{"file_contents":{"README.md":{"content":"# 🎯 CrowBot Gestion V2\n\n**CrowBot Gestion V2** est un bot Discord de modération et d'administration complet, développé en Python avec discord.py. Il offre un système de gestion avancé pour les serveurs Discord avec des fonctionnalités de modération, d'administration et de gestion des rôles.\n\n## 📋 Table des matières\n\n- [Fonctionnalités](#-fonctionnalités)\n- [Installation](#-installation)\n- [Configuration](#️-configuration)\n- [Structure du projet](#-structure-du-projet)\n- [Commandes disponibles](#-commandes-disponibles)\n- [Permissions et sécurité](#-permissions-et-sécurité)\n- [Architecture du code](#-architecture-du-code)\n- [Guide de développement](#-guide-de-développement)\n- [Troubleshooting](#-troubleshooting)\n- [Contribuer](#-contribuer)\n\n## 🚀 Fonctionnalités\n\n### 🎛️ **Administration**\n- Gestion des permissions par rôle\n- Configuration des cooldowns\n- Gestion du préfixe personnalisé\n- Réinitialisation des paramètres\n- Affichage des configurations\n\n### 🔨 **Modération**\n- Bannissement et débannissement\n- Expulsion des membres\n- Système de mute temporaire ou permanent\n- Système d'avertissements\n- Historique des infractions\n- Nettoyage de messages\n- Verrouillage/déverrouillage de salons\n\n### 👑 **Gestion des rôles**\n- Ajout et suppression de rôles\n- Création de rôles avec couleurs personnalisées\n- Suppression de rôles existants\n- Statistiques détaillées des rôles\n- Support des noms, mentions et IDs\n\n### 🛡️ **Sécurité**\n- Système de permissions hiérarchique\n- Vérification des rôles et positions\n- Logs détaillés de toutes les actions\n- Protection contre l'auto-modération\n- Messages d'erreur en français\n\n## 💻 Installation\n\n### Prérequis\n- Python 3.7 ou supérieur\n- discord.py 2.6+\n- SQLite3 (inclus avec Python)\n\n### Installation rapide\n\n1. **Clonez le projet**\n```bash\ngit clone <url-du-repo>\ncd crowbot-gestion-v2\n```\n\n2. **Installez les dépendances**\n```bash\npip install discord.py\n```\n\n3. **Configurez le bot**\n   - Créez une application Discord sur [Discord Developer Portal](https://discord.com/developers/applications)\n   - Récupérez le token du bot\n   - Configurez les variables d'environnement\n\n4. **Lancez le bot**\n```bash\npython main.py\n```\n\n## ⚙️ Configuration\n\n### Variables d'environnement\n\nCréez un fichier `.env` ou définissez les variables suivantes :\n\n```env\nDISCORD_TOKEN=votre_token_discord_ici\n```\n\n### Permissions Discord requises\n\nLe bot nécessite les permissions suivantes :\n- `Gérer les rôles`\n- `Expulser des membres`\n- `Bannir des membres` \n- `Gérer les messages`\n- `Gérer les salons`\n- `Lire l'historique des messages`\n- `Mentionner tout le monde`\n\n### Intents requis\n\n```python\nintents.message_content = True\nintents.members = True\nintents.guilds = True\n```\n\n## 📁 Structure du projet\n\n```\ncrowbot-gestion-v2/\n├── main.py                 # Point d'entrée principal\n├── bot.py                  # Classe principale du bot\n├── config.py               # Configuration et constantes\n├── database.py             # Gestion de la base de données SQLite\n├── cogs/                   # Modules de commandes\n│   ├── administration.py   # Commandes d'administration\n│   ├── moderation.py      # Commandes de modération\n│   ├── roles.py           # Gestion des rôles\n│   └── help.py            # Système d'aide\n├── utils/                  # Utilitaires\n│   ├── permissions.py     # Système de permissions\n│   ├── helpers.py         # Fonctions d'aide\n│   └── converters.py      # Convertisseurs personnalisés\n├── crowbot.db             # Base de données SQLite (auto-créée)\n├── crowbot.log            # Fichier de logs\n└── README.md              # Ce fichier\n```\n\n## 📚 Commandes disponibles\n\n### 🎛️ Administration\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `setperm` | Attribuer une permission | `+setperm <commande> <rôle>` |\n| `unsetperm` | Retirer une permission | `+unsetperm <commande> <rôle>` |\n| `perms` | Voir toutes les permissions | `+perms` |\n| `resetperms` | Réinitialiser les permissions | `+resetperms` |\n| `cooldown` | Définir un délai d'attente | `+cooldown <commande> <secondes>` |\n| `settings` | Voir les paramètres du serveur | `+settings` |\n| `prefix` | Changer le préfixe | `+prefix <nouveau_préfixe>` |\n\n### 🔨 Modération\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `ban` | Bannir un membre | `+ban <membre> [raison]` |\n| `unban` | Débannir un utilisateur | `+unban <id_utilisateur>` |\n| `kick` | Expulser un membre | `+kick <membre> [raison]` |\n| `mute` | Rendre muet un membre | `+mute <membre> [durée] [raison]` |\n| `unmute` | Enlever le mute | `+unmute <membre>` |\n| `warn` | Avertir un membre | `+warn <membre> [raison]` |\n| `infractions` | Voir l'historique d'un membre | `+infractions <membre>` |\n| `mutelist` | Liste des membres mués | `+mutelist` |\n| `clear` | Supprimer des messages | `+clear <nombre>` |\n| `lock` | Verrouiller un salon | `+lock [#salon]` |\n| `unlock` | Déverrouiller un salon | `+unlock [#salon]` |\n\n### 👑 Gestion des rôles\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `addrole` | Ajouter un rôle à un membre | `+addrole <membre> <rôle>` |\n| `delrole` | Retirer un rôle d'un membre | `+delrole <membre> <rôle>` |\n| `createrole` | Créer un nouveau rôle | `+createrole <nom> [couleur] [permissions]` |\n| `deleterole` | Supprimer un rôle | `+deleterole <rôle>` |\n| `rolestats` | Statistiques d'un rôle | `+rolestats <rôle>` |\n\n### 📚 Aide\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `help` | Menu d'aide principal | `+help [catégorie]` |\n| `help administration` | Aide administration | `+help administration` |\n| `help moderation` | Aide modération | `+help moderation` |\n| `help roles` | Aide gestion des rôles | `+help roles` |\n\n## 🔒 Permissions et sécurité\n\n### Système de permissions hiérarchique\n\n1. **Propriétaire du bot** : Accès total\n2. **Propriétaire du serveur** : Accès total sur son serveur  \n3. **Administrateurs** : Commandes d'administration et modération\n4. **Rôles personnalisés** : Selon configuration avec `setperm`\n\n### Protections intégrées\n\n- ✅ Vérification de la hiérarchie des rôles\n- ✅ Impossibilité d'auto-modération\n- ✅ Protection des rôles système\n- ✅ Validation des permissions Discord\n- ✅ Logs complets de toutes les actions\n\n### Format des durées\n\nPour les commandes temporaires (mute) :\n- `10s` = 10 secondes\n- `5m` = 5 minutes  \n- `2h` = 2 heures\n- `1d` = 1 jour\n- `1w` = 1 semaine\n\n### Couleurs disponibles pour les rôles\n\n**Noms prédéfinis :**\n`rouge`, `bleu`, `vert`, `jaune`, `orange`, `violet`, `rose`, `cyan`, `noir`, `blanc`\n\n**Format hexadécimal :**\n`#FF0000`, `#00FF00`, `#0000FF`, etc.\n\n## 🏗️ Architecture du code\n\n### Composants principaux\n\n#### `main.py`\nPoint d'entrée du bot qui :\n- Configure les logs\n- Récupère le token\n- Lance le bot avec gestion des erreurs\n\n#### `bot.py` - Classe CrowBot\nClasse principale héritant de `commands.Bot` :\n- Configuration des intents\n- Gestion des préfixes dynamiques\n- Chargement des cogs\n- Gestion globale des erreurs\n- Système de permissions personnalisé\n\n#### `database.py` - Gestion des données\nClasse Database avec SQLite :\n- Tables : guilds, permissions, cooldowns, infractions, mutes, logs\n- Opérations asynchrones avec verrous\n- Méthodes CRUD complètes\n\n#### `config.py` - Configuration\nCentralise toutes les configurations :\n- Couleurs des embeds\n- Listes de commandes par catégorie\n- Unités de temps\n- Préfixe par défaut\n\n### Structure des Cogs\n\nChaque cog représente une catégorie de fonctionnalités :\n\n```python\nclass MonCog(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command()\n    @has_permission()  # Décorateur de permissions\n    async def ma_commande(self, ctx, arg: CustomConverter):\n        # Logique de la commande\n        pass\n```\n\n### Système de permissions\n\n#### Décorateurs disponibles\n\n```python\n@has_permission()    # Vérifie permissions + cooldown\n@admin_only()        # Administrateurs uniquement\n```\n\n#### Convertisseurs personnalisés\n\n```python\nMemberConverter     # Membre par nom/mention/ID\nRoleConverter       # Rôle par nom/mention/ID  \nUserConverter       # Utilisateur par nom/ID\n```\n\n## 🛠️ Guide de développement\n\n### Ajouter une nouvelle commande\n\n1. **Choisir le cog approprié** ou créer un nouveau\n2. **Définir la commande avec décorateurs**\n3. **Implémenter la logique métier**\n4. **Ajouter les vérifications de sécurité**\n5. **Logger l'action si nécessaire**\n6. **Mettre à jour l'aide**\n\n#### Exemple complet\n\n```python\n@commands.command(name=\"macommande\")\n@has_permission()\nasync def ma_commande(self, ctx, membre: MemberConverter, *, raison: str = \"Aucune raison\"):\n    \"\"\"Description de ma commande\"\"\"\n    \n    # Vérifications de sécurité\n    if membre == ctx.author:\n        embed = discord.Embed(\n            title=\"❌ Erreur\",\n            description=\"Vous ne pouvez pas vous cibler vous-même.\",\n            color=self.bot.config.error_color\n        )\n        await ctx.send(embed=embed)\n        return\n    \n    try:\n        # Logique principale\n        # ... votre code ici ...\n        \n        # Log de l'action\n        await self.bot.db.log_moderation_action(\n            ctx.guild.id, membre.id, ctx.author.id, \"macommande\", raison\n        )\n        \n        # Confirmation\n        embed = discord.Embed(\n            title=\"✅ Succès\",\n            description=f\"Action réalisée sur **{membre}**.\",\n            color=self.bot.config.success_color\n        )\n        embed.add_field(name=\"Raison\", value=raison, inline=False)\n        await ctx.send(embed=embed)\n        \n    except Exception as e:\n        embed = discord.Embed(\n            title=\"❌ Erreur\",\n            description=f\"Échec de l'opération : {str(e)}\",\n            color=self.bot.config.error_color\n        )\n        await ctx.send(embed=embed)\n```\n\n### Ajouter un nouveau cog\n\n1. **Créer le fichier** `cogs/mon_cog.py`\n2. **Implémenter la classe** héritant de `commands.Cog`\n3. **Ajouter la fonction setup**\n4. **Charger dans bot.py**\n5. **Mettre à jour l'aide**\n\n#### Template de cog\n\n```python\nimport discord\nfrom discord.ext import commands\nfrom utils.permissions import has_permission\nfrom utils.converters import MemberConverter\n\nclass MonCog(commands.Cog):\n    \"\"\"Description de mon cog\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"test\")\n    @has_permission()\n    async def test_command(self, ctx):\n        \"\"\"Commande de test\"\"\"\n        await ctx.send(\"Commande test fonctionnelle !\")\n\nasync def setup(bot):\n    await bot.add_cog(MonCog(bot))\n```\n\n### Étendre la base de données\n\nPour ajouter une nouvelle table :\n\n```python\n# Dans database.py, méthode initialize()\ncursor.execute('''\n    CREATE TABLE IF NOT EXISTS ma_table (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        guild_id INTEGER,\n        user_id INTEGER,\n        data TEXT,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n''')\n```\n\nAjouter les méthodes CRUD correspondantes.\n\n### Tests et debugging\n\n#### Logs disponibles\n\n```python\nself.bot.logger.info(\"Message d'information\")\nself.bot.logger.warning(\"Avertissement\")\nself.bot.logger.error(\"Erreur\")\n```\n\nLes logs sont écrits dans `crowbot.log` et la console.\n\n#### Variables d'environnement de debug\n\n```env\nDISCORD_TOKEN=votre_token\nDEBUG=1  # Active le mode debug (optionnel)\n```\n\n## 🔧 Troubleshooting\n\n### Problèmes courants\n\n#### Le bot ne se connecte pas\n- Vérifiez le token Discord\n- Vérifiez les intents dans le Developer Portal\n- Vérifiez que le bot a été invité sur le serveur\n\n#### Commandes ne fonctionnent pas\n- Vérifiez le préfixe configuré (`+settings`)\n- Vérifiez les permissions Discord du bot\n- Vérifiez les permissions personnalisées (`+perms`)\n\n#### Erreurs de base de données\n- Vérifiez les permissions d'écriture du dossier\n- Supprimez `crowbot.db` pour réinitialiser (⚠️ perte de données)\n\n#### Erreurs de permissions\n- Vérifiez la position du rôle du bot\n- Vérifiez que le bot a les permissions Discord nécessaires\n- Vérifiez la hiérarchie des rôles\n\n### Messages d'erreur fréquents\n\n#### \"Membre introuvable\"\nL'utilisateur saisi n'existe pas sur le serveur ou le nom est incorrect.\n\n#### \"Rôle introuvable\"  \nLe rôle saisi n'existe pas ou le nom est incorrect.\n\n#### \"Permission insuffisante\"\nLe bot n'a pas les permissions Discord nécessaires pour cette action.\n\n#### \"Argument requis manquant\"\nUne commande a été utilisée sans tous ses arguments obligatoires.\n\n### Commandes de diagnostic\n\n```bash\n# Vérifier les permissions\n+settings\n\n# Voir les permissions personnalisées\n+perms\n\n# Tester une commande simple\n+help\n```\n\n## 📝 Changelog\n\n### Version 2.0\n- ✅ Système de gestion des rôles complet\n- ✅ Convertisseurs personnalisés pour noms/mentions/IDs\n- ✅ Messages d'erreur en français\n- ✅ Commande help avec menu par catégories\n- ✅ Amélioration du système de permissions\n- ✅ Logs détaillés de toutes les actions\n\n### Version 1.0\n- ✅ Système de modération complet\n- ✅ Gestion des permissions par rôle\n- ✅ Base de données SQLite\n- ✅ Système d'infractions et mutes\n- ✅ Configuration par serveur\n\n## 📄 License\n\nCe projet est sous licence MIT. Voir le fichier `LICENSE` pour plus de détails.\n\n## 🤝 Contribuer\n\nLes contributions sont les bienvenues ! \n\n1. **Fork** le projet\n2. **Créer** une branche feature (`git checkout -b feature/AmazingFeature`)\n3. **Commit** vos changements (`git commit -m 'Add AmazingFeature'`)\n4. **Push** vers la branche (`git push origin feature/AmazingFeature`)\n5. **Ouvrir** une Pull Request\n\n### Guidelines de contribution\n\n- Respecter le style de code existant\n- Ajouter des tests pour les nouvelles fonctionnalités\n- Mettre à jour la documentation\n- S'assurer que tous les tests passent\n\n## 📞 Support\n\nPour obtenir de l'aide :\n\n1. Consulter ce README\n2. Vérifier les [Issues GitHub](lien-vers-issues)\n3. Utiliser la commande `+help` dans Discord\n4. Consulter les logs dans `crowbot.log`\n\n---\n\n**Développé avec ❤️ en Python | Powered by discord.py**","size_bytes":14402},"bot.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nimport logging\nfrom database import Database\nfrom config import Config\n\nclass CrowBot(commands.Bot):\n    def __init__(self):\n        # Initialize with default prefix, will be updated from database\n        intents = discord.Intents.default()\n        intents.message_content = True\n        intents.members = True\n        intents.guilds = True\n        \n        super().__init__(\n            command_prefix=self.get_prefix,\n            intents=intents,\n            help_command=None\n        )\n        \n        self.db = Database()\n        self.config = Config()\n        self.logger = logging.getLogger('chdfz gestion')\n        \n    async def get_prefix(self, message):\n        \"\"\"Get the prefix for a guild\"\"\"\n        if message.guild is None:\n            return self.config.default_prefix\n        \n        prefix = await self.db.get_guild_prefix(message.guild.id)\n        return prefix or self.config.default_prefix\n    \n    async def setup_hook(self):\n        await self.db.initialize()\n        cogs = [\n            'cogs.administration',\n            'cogs.moderation',\n            'cogs.roles',\n            'cogs.help_interactive',\n            'cogs.triggers',\n            'cogs.ownership',\n            'cogs.permissions_crowbots'\n        ]\n\n        for cog in cogs:\n            if cog not in self.extensions:  # ← empêche le rechargement\n                try:\n                    await self.load_extension(cog)\n                    self.logger.info(f\"Loaded cog: {cog}\")\n                except Exception as e:\n                    self.logger.error(f\"Failed to load cog {cog}: {e}\")\n    \n    async def on_ready(self):\n        \"\"\"Called when the bot is ready\"\"\"\n        self.logger.info(f'{self.user.name if self.user else \"Bot\"} has connected to Discord!')\n        self.logger.info(f'Bot is in {len(self.guilds)} guilds')\n        \n        # Set bot status\n        await self.change_presence(\n            activity=discord.Activity(\n                type=discord.ActivityType.watching,\n                name=\"for infractions | +help\"\n            )\n        )\n    \n    async def on_guild_join(self, guild):\n        \"\"\"Called when the bot joins a new guild\"\"\"\n        self.logger.info(f\"Joined guild: {guild.name} (ID: {guild.id})\")\n        await self.db.setup_guild(guild.id)\n    \n    async def on_command_error(self, ctx, error):\n        \"\"\"Global error handler\"\"\"\n        if isinstance(error, commands.CommandNotFound):\n            return\n        \n        if isinstance(error, commands.CheckFailure):\n            # Don't send error message for check failures, already handled by custom checks\n            return\n        \n        if isinstance(error, commands.MissingPermissions):\n            perms = \", \".join(error.missing_permissions)\n            await ctx.send(f\"❌ **Permissions manquantes :** `{perms}`\\n💡 Vous devez avoir ces permissions pour utiliser cette commande.\")\n            return\n        \n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send(f\"❌ **Argument manquant :** `{error.param.name}`\\n💡 Utilisez `+help` pour voir la syntaxe correcte.\")\n            return\n        \n        if isinstance(error, commands.BadArgument):\n            await ctx.send(f\"❌ **Argument invalide :** {error}\\n💡 Vérifiez la syntaxe de votre commande.\")\n            return\n        \n        if isinstance(error, commands.CommandOnCooldown):\n            await ctx.send(f\"❌ **Commande en cooldown**\\n⏰ Réessayez dans {error.retry_after:.1f} secondes.\")\n            return\n        \n        # Handle custom converter errors\n        if isinstance(error, commands.MemberNotFound):\n            await ctx.send(f\"❌ **Membre introuvable :** {error}\")\n            return\n        \n        if isinstance(error, commands.RoleNotFound):\n            await ctx.send(f\"❌ **Rôle introuvable :** {error}\")\n            return\n        \n        if isinstance(error, commands.UserNotFound):\n            await ctx.send(f\"❌ **Utilisateur introuvable :** {error}\")\n            return\n        \n        # Enhanced error logging with more details\n        self.logger.error(f\"Unhandled error in command '{ctx.command}' by {ctx.author} ({ctx.author.id}) in {ctx.guild.name if ctx.guild else 'DM'}: {error}\")\n        await ctx.send(f\"❌ **Erreur inattendue**\\n🔧 Détails : `{str(error)[:100]}...`\\n💡 Contactez l'administrateur si le problème persiste.\")\n    \n    async def check_permissions(self, ctx, command_name):\n        \"\"\"Check if user has permission to use a command\"\"\"\n        # Initialize default permissions if not set\n        existing_perms = await self.db.get_all_command_permissions(ctx.guild.id)\n        if not existing_perms:\n            await self.db.initialize_default_permissions(ctx.guild.id)\n        \n        # Bot owner always has permission\n        if await self.is_owner(ctx.author):\n            return True\n        \n        # Server owner always has permission  \n        if ctx.author == ctx.guild.owner:\n            return True\n        \n        # Check buyer permission\n        if await self.is_buyer_user(ctx.author.id):\n            return True\n        \n        # Check owner permission\n        if await self.is_owner_user(ctx.author.id):\n            command_level = await self.db.get_command_permission_level(ctx.guild.id, command_name)\n            if command_level in ['owner', 'buyer', 'public', 'everyone'] or command_level.startswith('perm'):\n                return True\n        \n        # Get command permission level\n        command_level = await self.db.get_command_permission_level(ctx.guild.id, command_name)\n        if not command_level:\n            return True  # Default allow if no permission set\n        \n        # Check specific command permissions (role/user specific)\n        specific_perms = await self.db.get_command_specific_permissions(ctx.guild.id, command_name)\n        user_roles = [role.id for role in ctx.author.roles]\n        \n        # Check if user has specific permission for this command\n        if ctx.author.id in specific_perms.get('users', []):\n            return True\n        \n        # Check if user has role with specific permission for this command\n        if any(role_id in specific_perms.get('roles', []) for role_id in user_roles):\n            return True\n        \n        # Handle special permission levels\n        if command_level == 'everyone':\n            return True\n        \n        if command_level == 'public':\n            return True  # TODO: Add public channel check if needed\n        \n        if command_level == 'owner':\n            return await self.is_owner_user(ctx.author.id)\n        \n        if command_level == 'buyer':\n            return await self.is_buyer_user(ctx.author.id)\n        \n        # Handle permission levels (perm1-perm9)\n        if command_level.startswith('perm'):\n            try:\n                required_level = int(command_level[4:])  # Extract number from \"perm1\", \"perm2\", etc.\n                user_max_level = await self.get_user_max_permission_level(ctx.author, ctx.guild.id)\n                \n                # Hierarchical: higher levels include lower levels\n                return user_max_level >= required_level\n            except (ValueError, TypeError):\n                return False\n        \n        return False\n    \n    async def get_user_max_permission_level(self, user, guild_id):\n        \"\"\"Get user's highest permission level\"\"\"\n        # Get all permission levels for the guild\n        permission_levels = await self.db.get_permission_levels(guild_id)\n        \n        user_roles = [role.id for role in user.roles]\n        max_level = 0\n        \n        for level, data in permission_levels.items():\n            # Check if user has this level through role or direct assignment\n            has_level = (\n                user.id in data.get('users', []) or\n                any(role_id in data.get('roles', []) for role_id in user_roles)\n            )\n            \n            if has_level and level > max_level:\n                max_level = level\n        \n        return max_level\n    \n    async def check_cooldown(self, ctx, command_name):\n        \"\"\"Check if command is on cooldown for user\"\"\"\n        cooldown_time = await self.db.get_command_cooldown(ctx.guild.id, command_name)\n        if not cooldown_time:\n            return True\n        \n        last_used = await self.db.get_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n        if not last_used:\n            await self.db.update_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n            return True\n        \n        import time\n        if time.time() - last_used < cooldown_time:\n            return False\n        \n        await self.db.update_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n        return True\n","size_bytes":8823},"config.py":{"content":"class Config:\n    def __init__(self):\n        self.default_prefix = \"+\"\n        self.bot_description = \"CrowBot Gestion V2 - Discord Moderation Bot\"\n        self.embed_color = 0x2F3136\n        self.error_color = 0xFF0000\n        self.success_color = 0x00FF00\n        self.warning_color = 0xFFFF00\n        \n        # Command categories\n        self.moderation_commands = [\n            'ban', 'unban', 'kick', 'mute', 'unmute', 'warn', \n            'clear', 'lock', 'unlock', 'infractions', 'mutelist'\n        ]\n        \n        self.admin_commands = [\n            'setperm', 'unsetperm', 'perms', 'resetperms', \n            'cooldown', 'settings', 'prefix'\n        ]\n        \n        # Time parsing formats\n        self.time_units = {\n            's': 1,\n            'm': 60,\n            'h': 3600,\n            'd': 86400,\n            'w': 604800\n        }\n","size_bytes":856},"database.py":{"content":"import sqlite3\nimport asyncio\nimport json\nimport time\nimport secrets\nfrom typing import List, Optional, Dict, Any\n\nclass Database:\n    def __init__(self, db_path: str = \"crowbot.db\"):\n        self.db_path = db_path\n        self._lock = asyncio.Lock()\n    \n    async def initialize(self):\n        \"\"\"Initialize the database with required tables\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Guild settings table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS guild_settings (\n                    guild_id INTEGER PRIMARY KEY,\n                    prefix TEXT DEFAULT '+',\n                    log_channel_id INTEGER,\n                    mute_role_id INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Permission levels table (perm 1-9)\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS permission_levels (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    level INTEGER,\n                    role_id INTEGER,\n                    user_id INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, level, role_id),\n                    UNIQUE(guild_id, level, user_id)\n                )\n            ''')\n            \n            # Command permissions table - now maps commands to permission levels\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_permissions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    command_name TEXT,\n                    permission_level TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, command_name)\n                )\n            ''')\n            \n            # Command-specific permissions (for individual roles/users)\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_specific_permissions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    command_name TEXT,\n                    role_id INTEGER,\n                    user_id INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, command_name, role_id),\n                    UNIQUE(guild_id, command_name, user_id)\n                )\n            ''')\n            \n            # Command cooldowns table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_cooldowns (\n                    guild_id INTEGER,\n                    command_name TEXT,\n                    cooldown_seconds INTEGER,\n                    PRIMARY KEY(guild_id, command_name)\n                )\n            ''')\n            \n            # Command usage tracking\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_usage (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    command_name TEXT,\n                    last_used TIMESTAMP,\n                    PRIMARY KEY(guild_id, user_id, command_name)\n                )\n            ''')\n            \n            # Infractions table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS infractions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    moderator_id INTEGER,\n                    infraction_type TEXT,\n                    reason TEXT,\n                    duration INTEGER,\n                    active BOOLEAN DEFAULT 1,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Muted users table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS muted_users (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    muted_until TIMESTAMP,\n                    reason TEXT,\n                    moderator_id INTEGER,\n                    PRIMARY KEY(guild_id, user_id)\n                )\n            ''')\n            \n            # Moderation logs\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS moderation_logs (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    moderator_id INTEGER,\n                    action TEXT,\n                    reason TEXT,\n                    details TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Bot ownership tables\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS bot_ownership (\n                    guild_id INTEGER PRIMARY KEY,\n                    buyer_id INTEGER,\n                    recovery_code TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Owners table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS owners (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Whitelist table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS whitelist (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Blacklist rank table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS blacklist_rank (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Leash system table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS leash_system (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    owner_id INTEGER,\n                    original_nick TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    PRIMARY KEY(guild_id, user_id)\n                )\n            ''')\n            \n            conn.commit()\n            conn.close()\n    \n    # Extensions from database_extensions.py\n    # Bot Ownership methods\n    async def set_buyer(self, guild_id: int, buyer_id: int) -> str:\n        \"\"\"Set the buyer/owner of the bot for a guild and generate recovery code\"\"\"\n        recovery_code = secrets.token_hex(16)\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO bot_ownership (guild_id, buyer_id, recovery_code)\n                VALUES (?, ?, ?)\n            ''', (guild_id, buyer_id, recovery_code))\n            \n            conn.commit()\n            conn.close()\n            \n        return recovery_code\n    \n    async def get_buyer(self, guild_id: int) -> Optional[int]:\n        \"\"\"Get the buyer ID for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT buyer_id FROM bot_ownership WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def verify_recovery_code(self, guild_id: int, code: str) -> bool:\n        \"\"\"Verify recovery code for buyer transfer\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT recovery_code FROM bot_ownership WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result and result[0] == code\n    \n    # Owners methods\n    async def add_owner(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO owners (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_owner(self, guild_id: int, user_id: int):\n        \"\"\"Remove an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM owners WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_owner(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM owners WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_owners(self, guild_id: int) -> List[int]:\n        \"\"\"Get all owners for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM owners WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Whitelist methods\n    async def add_whitelist(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add user to whitelist\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO whitelist (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_whitelist(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from whitelist\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM whitelist WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_whitelisted(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is whitelisted\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM whitelist WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_whitelist(self, guild_id: int) -> List[int]:\n        \"\"\"Get all whitelisted users\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM whitelist WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Blacklist rank methods\n    async def add_blacklist_rank(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add user to blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO blacklist_rank (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_blacklist_rank(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM blacklist_rank WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_blacklist_rank(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is in blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM blacklist_rank WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_blacklist_rank(self, guild_id: int) -> List[int]:\n        \"\"\"Get all blacklisted rank users\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM blacklist_rank WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Leash system methods\n    async def add_leash(self, guild_id: int, user_id: int, owner_id: int, original_nick: str):\n        \"\"\"Put user on leash\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO leash_system (guild_id, user_id, owner_id, original_nick)\n                VALUES (?, ?, ?, ?)\n            ''', (guild_id, user_id, owner_id, original_nick))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_leash(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from leash\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM leash_system WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_leash_info(self, guild_id: int, user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get leash info for user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT owner_id, original_nick FROM leash_system \n                WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            if result:\n                return {\n                    'owner_id': result[0],\n                    'original_nick': result[1]\n                }\n            return None\n    \n    async def is_leashed(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is leashed\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM leash_system WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def setup_guild(self, guild_id: int):\n        \"\"\"Setup a new guild in the database\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO guild_settings (guild_id) VALUES (?)\n            ''', (guild_id,))\n            \n            conn.commit()\n            conn.close()\n    \n    # Guild settings methods\n    async def get_guild_prefix(self, guild_id: int) -> Optional[str]:\n        \"\"\"Get the prefix for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT prefix FROM guild_settings WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def set_guild_prefix(self, guild_id: int, prefix: str):\n        \"\"\"Set the prefix for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO guild_settings (guild_id, prefix) VALUES (?, ?)\n            ''', (guild_id, prefix))\n            \n            conn.commit()\n            conn.close()\n    \n    # Permission Level methods\n    async def set_permission_level(self, guild_id: int, level: int, role_id: int = None, user_id: int = None):\n        \"\"\"Set a role or user to a permission level\"\"\"\n        level_name = f\"perm{level}\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            if role_id:\n                cursor.execute('''\n                    INSERT OR REPLACE INTO permission_levels (guild_id, level_name, role_id) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, level_name, role_id))\n            elif user_id:\n                cursor.execute('''\n                    INSERT OR REPLACE INTO permission_levels (guild_id, level_name, user_id) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, level_name, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_permission_level(self, guild_id: int, level: int, role_id: int = None, user_id: int = None):\n        \"\"\"Remove a role or user from a permission level\"\"\"\n        level_name = f\"perm{level}\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            if role_id:\n                cursor.execute('''\n                    DELETE FROM permission_levels \n                    WHERE guild_id = ? AND level_name = ? AND role_id = ?\n                ''', (guild_id, level_name, role_id))\n            elif user_id:\n                cursor.execute('''\n                    DELETE FROM permission_levels \n                    WHERE guild_id = ? AND level_name = ? AND user_id = ?\n                ''', (guild_id, level_name, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_permission_levels(self, guild_id: int) -> Dict[int, Dict]:\n        \"\"\"Get all permission levels for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT level_name, role_id, user_id FROM permission_levels \n                WHERE guild_id = ?\n                ORDER BY level_name\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            levels = {}\n            for level_name, role_id, user_id in results:\n                # Convert \"perm1\" to 1\n                if level_name.startswith('perm'):\n                    try:\n                        level_num = int(level_name[4:])\n                        if level_num not in levels:\n                            levels[level_num] = {'roles': [], 'users': []}\n                        if role_id:\n                            levels[level_num]['roles'].append(role_id)\n                        if user_id:\n                            levels[level_num]['users'].append(user_id)\n                    except ValueError:\n                        pass\n            \n            return levels\n    \n    async def set_command_permission(self, guild_id: int, command_name: str, permission_level: str):\n        \"\"\"Set command to a permission level\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO command_permissions (guild_id, command_name, permission_level) \n                VALUES (?, ?, ?)\n            ''', (guild_id, command_name, permission_level))\n            \n            conn.commit()\n            conn.close()\n    \n    async def set_command_specific_permission(self, guild_id: int, command_name: str, role_id: int = None, user_id: int = None):\n        \"\"\"Set specific permission for a command to a role or user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            if role_id:\n                cursor.execute('''\n                    INSERT OR REPLACE INTO command_specific_permissions (guild_id, command_name, role_id) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, command_name, role_id))\n            elif user_id:\n                cursor.execute('''\n                    INSERT OR REPLACE INTO command_specific_permissions (guild_id, command_name, user_id) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, command_name, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_command_specific_permission(self, guild_id: int, command_name: str, role_id: int = None, user_id: int = None):\n        \"\"\"Remove specific permission for a command from a role or user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            if role_id:\n                cursor.execute('''\n                    DELETE FROM command_specific_permissions \n                    WHERE guild_id = ? AND command_name = ? AND role_id = ?\n                ''', (guild_id, command_name, role_id))\n            elif user_id:\n                cursor.execute('''\n                    DELETE FROM command_specific_permissions \n                    WHERE guild_id = ? AND command_name = ? AND user_id = ?\n                ''', (guild_id, command_name, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_command_permission_level(self, guild_id: int, command_name: str) -> str:\n        \"\"\"Get permission level for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT permission_level FROM command_permissions \n                WHERE guild_id = ? AND command_name = ?\n            ''', (guild_id, command_name))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def get_all_command_permissions(self, guild_id: int) -> Dict[str, str]:\n        \"\"\"Get all command permissions for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT command_name, permission_level FROM command_permissions \n                WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return {command_name: permission_level for command_name, permission_level in results}\n    \n    async def get_command_specific_permissions(self, guild_id: int, command_name: str) -> Dict:\n        \"\"\"Get specific permissions for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT role_id, user_id FROM command_specific_permissions \n                WHERE guild_id = ? AND command_name = ?\n            ''', (guild_id, command_name))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            permissions = {'roles': [], 'users': []}\n            for role_id, user_id in results:\n                if role_id:\n                    permissions['roles'].append(role_id)\n                if user_id:\n                    permissions['users'].append(user_id)\n            \n            return permissions\n    \n    async def reset_permissions(self, guild_id: int):\n        \"\"\"Reset all permissions for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('DELETE FROM permission_levels WHERE guild_id = ?', (guild_id,))\n            cursor.execute('DELETE FROM command_permissions WHERE guild_id = ?', (guild_id,))\n            cursor.execute('DELETE FROM command_specific_permissions WHERE guild_id = ?', (guild_id,))\n            \n            conn.commit()\n            conn.close()\n    \n    async def initialize_default_permissions(self, guild_id: int):\n        \"\"\"Initialize default command permissions\"\"\"\n        defaults = {\n            # Perm 1 - Basic moderation\n            'clear': 'perm1',\n            'warn': 'perm1', \n            'mute': 'perm1',\n            \n            # Perm 2 - Full moderation\n            'kick': 'perm2',\n            'ban': 'perm2',\n            'unban': 'perm2',\n            'unmute': 'perm2',\n            'delwarn': 'perm2',\n            'infractions': 'perm2',\n            'mutelist': 'perm2',\n            'lock': 'perm2',\n            'unlock': 'perm2',\n            \n            # Perm 3 - Administration\n            'setperm': 'perm3',\n            'delperm': 'perm3',\n            'clearperm': 'perm3',\n            'change': 'perm3',\n            'changeall': 'perm3',\n            'resetperms': 'perm3',\n            'setcooldown': 'perm3',\n            'settings': 'perm3',\n            'prefix': 'perm3',\n            'addrole': 'perm3',\n            'delrole': 'perm3',\n            'massrole': 'perm3',\n            \n            # Owners only\n            'say': 'owner',\n            'dm': 'owner',\n            'laisse': 'owner',\n            'unlaisse': 'owner',\n            'wl': 'owner',\n            'unwl': 'owner',\n            'blrank': 'owner',\n            \n            # Buyer only\n            'owner': 'buyer',\n            'unowner': 'buyer',\n            'buyer': 'buyer',\n            \n            # Public commands\n            'help': 'public',\n            'helpall': 'public',\n            'ping': 'public',\n            'perms': 'public'\n        }\n        \n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            for command, perm_level in defaults.items():\n                cursor.execute('''\n                    INSERT OR IGNORE INTO command_permissions (guild_id, command_name, permission_level) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, command, perm_level))\n            \n            conn.commit()\n            conn.close()\n    \n    # Cooldown methods\n    async def set_command_cooldown(self, guild_id: int, command_name: str, cooldown_seconds: int):\n        \"\"\"Set cooldown for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO command_cooldowns (guild_id, command_name, cooldown_seconds) \n                VALUES (?, ?, ?)\n            ''', (guild_id, command_name, cooldown_seconds))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_command_cooldown(self, guild_id: int, command_name: str) -> Optional[int]:\n        \"\"\"Get cooldown for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT cooldown_seconds FROM command_cooldowns \n                WHERE guild_id = ? AND command_name = ?\n            ''', (guild_id, command_name))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def get_last_command_use(self, guild_id: int, user_id: int, command_name: str) -> Optional[float]:\n        \"\"\"Get last time user used a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT last_used FROM command_usage \n                WHERE guild_id = ? AND user_id = ? AND command_name = ?\n            ''', (guild_id, user_id, command_name))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return float(result[0]) if result else None\n    \n    async def update_last_command_use(self, guild_id: int, user_id: int, command_name: str):\n        \"\"\"Update last command use time\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO command_usage (guild_id, user_id, command_name, last_used) \n                VALUES (?, ?, ?, ?)\n            ''', (guild_id, user_id, command_name, time.time()))\n            \n            conn.commit()\n            conn.close()\n    \n    # Infraction methods\n    async def add_infraction(self, guild_id: int, user_id: int, moderator_id: int, \n                           infraction_type: str, reason: Optional[str] = None, duration: Optional[int] = None):\n        \"\"\"Add an infraction\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT INTO infractions (guild_id, user_id, moderator_id, infraction_type, reason, duration) \n                VALUES (?, ?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, moderator_id, infraction_type, reason, duration))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_user_infractions(self, guild_id: int, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all infractions for a user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT infraction_type, reason, duration, created_at, moderator_id \n                FROM infractions \n                WHERE guild_id = ? AND user_id = ? \n                ORDER BY created_at DESC\n            ''', (guild_id, user_id))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            infractions = []\n            for result in results:\n                infractions.append({\n                    'type': result[0],\n                    'reason': result[1],\n                    'duration': result[2],\n                    'created_at': result[3],\n                    'moderator_id': result[4]\n                })\n            \n            return infractions\n    \n    async def get_user_warnings(self, guild_id: int, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all warnings for a user with IDs\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT id, reason, created_at, moderator_id \n                FROM infractions \n                WHERE guild_id = ? AND user_id = ? AND infraction_type = 'warn' AND active = 1\n                ORDER BY created_at DESC\n            ''', (guild_id, user_id))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            warnings = []\n            for result in results:\n                warnings.append({\n                    'id': result[0],\n                    'reason': result[1],\n                    'created_at': result[2],\n                    'moderator_id': result[3]\n                })\n            \n            return warnings\n    \n    async def remove_warning(self, guild_id: int, warning_id: int) -> bool:\n        \"\"\"Remove a specific warning by ID\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # First check if the warning exists and is active\n            cursor.execute('''\n                SELECT user_id FROM infractions \n                WHERE id = ? AND guild_id = ? AND infraction_type = 'warn' AND active = 1\n            ''', (warning_id, guild_id))\n            \n            result = cursor.fetchone()\n            if not result:\n                conn.close()\n                return False\n            \n            # Mark the warning as inactive instead of deleting\n            cursor.execute('''\n                UPDATE infractions SET active = 0 \n                WHERE id = ? AND guild_id = ?\n            ''', (warning_id, guild_id))\n            \n            conn.commit()\n            conn.close()\n            return True\n    \n    # Mute methods\n    async def add_mute(self, guild_id: int, user_id: int, muted_until: Optional[float], \n                      reason: str, moderator_id: int):\n        \"\"\"Add a mute\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO muted_users (guild_id, user_id, muted_until, reason, moderator_id) \n                VALUES (?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, muted_until, reason, moderator_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_mute(self, guild_id: int, user_id: int):\n        \"\"\"Remove a mute\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM muted_users WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_muted_users(self, guild_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all muted users in a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id, muted_until, reason, moderator_id \n                FROM muted_users WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            muted_users = []\n            for result in results:\n                muted_users.append({\n                    'user_id': result[0],\n                    'muted_until': result[1],\n                    'reason': result[2],\n                    'moderator_id': result[3]\n                })\n            \n            return muted_users\n    \n    async def is_user_muted(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is muted\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT muted_until FROM muted_users \n                WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            if not result:\n                return False\n            \n            muted_until = result[0]\n            if muted_until and float(muted_until) < time.time():\n                await self.remove_mute(guild_id, user_id)\n                return False\n            \n            return True\n    \n    # Logging methods\n    async def log_moderation_action(self, guild_id: int, user_id: int, moderator_id: int, \n                                  action: str, reason: Optional[str] = None, details: Optional[str] = None):\n        \"\"\"Log a moderation action\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT INTO moderation_logs (guild_id, user_id, moderator_id, action, reason, details) \n                VALUES (?, ?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, moderator_id, action, reason, details))\n            \n            conn.commit()\n            conn.close()\n    \n","size_bytes":38357},"main.py":{"content":"import asyncio\nimport logging\nimport os\nfrom bot import CrowBot\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('crowbot.log'),\n        logging.StreamHandler()\n    ]\n)\n\nasync def main():\n    \"\"\"Main entry point for the bot\"\"\"\n    token = os.getenv('DISCORD_TOKEN')\n    if not token:\n        logging.error(\"DISCORD_TOKEN environment variable not set!\")\n        return\n    \n    bot = CrowBot()\n    \n    try:\n        await bot.start(token)\n    except KeyboardInterrupt:\n        logging.info(\"Bot stopped by user\")\n    except Exception as e:\n        logging.error(f\"Bot encountered an error: {e}\")\n    finally:\n        await bot.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":813},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"discord-py>=2.6.2\",\n]\n","size_bytes":169},"replit.md":{"content":"# chdfz gestion - Discord Bot\n\n## Overview\nchdfz gestion est un bot Discord de modération avancée avec système de gestion hiérarchique et fonctionnalités anti-raid. Le bot utilise Python avec discord.py et une base de données SQLite pour la persistance.\n\n## Recent Changes (26 août 2025)\n- ✅ Migration vers Replit complétée\n- ✅ Nouvelles commandes ownership/administration avancées ajoutées\n- ✅ Système de buyers/owners implémenté\n- ✅ Système de whitelist/blacklist ajouté\n- ✅ Système de \"laisse\" pour contrôler les pseudos\n- ✅ Commandes de communication anonyme (say, dm)\n- ✅ Réponses simplifiées pour commandes principales\n- ✅ Commande massrole pour attribution de rôles en masse\n- ✅ **NOUVEAU** : Système de permissions hiérarchiques (perm 1-9) implémenté\n- ✅ Interface française complète - plus de textes en anglais\n- ✅ Refonte complète du système de permissions selon doc CrowBots\n- ✅ **Migration Replit Agent terminée** - Base de données réparée, logs optimisés\n- ✅ **Cogs administration fonctionnel** - Erreurs SQLite corrigées\n- ✅ **Performance optimisée** - Plus de spam de logs, traitement messages efficace\n- ✅ **SYSTÈME CROWBOTS COMPLET** - Intégration finale dans administration.py\n- ✅ **Structure unifiée** - Plus de cogs en doublon, tout centralisé\n\n## Project Architecture\n\n### Core Files\n- `main.py` - Point d'entrée principal\n- `bot.py` - Classe principale du bot\n- `database.py` - Gestion de la base de données SQLite\n- `config.py` - Configuration du bot\n\n### Cogs (Modules)\n- `cogs/administration.py` - Commandes d'administration\n- `cogs/moderation.py` - Commandes de modération\n- `cogs/roles.py` - Gestion des rôles\n- `cogs/help.py` - Système d'aide\n- `cogs/triggers.py` - Système de triggers/réponses automatiques\n- `cogs/ownership.py` - **NOUVEAU** Commandes avancées ownership\n\n### Utilities\n- `utils/permissions.py` - Système de permissions\n- `utils/helpers.py` - Fonctions utilitaires\n- `utils/converters.py` - Convertisseurs Discord\n\n## User Preferences\n- Réponses simplifiées préférées pour les commandes de base\n- Interface en français\n- Messages d'erreur clairs et concis\n\n## Database Schema\n- Tables existantes : guild_settings, command_cooldowns, command_usage, infractions, muted_users, moderation_logs\n- Tables ownership : bot_ownership, owners, whitelist, blacklist_rank, leash_system\n- **Tables permissions hiérarchiques** : permission_levels, command_permissions (refonte), command_specific_permissions\n\n## Nouvelles Fonctionnalités Implémentées\n\n### Système Hiérarchique\n- **buyer** : Propriétaire principal du bot avec code de récupération\n- **owners** : Utilisateurs avec privilèges étendus\n- **whitelist** : Utilisateurs immunisés contre l'anti-raid\n\n### Système de Permissions Hiérarchiques (NOUVEAU)\n- **9 niveaux de permissions** : perm1 à perm9 (hiérarchique)\n- **Niveaux spéciaux** : owner, buyer, public, everyone\n- **Attribution flexible** : par rôle ou utilisateur individuel\n\n#### Commandes de Configuration des Permissions (CrowBots Compatible)\n- `+set perm <niveau> <@role/@user>` - Assigner niveau à un rôle/utilisateur\n- `+set perm <commande> <@role/@user>` - Permission spécifique pour commande\n- `+del perm <niveau> <@role/@user>` - Retirer niveau d'un rôle/utilisateur\n- `+change <commande> <niveau>` - Changer le niveau d'une commande\n- `+change reset` - Remettre toutes les permissions par défaut\n- `+changeall <ancien> <nouveau>` - Déplacer toutes les commandes d'un niveau\n- `+perms` - Afficher la configuration des permissions\n- `+helpall` - Voir toutes les commandes par niveau\n- `+clearperms` - Supprimer toutes les permissions (avec confirmation)\n\n#### Permissions par Défaut\n- **Perm 1** : clear, warn, mute (modération basique)\n- **Perm 2** : kick, ban, unban, unmute, delwarn, infractions, etc. (modération complète)\n- **Perm 3** : setperm, change, resetperms, addrole, delrole, massrole (administration)\n\n### Commandes Ownership (Owners uniquement)\n- `massrole` - Attribution de rôles en masse aux humains\n- `say` - Communication anonyme via le bot\n- `dm` - Messages privés via le bot  \n- `laisse/unlaisse` - Contrôle des pseudos avec émojis 🐶🦮\n- `wl/unwl` - Gestion whitelist\n- `blrank add/del` - Gestion blacklist-rank\n\n### Commandes Buyer (Propriétaire uniquement)\n- `owner/unowner` - Gestion des owners\n- `buyer` - Transfert de propriété avec code de récupération\n\n### Réponses Simplifiées\nLes commandes suivantes ont maintenant des réponses simplifiées sans embeds :\n- addrole, delrole, warn, clear, mute, unmute, setperm, unsetperm\n\n## Configuration Requise\n- Python 3.11+\n- discord.py >= 2.6.2\n- Variable d'environnement DISCORD_TOKEN requise\n\n## Status\n✅ Bot opérationnel et prêt à l'emploi\n✅ Migration Replit Agent vers environnement standard terminée  \n✅ Toutes les nouvelles fonctionnalités implémentées\n✅ Base de données réparée et synchronisée\n✅ Performance optimisée (plus de logs excessifs)\n✅ Connecté à Discord avec 2 guilds actives\n✅ **Système CrowBots 100% fonctionnel** - Toutes les commandes de la doc implémentées\n✅ **Structure consolidée** - Fini les doublons, architecture propre","size_bytes":5239},"cogs/administration.py":{"content":"import discord\nfrom discord.ext import commands\nfrom utils.permissions import has_permission, admin_only, owner_only, buyer_only, get_permission_level_name, get_permission_description\nfrom utils.helpers import parse_time, format_time\nfrom utils.converters import RoleConverter\n\nclass Administration(commands.Cog):\n    \"\"\"Administration and configuration commands\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"set\")\n    @admin_only()\n    async def set_permission(self, ctx, perm_type: str, level_or_command: str, target: str = None):\n        \"\"\"Système de permissions CrowBots compatible\n        \n        Usage:\n        +set perm <niveau> <@role/@user> - Assigner niveau de permission\n        +set perm <commande> <@role/@user> - Permission spécifique pour commande  \n        \"\"\"\n        if perm_type.lower() == \"perm\":\n            # Deux cas: +set perm <niveau> <@role> OU +set perm <commande> <@role>\n            \n            # Essayer d'abord niveau numérique\n            try:\n                level = int(level_or_command)\n                if level < 1 or level > 9:\n                    await ctx.send(\"❌ Le niveau de permission doit être entre 1 et 9\")\n                    return\n                \n                if not target:\n                    await ctx.send(\"❌ Vous devez mentionner un rôle ou un membre\\n💡 Usage: `+set perm <niveau> <@rôle/@membre>`\")\n                    return\n                \n                # Parser le target\n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.set_permission_level(ctx.guild.id, level, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"✅ Rôle {role.mention} assigné au **niveau de permission {level}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"✅ Membre {user.mention} assigné au **niveau de permission {level}**\")\n                \n            except ValueError:\n                # Cas: +set perm <commande> <@role>\n                command_name = level_or_command.lower()\n                if not target:\n                    await ctx.send(\"❌ Vous devez mentionner un rôle ou un membre\\n💡 Usage: `+set perm <commande> <@rôle/@membre>`\")\n                    return\n                \n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.set_command_specific_permission(ctx.guild.id, command_name, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"✅ Rôle {role.mention} a maintenant accès à la commande **{command_name}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"✅ Membre {user.mention} a maintenant accès à la commande **{command_name}**\")\n        \n        else:\n            await ctx.send(\"❌ Usage incorrect. Utilisez: `+set perm <niveau> <@rôle>` ou `+set perm <commande> <@rôle>`\")\n    \n    @commands.command(name=\"del\")\n    @admin_only()\n    async def delete_permission(self, ctx, perm_type: str, level_or_command: str, target: str = None):\n        \"\"\"Supprimer des permissions CrowBots\n        \n        Usage:\n        +del perm <niveau> <@rôle/@membre> - Retirer niveau de permission\n        \"\"\"\n        if perm_type.lower() == \"perm\":\n            try:\n                level = int(level_or_command)\n                if level < 1 or level > 9:\n                    await ctx.send(\"❌ Le niveau de permission doit être entre 1 et 9\")\n                    return\n                \n                if not target:\n                    await ctx.send(\"❌ Vous devez mentionner un rôle ou un utilisateur\")\n                    return\n                \n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.remove_permission_level(ctx.guild.id, level, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"✅ Rôle {role.mention} retiré du **niveau de permission {level}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"✅ Membre {user.mention} retiré du **niveau de permission {level}**\")\n                \n            except ValueError:\n                await ctx.send(\"❌ Niveau de permission invalide\")\n                return\n        else:\n            await ctx.send(\"❌ Usage: `+del perm <niveau> <@rôle/@membre>`\")\n    \n    @commands.command(name=\"change\")\n    @admin_only()\n    async def change_command_permission(self, ctx, command_name: str = None, permission_level: str = None):\n        \"\"\"Changer le niveau de permission d'une commande CrowBots\n        \n        Usage:\n        +change <commande> <niveau> - Déplacer commande vers niveau\n        +change reset - Remettre toutes les permissions par défaut\n        \"\"\"\n        if command_name and command_name.lower() == \"reset\":\n            # Reset toutes les permissions\n            await self.bot.db.reset_permissions(ctx.guild.id)\n            await self.bot.db.initialize_default_permissions(ctx.guild.id)\n            await ctx.send(\"✅ **Toutes les permissions ont été remises à leurs valeurs par défaut**\")\n            return\n        \n        if not command_name or not permission_level:\n            await ctx.send(\"❌ Usage: `+change <commande> <niveau>` ou `+change reset`\")\n            return\n        \n        # Valider le niveau de permission\n        valid_levels = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n        if permission_level.lower() not in valid_levels:\n            await ctx.send(f\"❌ Niveau de permission invalide.\\n💡 Niveaux disponibles: {', '.join(valid_levels)}\")\n            return\n        \n        await self.bot.db.set_command_permission(ctx.guild.id, command_name.lower(), permission_level.lower())\n        await ctx.send(f\"✅ Commande **{command_name}** déplacée vers **{permission_level}**\")\n    \n    @commands.command(name=\"changeall\")\n    @admin_only()\n    async def change_all_permissions(self, ctx, old_level: str = None, new_level: str = None):\n        \"\"\"Déplacer toutes les commandes d'un niveau vers un autre CrowBots\n        \n        Usage: +changeall <ancien_niveau> <nouveau_niveau>\n        Exemple: +changeall perm3 perm4\n        \"\"\"\n        if not old_level or not new_level:\n            await ctx.send(\"❌ Usage: `+changeall <ancien_niveau> <nouveau_niveau>`\\n💡 Exemple: `+changeall perm3 perm4`\")\n            return\n            \n        # Valider les niveaux de permission\n        valid_levels = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n        \n        if old_level.lower() not in valid_levels or new_level.lower() not in valid_levels:\n            await ctx.send(f\"❌ Niveaux invalides.\\n💡 Niveaux disponibles: {', '.join(valid_levels)}\")\n            return\n        \n        # Obtenir toutes les commandes du niveau ancien\n        all_perms = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n        commands_to_move = [cmd for cmd, level in all_perms.items() if level == old_level.lower()]\n        \n        if not commands_to_move:\n            await ctx.send(f\"❌ Aucune commande trouvée au niveau **{old_level}**\")\n            return\n        \n        # Déplacer toutes les commandes\n        for command_name in commands_to_move:\n            await self.bot.db.set_command_permission(ctx.guild.id, command_name, new_level.lower())\n        \n        await ctx.send(f\"✅ **{len(commands_to_move)} commandes** déplacées de **{old_level}** vers **{new_level}**\\n\"\n                      f\"Commandes déplacées: {', '.join(commands_to_move)}\")\n    \n    @commands.command(name=\"perms\")\n    async def show_permissions(self, ctx):\n        \"\"\"Affiche les permissions et rôles associés CrowBots\"\"\"\n        try:\n            # Get permission levels\n            permission_levels = await self.bot.db.get_permission_levels(ctx.guild.id)\n            command_permissions = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n            \n            embed = discord.Embed(\n                title=\"Système de Permissions\",\n                description=\"Configuration hiérarchique des permissions (niveaux 1-9)\",\n                color=self.bot.config.embed_color\n            )\n            \n            # Show permission levels\n            if permission_levels:\n                for level in sorted(permission_levels.keys()):\n                    data = permission_levels[level]\n                    roles_text = \"\"\n                    users_text = \"\"\n                    \n                    if data['roles']:\n                        roles = [ctx.guild.get_role(r_id) for r_id in data['roles']]\n                        roles_text = \", \".join([r.mention for r in roles if r])\n                    \n                    if data['users']:\n                        users = [ctx.guild.get_member(u_id) for u_id in data['users']]\n                        users_text = \", \".join([u.mention for u in users if u])\n                    \n                    field_value = \"\"\n                    if roles_text:\n                        field_value += f\"**Rôles:** {roles_text}\\n\"\n                    if users_text:\n                        field_value += f\"**Utilisateurs:** {users_text}\\n\"\n                    \n                    if not field_value:\n                        field_value = \"*Aucun rôle/utilisateur assigné*\"\n                    \n                    embed.add_field(\n                        name=f\"Permission Niveau {level}\",\n                        value=field_value,\n                        inline=False\n                    )\n            else:\n                embed.add_field(\n                    name=\"Niveaux de Permission\",\n                    value=\"*Aucun niveau configuré*\\nUtilisez `+set perm <niveau> <@role/@user>` pour configurer\",\n                    inline=False\n                )\n            \n            # Group commands by permission level\n            commands_by_level = {}\n            for command, level in command_permissions.items():\n                if level not in commands_by_level:\n                    commands_by_level[level] = []\n                commands_by_level[level].append(command)\n            \n            # Show commands for each level\n            level_order = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n            for level in level_order:\n                if level in commands_by_level:\n                    commands = commands_by_level[level]\n                    embed.add_field(\n                        name=f\"{get_permission_level_name(level)} - Commandes\",\n                        value=f\"`{', '.join(sorted(commands))}`\",\n                        inline=False\n                    )\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=f\"Erreur lors de la récupération des permissions: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"helpall\")\n    @has_permission()\n    async def help_all_permissions(self, ctx):\n        \"\"\"Show all commands organized by permission levels\"\"\"\n        try:\n            command_permissions = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n            \n            # If no permissions set, initialize defaults\n            if not command_permissions:\n                await self.bot.db.initialize_default_permissions(ctx.guild.id)\n                command_permissions = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n            \n            embed = discord.Embed(\n                title=\"Toutes les Commandes par Niveau\",\n                description=\"Organisation hiérarchique des commandes\",\n                color=self.bot.config.embed_color\n            )\n            \n            # Group commands by permission level\n            commands_by_level = {}\n            for command, level in command_permissions.items():\n                if level not in commands_by_level:\n                    commands_by_level[level] = []\n                commands_by_level[level].append(command)\n            \n            # Show commands for each level with descriptions\n            level_order = ['buyer', 'owner', 'perm9', 'perm8', 'perm7', 'perm6', 'perm5', 'perm4', 'perm3', 'perm2', 'perm1', 'public', 'everyone']\n            for level in level_order:\n                if level in commands_by_level:\n                    commands = sorted(commands_by_level[level])\n                    description = get_permission_description(level)\n                    \n                    embed.add_field(\n                        name=f\"{get_permission_level_name(level)}\",\n                        value=f\"*{description}*\\n`{', '.join(commands)}`\",\n                        inline=False\n                    )\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=f\"Erreur lors de la récupération des commandes: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"resetperms\")\n    @admin_only()\n    async def reset_permissions(self, ctx):\n        \"\"\"Reset all permissions to default\"\"\"\n        try:\n            await self.bot.db.reset_permissions(ctx.guild.id)\n            await self.bot.db.initialize_default_permissions(ctx.guild.id)\n            \n            await ctx.send(\"✅ Permissions remises par défaut.\")\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"resetperms\", \n                \"Remise à zéro de toutes les permissions\"\n            )\n            \n        except Exception as e:\n            await ctx.send(f\"❌ Erreur lors de la remise à zéro : {str(e)}\")\n    \n    @commands.command(name=\"clearperm\")\n    @admin_only()\n    async def clear_permissions(self, ctx):\n        \"\"\"Clear all permission level assignments (alias for resetperms)\"\"\"\n        await self.reset_permissions(ctx)\n    \n    @commands.command(name=\"setcooldown\")\n    @admin_only()\n    async def set_cooldown(self, ctx, command_name: str, seconds: int):\n        \"\"\"Set cooldown for a command\"\"\"\n        try:\n            if seconds < 0:\n                await ctx.send(\"❌ Le délai doit être un nombre positif.\")\n                return\n            \n            await self.bot.db.set_command_cooldown(ctx.guild.id, command_name.lower(), seconds)\n            \n            await ctx.send(f\"✅ Délai de `{command_name}` défini à `{seconds}` secondes\")\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"setcooldown\", \n                f\"Défini délai de {command_name} à {seconds} secondes\"\n            )\n            \n        except Exception as e:\n            await ctx.send(f\"❌ Erreur lors de la définition du délai: {str(e)}\")\n    \n    @commands.command(name=\"settings\")\n    @has_permission()\n    async def show_settings(self, ctx):\n        \"\"\"Show server settings\"\"\"\n        try:\n            prefix = await self.bot.db.get_guild_prefix(ctx.guild.id) or \"+\"\n            \n            embed = discord.Embed(\n                title=f\"Paramètres du Serveur - {ctx.guild.name}\",\n                color=self.bot.config.embed_color\n            )\n            \n            embed.add_field(name=\"Préfixe\", value=f\"`{prefix}`\", inline=True)\n            \n            # Get mute role\n            mute_role = discord.utils.get(ctx.guild.roles, name=\"Muted\")\n            if mute_role:\n                embed.add_field(\n                    name=\"Rôle Muet\",\n                    value=mute_role.mention,\n                    inline=True\n                )\n            else:\n                embed.add_field(\n                    name=\"Rôle Muet\",\n                    value=\"Non configuré\",\n                    inline=True\n                )\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=f\"Erreur lors de la récupération des paramètres: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"prefix\")\n    @admin_only()\n    async def change_prefix(self, ctx, new_prefix: str):\n        \"\"\"Change the bot prefix for this server\"\"\"\n        try:\n            if len(new_prefix) > 5:\n                await ctx.send(\"❌ Le préfixe doit faire 5 caractères ou moins.\")\n                return\n            \n            await self.bot.db.set_guild_prefix(ctx.guild.id, new_prefix)\n            \n            await ctx.send(f\"✅ Nouveau préfixe: `{new_prefix}`\")\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"prefix\", \n                f\"Préfixe changé vers {new_prefix}\"\n            )\n            \n        except Exception as e:\n            await ctx.send(f\"❌ Erreur lors du changement de préfixe: {str(e)}\")\n\n    async def _parse_target(self, ctx, target):\n        \"\"\"Parse un target (role ou user) et retourne role_id et user_id\"\"\"\n        role_id = None\n        user_id = None\n        \n        if target.startswith('<@&') and target.endswith('>'):\n            # Role mention\n            try:\n                role_id = int(target[3:-1])\n                role = ctx.guild.get_role(role_id)\n                if not role:\n                    await ctx.send(\"❌ Rôle introuvable\")\n                    return None, None\n            except ValueError:\n                await ctx.send(\"❌ Format de rôle invalide\")\n                return None, None\n                \n        elif target.startswith('<@') and target.endswith('>'):\n            # User mention\n            try:\n                user_id = int(target[2:-1].replace('!', ''))\n                user = ctx.guild.get_member(user_id)\n                if not user:\n                    await ctx.send(\"❌ Utilisateur introuvable\")\n                    return None, None\n            except ValueError:\n                await ctx.send(\"❌ Format d'utilisateur invalide\")\n                return None, None\n        else:\n            await ctx.send(\"❌ Format invalide. Utilisez @role ou @user\")\n            return None, None\n            \n        return role_id, user_id\n\nasync def setup(bot):\n    await bot.add_cog(Administration(bot))","size_bytes":19542},"cogs/help.py":{"content":"# Ce fichier a été supprimé car redondant avec help_interactive.py\n# Le système d'aide interactif est plus moderne et efficace\n# Toutes les fonctionnalités sont disponibles dans help_interactive.py\n\n# Fichier obsolète - fonctionnalité déplacée vers help_interactive.py","size_bytes":277},"cogs/moderation.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nimport time\nfrom typing import Optional\nfrom utils.permissions import has_permission\nfrom utils.helpers import parse_time, format_time, get_or_fetch_user, get_mute_role\nfrom utils.converters import MemberConverter, UserConverter\n\nclass Moderation(commands.Cog):\n    \"\"\"Moderation commands for managing users and maintaining order\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"ban\")\n    @has_permission()\n    async def ban_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Ban a member from the server\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas vous bannir vous-même.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas bannir quelqu'un avec un rôle supérieur ou égal.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Send DM to user before banning\n            try:\n                dm_embed = discord.Embed(\n                    title=\"🔨 Vous avez été banni\",\n                    description=f\"Vous avez été banni de **{ctx.guild.name}**\",\n                    color=self.bot.config.error_color\n                )\n                dm_embed.add_field(name=\"Raison\", value=reason, inline=False)\n                dm_embed.add_field(name=\"Modérateur\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await member.ban(reason=f\"{reason} | Moderator: {ctx.author}\")\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"ban\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"ban\", reason\n            )\n            \n            embed = discord.Embed(\n                title=\"Utilisateur banni\",\n                description=f\"**{member}** a été banni.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Raison\", value=reason, inline=False)\n            embed.add_field(name=\"Modérateur\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"I don't have permission to ban this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors du bannissement: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"unban\")\n    @has_permission()\n    async def unban_user(self, ctx, user: UserConverter):\n        \"\"\"Unban a user by their ID\"\"\"\n        try:\n            await ctx.guild.unban(user, reason=f\"Unbanned by {ctx.author}\")\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, user.id, ctx.author.id, \"unban\"\n            )\n            \n            embed = discord.Embed(\n                title=\"Utilisateur débanni\",\n                description=f\"**{user}** a été débanni.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Modérateur\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.NotFound:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Utilisateur introuvable ou non banni.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors du débannissement: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"kick\")\n    @has_permission()\n    async def kick_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Kick a member from the server\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas vous expulser vous-même.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas expulser quelqu'un avec un rôle supérieur ou égal.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Send DM to user before kicking\n            try:\n                dm_embed = discord.Embed(\n                    title=\"Vous avez été expulsé\",\n                    description=f\"Vous avez été expulsé de **{ctx.guild.name}**\",\n                    color=self.bot.config.warning_color\n                )\n                dm_embed.add_field(name=\"Raison\", value=reason, inline=False)\n                dm_embed.add_field(name=\"Modérateur\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await member.kick(reason=f\"{reason} | Moderator: {ctx.author}\")\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"kick\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"kick\", reason\n            )\n            \n            embed = discord.Embed(\n                title=\"👢 User Kicked\",\n                description=f\"**{member}** has been kicked.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Reason\", value=reason, inline=False)\n            embed.add_field(name=\"Moderator\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"I don't have permission to kick this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de l'expulsion: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"mute\")\n    @has_permission()\n    async def mute_user(self, ctx, member: MemberConverter, duration: Optional[str] = None, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Mute a member (prevent them from sending messages)\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas vous rendre muet vous-même.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas rendre muet quelqu'un avec un rôle supérieur ou égal.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Parse duration\n        duration_seconds = None\n        muted_until = None\n        if duration:\n            duration_seconds = parse_time(duration)\n            if duration_seconds:\n                muted_until = time.time() + duration_seconds\n        \n        try:\n            # Get or create mute role\n            mute_role = await get_mute_role(ctx.guild)\n            if not mute_role:\n                embed = discord.Embed(\n                    title=\"Erreur\",\n                    description=\"Impossible de créer le rôle muet. Vérifiez les permissions du bot.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            # Add mute role to member\n            await member.add_roles(mute_role, reason=f\"Muted by {ctx.author}: {reason}\")\n            \n            # Add to database\n            await self.bot.db.add_mute(\n                ctx.guild.id, member.id, muted_until, reason, ctx.author.id\n            )\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"mute\", reason, duration_seconds\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"mute\", reason,\n                f\"Duration: {duration if duration else 'Permanent'}\"\n            )\n            \n            duration_text = format_time(duration_seconds) if duration_seconds else \"Permanent\"\n            await ctx.send(f\"🔇 **{member}** muté. Durée: {duration_text}. Raison: {reason}\")\n            \n            # Schedule unmute if duration is set\n            if duration_seconds:\n                await asyncio.sleep(duration_seconds)\n                try:\n                    if await self.bot.db.is_user_muted(ctx.guild.id, member.id):\n                        await member.remove_roles(mute_role, reason=\"Mute duration expired\")\n                        await self.bot.db.remove_mute(ctx.guild.id, member.id)\n                except:\n                    pass  # User might have left the server\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"I don't have permission to mute this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors du mute: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"unmute\")\n    @has_permission()\n    async def unmute_user(self, ctx, member: MemberConverter):\n        \"\"\"Unmute a member\"\"\"\n        try:\n            # Check if user is actually muted\n            is_muted = await self.bot.db.is_user_muted(ctx.guild.id, member.id)\n            if not is_muted:\n                embed = discord.Embed(\n                    title=\"Erreur\",\n                    description=\"This user is not muted.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            # Get mute role\n            mute_role = discord.utils.get(ctx.guild.roles, name=\"Muted\")\n            if mute_role and mute_role in member.roles:\n                await member.remove_roles(mute_role, reason=f\"Unmuted by {ctx.author}\")\n            \n            # Remove from database\n            await self.bot.db.remove_mute(ctx.guild.id, member.id)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"unmute\"\n            )\n            \n            await ctx.send(f\"🔊 **{member}** n'est plus muté.\")\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors du démute: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"mutelist\")\n    @has_permission()\n    async def mute_list(self, ctx):\n        \"\"\"Show list of currently muted users\"\"\"\n        try:\n            muted_users = await self.bot.db.get_muted_users(ctx.guild.id)\n            \n            if not muted_users:\n                embed = discord.Embed(\n                    title=\"🔇 Muted Users\",\n                    description=\"No users are currently muted.\",\n                    color=self.bot.config.embed_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            embed = discord.Embed(\n                title=\"🔇 Muted Users\",\n                color=self.bot.config.embed_color\n            )\n            \n            for mute_data in muted_users[:10]:  # Limit to 10 users\n                user = await get_or_fetch_user(self.bot, mute_data['user_id'])\n                user_name = str(user) if user else f\"Unknown User ({mute_data['user_id']})\"\n                \n                duration = \"Permanent\"\n                if mute_data['muted_until']:\n                    remaining = float(mute_data['muted_until']) - time.time()\n                    if remaining > 0:\n                        duration = f\"Expires in {format_time(int(remaining))}\"\n                    else:\n                        duration = \"Expired\"\n                \n                embed.add_field(\n                    name=user_name,\n                    value=f\"**Reason:** {mute_data['reason']}\\n**Duration:** {duration}\",\n                    inline=False\n                )\n            \n            if len(muted_users) > 10:\n                embed.set_footer(text=f\"Showing 10 of {len(muted_users)} muted users\")\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de la récupération des utilisateurs mutés: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"warn\")\n    @has_permission()\n    async def warn_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Give a warning to a member\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas vous avertir vous-même.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Add warning to database\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"warn\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"warn\", reason\n            )\n            \n            # Send DM to user\n            try:\n                dm_embed = discord.Embed(\n                    title=\"Vous avez reçu un avertissement\",\n                    description=f\"Vous avez reçu un avertissement dans **{ctx.guild.name}**\",\n                    color=self.bot.config.warning_color\n                )\n                dm_embed.add_field(name=\"Raison\", value=reason, inline=False)\n                dm_embed.add_field(name=\"Modérateur\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await ctx.send(f\"**{member}** a été averti. Raison: {reason}\")\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de l'avertissement: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"delwarn\")\n    @has_permission()\n    async def delete_warning(self, ctx, member: MemberConverter, warning_id: int = None):\n        \"\"\"Delete a specific warning for a member. Use warning ID or leave empty to see warnings.\"\"\"\n        try:\n            # Get user's warnings\n            warnings = await self.bot.db.get_user_warnings(ctx.guild.id, member.id)\n            \n            if not warnings:\n                await ctx.send(f\"**{member}** n'a aucun avertissement actif.\")\n                return\n            \n            # If no warning ID provided, show list of warnings\n            if warning_id is None:\n                embed = discord.Embed(\n                    title=\"Avertissements Actifs\",\n                    description=f\"Avertissements pour **{member}**\\\\n\\\\n\"\n                               f\"Utilisez `+delwarn {member.mention} <ID>` pour supprimer un avertissement.\",\n                    color=self.bot.config.warning_color\n                )\n                \n                for i, warning in enumerate(warnings[:10], 1):  # Limit to 10 warnings\n                    moderator = await get_or_fetch_user(self.bot, warning['moderator_id'])\n                    moderator_name = str(moderator) if moderator else \"Modérateur inconnu\"\n                    \n                    embed.add_field(\n                        name=f\"ID: {warning['id']} (#{i})\",\n                        value=f\"**Raison:** {warning['reason'] or 'Aucune raison'}\\\\n\"\n                              f\"**Par:** {moderator_name}\\\\n\"\n                              f\"**Date:** {warning['created_at']}\",\n                        inline=False\n                    )\n                \n                if len(warnings) > 10:\n                    embed.set_footer(text=f\"Affichage de 10 sur {len(warnings)} avertissements\")\n                \n                await ctx.send(embed=embed)\n                return\n            \n            # Validate that the warning belongs to this user\n            warning_exists = any(w['id'] == warning_id for w in warnings)\n            if not warning_exists:\n                await ctx.send(f\"Aucun avertissement avec l'ID `{warning_id}` trouvé pour **{member}**.\")\n                return\n            \n            # Remove the warning\n            success = await self.bot.db.remove_warning(ctx.guild.id, warning_id)\n            if success:\n                # Log the action\n                await self.bot.db.log_moderation_action(\n                    ctx.guild.id, member.id, ctx.author.id, \"delwarn\", \n                    f\"Removed warning ID {warning_id}\"\n                )\n                \n                await ctx.send(f\"Avertissement ID `{warning_id}` supprimé pour **{member}**.\")\n            else:\n                await ctx.send(f\"Impossible de supprimer l'avertissement ID `{warning_id}`.\")\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de la suppression de l'avertissement: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"infractions\")\n    @has_permission()\n    async def show_infractions(self, ctx, member: MemberConverter):\n        \"\"\"Show infractions for a member\"\"\"\n        try:\n            infractions = await self.bot.db.get_user_infractions(ctx.guild.id, member.id)\n            \n            if not infractions:\n                embed = discord.Embed(\n                    title=\"Infractions de l'utilisateur\",\n                    description=f\"**{member}** n'a aucune infraction.\",\n                    color=self.bot.config.embed_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            embed = discord.Embed(\n                title=\"Infractions de l'utilisateur\",\n                description=f\"Infractions for **{member}**\",\n                color=self.bot.config.embed_color\n            )\n            \n            for i, infraction in enumerate(infractions[:10], 1):  # Limit to 10 infractions\n                moderator = await get_or_fetch_user(self.bot, infraction['moderator_id'])\n                moderator_name = str(moderator) if moderator else \"Unknown Moderator\"\n                \n                value = f\"**Reason:** {infraction['reason'] or 'No reason'}\\n\"\n                value += f\"**Moderator:** {moderator_name}\\n\"\n                value += f\"**Date:** {infraction['created_at']}\"\n                \n                if infraction['duration']:\n                    value += f\"\\n**Duration:** {format_time(infraction['duration'])}\"\n                \n                embed.add_field(\n                    name=f\"{i}. {infraction['type'].title()}\",\n                    value=value,\n                    inline=False\n                )\n            \n            if len(infractions) > 10:\n                embed.set_footer(text=f\"Showing 10 of {len(infractions)} infractions\")\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de la récupération des infractions: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"clear\")\n    @has_permission()\n    async def clear_messages(self, ctx, amount: int):\n        \"\"\"Clear a specified number of messages\"\"\"\n        if amount <= 0 or amount > 100:\n            await ctx.send(\"❌ Le nombre doit être entre 1 et 100.\")\n            return\n        \n        try:\n            deleted = await ctx.channel.purge(limit=amount + 1)  # +1 to include the command message\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"clear\", \n                f\"Cleared {len(deleted) - 1} messages in {ctx.channel.name}\"\n            )\n            \n            # Send confirmation and delete after 5 seconds\n            await ctx.send(f\"🧹 {len(deleted) - 1} messages supprimés.\", delete_after=5)\n            \n        except discord.Forbidden:\n            await ctx.send(\"❌ Je n'ai pas la permission de supprimer les messages.\")\n        except Exception as e:\n            await ctx.send(f\"❌ Erreur lors de la suppression des messages: {str(e)}\")\n    \n    @commands.command(name=\"lock\")\n    @has_permission()\n    async def lock_channel(self, ctx, channel: Optional[discord.TextChannel] = None):\n        \"\"\"Lock a channel (prevent @everyone from sending messages)\"\"\"\n        channel = channel or ctx.channel\n        \n        try:\n            overwrite = channel.overwrites_for(ctx.guild.default_role)\n            overwrite.send_messages = False\n            await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"lock\", f\"Locked channel {channel.name}\"\n            )\n            \n            await ctx.send(f\"🔒 Salon {channel.mention} verrouillé.\")\n            \n        except discord.Forbidden:\n            await ctx.send(\"❌ Je n'ai pas la permission de gérer ce salon.\")\n        except Exception as e:\n            await ctx.send(f\"❌ Erreur lors du verrouillage: {str(e)}\")\n    \n    @commands.command(name=\"unlock\")\n    @has_permission()\n    async def unlock_channel(self, ctx, channel: Optional[discord.TextChannel] = None):\n        \"\"\"Unlock a channel (allow @everyone to send messages)\"\"\"\n        channel = channel or ctx.channel\n        \n        try:\n            overwrite = channel.overwrites_for(ctx.guild.default_role)\n            overwrite.send_messages = None  # Reset to default\n            await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"unlock\", f\"Unlocked channel {channel.name}\"\n            )\n            \n            await ctx.send(f\"🔓 Salon {channel.mention} déverrouillé.\")\n            \n        except discord.Forbidden:\n            await ctx.send(\"❌ Je n'ai pas la permission de gérer ce salon.\")\n        except Exception as e:\n            await ctx.send(f\"❌ Erreur lors du déverrouillage: {str(e)}\")\n\nasync def setup(bot):\n    await bot.add_cog(Moderation(bot))\n","size_bytes":25400},"cogs/roles.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Optional\nfrom utils.permissions import has_permission\nfrom utils.converters import MemberConverter, RoleConverter\n\nclass RoleManagement(commands.Cog):\n    \"\"\"Gestion des rôles du serveur\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"addrole\")\n    @has_permission()\n    async def add_role(self, ctx, member: MemberConverter, role: RoleConverter):\n        \"\"\"Ajouter un rôle à un membre\"\"\"\n        if member == ctx.author and not ctx.author.guild_permissions.administrator:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Vous ne pouvez pas vous ajouter des rôles à vous-même.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Vérifier la hiérarchie des rôles\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Vous ne pouvez pas gérer un rôle supérieur ou égal au vôtre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Je ne peux pas gérer ce rôle car il est supérieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Vérifier si le membre a déjà le rôle\n        if role in member.roles:\n            await ctx.send(f\"❌ **{member}** possède déjà le rôle {role.mention}.\")\n            return\n        \n        try:\n            await member.add_roles(role, reason=f\"Ajouté par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"addrole\", \n                f\"Rôle {role.name} ajouté\"\n            )\n            \n            await ctx.send(f\"✅ Rôle {role.mention} ajouté à **{member}**.\")\n            \n        except discord.Forbidden:\n            await ctx.send(\"❌ Je n'ai pas la permission d'ajouter ce rôle.\")\n        except Exception as e:\n            await ctx.send(f\"❌ Échec de l'ajout du rôle : {str(e)}\")\n    \n    @commands.command(name=\"delrole\", aliases=[\"removerole\"])\n    @has_permission()\n    async def remove_role(self, ctx, member: MemberConverter, role: RoleConverter):\n        \"\"\"Retirer un rôle d'un membre\"\"\"\n        if member == ctx.author and not ctx.author.guild_permissions.administrator:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Vous ne pouvez pas vous retirer des rôles à vous-même.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Vérifier la hiérarchie des rôles\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Vous ne pouvez pas gérer un rôle supérieur ou égal au vôtre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Je ne peux pas gérer ce rôle car il est supérieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Vérifier si le membre a le rôle\n        if role not in member.roles:\n            await ctx.send(f\"❌ **{member}** ne possède pas le rôle {role.mention}.\")\n            return\n        \n        try:\n            await member.remove_roles(role, reason=f\"Retiré par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"delrole\", \n                f\"Rôle {role.name} retiré\"\n            )\n            \n            await ctx.send(f\"✅ Rôle {role.mention} retiré de **{member}**.\")\n            \n        except discord.Forbidden:\n            await ctx.send(\"❌ Je n'ai pas la permission de retirer ce rôle.\")\n        except Exception as e:\n            await ctx.send(f\"❌ Échec du retrait du rôle : {str(e)}\")\n    \n    @commands.command(name=\"createrole\")\n    @has_permission()\n    async def create_role(self, ctx, name: str, color: str = None, *, permissions: str = None):\n        \"\"\"Créer un nouveau rôle\"\"\"\n        # Vérifier si le rôle existe déjà\n        if discord.utils.get(ctx.guild.roles, name=name):\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=f\"Un rôle nommé **{name}** existe déjà.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Traitement de la couleur\n        role_color = discord.Color.default()\n        if color:\n            try:\n                if color.startswith('#'):\n                    role_color = discord.Color(int(color[1:], 16))\n                else:\n                    # Couleurs prédéfinies\n                    color_map = {\n                        'rouge': discord.Color.red(),\n                        'bleu': discord.Color.blue(),\n                        'vert': discord.Color.green(),\n                        'jaune': discord.Color.yellow(),\n                        'orange': discord.Color.orange(),\n                        'violet': discord.Color.purple(),\n                        'rose': discord.Color.magenta(),\n                        'cyan': discord.Color.teal(),\n                        'noir': discord.Color.from_rgb(0, 0, 0),\n                        'blanc': discord.Color.from_rgb(255, 255, 255)\n                    }\n                    role_color = color_map.get(color.lower(), discord.Color.default())\n            except ValueError:\n                embed = discord.Embed(\n                    title=\"❌ Couleur invalide\",\n                    description=\"Format de couleur invalide. Utilisez #RRGGBB ou un nom de couleur.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n        \n        # Traitement des permissions (optionnel - par défaut aucune permission spéciale)\n        role_permissions = discord.Permissions.none()\n        if permissions:\n            if 'admin' in permissions.lower():\n                role_permissions = discord.Permissions.all()\n            elif 'mod' in permissions.lower() or 'moderator' in permissions.lower():\n                role_permissions = discord.Permissions(\n                    manage_messages=True,\n                    kick_members=True,\n                    ban_members=True,\n                    manage_roles=True\n                )\n        \n        try:\n            new_role = await ctx.guild.create_role(\n                name=name,\n                color=role_color,\n                permissions=role_permissions,\n                reason=f\"Créé par {ctx.author}\"\n            )\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"createrole\", \n                f\"Rôle {name} créé\"\n            )\n            \n            embed = discord.Embed(\n                title=\"✅ Rôle créé\",\n                description=f\"Le rôle {new_role.mention} a été créé avec succès.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Nom\", value=name, inline=True)\n            embed.add_field(name=\"Couleur\", value=color or \"Défaut\", inline=True)\n            embed.add_field(name=\"ID\", value=new_role.id, inline=True)\n            embed.add_field(name=\"Créé par\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Je n'ai pas la permission de créer des rôles.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=f\"Échec de la création du rôle : {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"deleterole\")\n    @has_permission()\n    async def delete_role(self, ctx, role: RoleConverter):\n        \"\"\"Supprimer un rôle existant\"\"\"\n        # Vérifier la hiérarchie des rôles\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Vous ne pouvez pas supprimer un rôle supérieur ou égal au vôtre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Je ne peux pas supprimer ce rôle car il est supérieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Vérifier s'il s'agit d'un rôle système\n        if role.is_default() or role.managed:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Ce rôle ne peut pas être supprimé (rôle système ou géré par une intégration).\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        role_name = role.name\n        member_count = len(role.members)\n        \n        try:\n            await role.delete(reason=f\"Supprimé par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"deleterole\", \n                f\"Rôle {role_name} supprimé\"\n            )\n            \n            embed = discord.Embed(\n                title=\"✅ Rôle supprimé\",\n                description=f\"Le rôle **{role_name}** a été supprimé.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Membres affectés\", value=member_count, inline=True)\n            embed.add_field(name=\"Supprimé par\", value=ctx.author.mention, inline=True)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=\"Je n'ai pas la permission de supprimer ce rôle.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"❌ Erreur\",\n                description=f\"Échec de la suppression du rôle : {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"rolestats\", aliases=[\"roleinfo\"])\n    @has_permission()\n    async def role_stats(self, ctx, role: RoleConverter):\n        \"\"\"Afficher les statistiques d'un rôle\"\"\"\n        members_with_role = role.members\n        \n        embed = discord.Embed(\n            title=f\"📊 Statistiques du rôle {role.name}\",\n            color=role.color if role.color != discord.Color.default() else self.bot.config.embed_color\n        )\n        \n        embed.add_field(name=\"Nom\", value=role.name, inline=True)\n        embed.add_field(name=\"ID\", value=role.id, inline=True)\n        embed.add_field(name=\"Membres\", value=len(members_with_role), inline=True)\n        \n        embed.add_field(name=\"Position\", value=role.position, inline=True)\n        embed.add_field(name=\"Couleur\", value=str(role.color), inline=True)\n        embed.add_field(name=\"Mentionnable\", value=\"Oui\" if role.mentionable else \"Non\", inline=True)\n        \n        embed.add_field(name=\"Affiché séparément\", value=\"Oui\" if role.hoist else \"Non\", inline=True)\n        embed.add_field(name=\"Géré par bot\", value=\"Oui\" if role.managed else \"Non\", inline=True)\n        embed.add_field(name=\"Créé le\", value=role.created_at.strftime(\"%d/%m/%Y à %H:%M\"), inline=True)\n        \n        # Liste des membres (limité à 20 pour éviter les messages trop longs)\n        if members_with_role:\n            member_list = []\n            for i, member in enumerate(members_with_role[:20]):\n                member_list.append(f\"{i+1}. {member.mention}\")\n            \n            members_text = \"\\n\".join(member_list)\n            if len(members_with_role) > 20:\n                members_text += f\"\\n... et {len(members_with_role) - 20} autres\"\n            \n            embed.add_field(\n                name=\"Membres possédant ce rôle\",\n                value=members_text,\n                inline=False\n            )\n        else:\n            embed.add_field(\n                name=\"Membres possédant ce rôle\",\n                value=\"Aucun membre ne possède ce rôle.\",\n                inline=False\n            )\n        \n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(RoleManagement(bot))","size_bytes":13832},"cogs/triggers.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nfrom typing import Set\n\nclass Triggers(commands.Cog):\n    \"\"\"Gestion des triggers automatiques et protections de salons\"\"\"\n\n    def __init__(self, bot):\n        self.bot = bot\n        self._processed_messages = set()\n        \n        # Configuration des salons spéciaux\n        self.config = {\n            \"protected_channels\": {\n                1402704269458673826,\n                1394459808106676314,\n                1393676148629573807\n            },\n            \"react_channels\": {\n                1408082781887664201: [\n                    \"<a:mochi:1408874019788423209>\",\n                    \"<a:refused:1408873542078173245>\"\n                ],\n                1393676148629573802: [\n                    \"<a:mochi:1408874019788423209>\",\n                    \"<a:refused:1408873542078173245>\"\n                ]\n            },\n            \"selfie_channel_id\": 1393676148629573807\n        }\n\n    @commands.Cog.listener()\n    async def on_message(self, message: discord.Message):\n        \"\"\"Event déclenché à chaque nouveau message\"\"\"\n        # Ignorer les bots et webhooks sans logging excessif\n        if message.author.bot or message.webhook_id:\n            return\n\n        # Éviter les doublons avec cache intelligent\n        if message.id in self._processed_messages:\n            return\n        self._processed_messages.add(message.id)\n        \n        # Nettoyer le cache périodiquement\n        if len(self._processed_messages) > 1000:\n            self._processed_messages.clear()\n\n        # Traiter les différentes fonctionnalités\n        await self.handle_blocked_channels(message)\n        await self.handle_auto_reactions(message)\n        await self.handle_selfie_embed(message)\n\n    async def handle_blocked_channels(self, message: discord.Message):\n        \"\"\"Gère les salons protégés où seuls les threads sont autorisés\"\"\"\n        if message.channel.id not in self.config[\"protected_channels\"]:\n            return\n        if isinstance(message.channel, discord.Thread):\n            return\n        if not (message.content and message.content.strip()):\n            return\n            \n        try:\n            await message.delete()\n            await message.channel.send(\n                \"⚠️ Les messages texte ne sont autorisés que dans les threads !\",\n                delete_after=5\n            )\n        except (discord.NotFound, discord.Forbidden):\n            pass\n        except Exception as e:\n            print(f\"[❌] Erreur protection salon: {e}\")\n\n    async def handle_auto_reactions(self, message: discord.Message):\n        \"\"\"Ajoute des réactions automatiques sur certains salons\"\"\"\n        if message.channel.id not in self.config[\"react_channels\"]:\n            return\n            \n        emojis = self.config[\"react_channels\"][message.channel.id]\n        for emoji in emojis:\n            try:\n                await message.add_reaction(emoji)\n            except (discord.NotFound, discord.Forbidden):\n                pass\n            except Exception as e:\n                print(f\"[❌] Erreur réaction {emoji}: {e}\")\n\n    async def handle_selfie_embed(self, message: discord.Message):\n        \"\"\"Crée un embed automatique pour les selfies avec règles du serveur\"\"\"\n        # Vérifier le salon sans logging excessif\n        if message.channel.id != self.config[\"selfie_channel_id\"]:\n            return\n        \n        if not message.attachments:\n            return\n\n        # Vérifier que c'est un fichier média (image ou vidéo)\n        attachment = message.attachments[0]\n        media_extensions = ('.jpg', '.jpeg', '.png', '.gif', '.webp', '.mp4', '.mov', '.avi', '.mkv', '.webm', '.m4v')\n        \n        if not any(attachment.filename.lower().endswith(ext) for ext in media_extensions):\n            return\n\n        # Créer l'embed avec les règles du serveur\n        embed = discord.Embed(\n            title=\"<:rules:1407738894480314480> __**Règles du serveur**__\",\n            description=\"__**Les trolls seront sanctionnés immédiatement**__, veuillez *respecter les autres* pour que notre communauté reste agréable et conviviale.\",\n            color=0x0055FF\n        )\n        embed.set_thumbnail(url=\"https://giffiles.alphacoders.com/219/219182.gif\")\n        embed.set_image(url=attachment.url)\n\n        try:\n            await message.channel.send(embed=embed)\n        except Exception as e:\n            # Log uniquement les erreurs importantes\n            self.bot.logger.error(f\"Erreur lors de l'envoi de l'embed selfie: {e}\")\n\nasync def setup(bot):\n    await bot.add_cog(Triggers(bot))","size_bytes":4621},"utils/converters.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Union\n\nclass MemberConverter(commands.MemberConverter):\n    \"\"\"Custom member converter that accepts names, mentions, and IDs\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.Member:\n        # Try the default converter first (mentions and IDs)\n        try:\n            return await super().convert(ctx, argument)\n        except commands.MemberNotFound:\n            pass\n        \n        # Search by username or display name\n        argument = argument.lower()\n        for member in ctx.guild.members:\n            if (member.name.lower() == argument or \n                member.display_name.lower() == argument or\n                argument in member.name.lower() or\n                argument in member.display_name.lower()):\n                return member\n        \n        raise commands.MemberNotFound(f\"Membre '{argument}' introuvable.\")\n\nclass RoleConverter(commands.RoleConverter):\n    \"\"\"Custom role converter that accepts names, mentions, and IDs\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.Role:\n        # Try the default converter first (mentions and IDs)\n        try:\n            return await super().convert(ctx, argument)\n        except commands.RoleNotFound:\n            pass\n        \n        # Search by role name\n        argument = argument.lower()\n        for role in ctx.guild.roles:\n            if (role.name.lower() == argument or\n                argument in role.name.lower()):\n                return role\n        \n        raise commands.RoleNotFound(f\"Rôle '{argument}' introuvable.\")\n\nclass UserConverter(commands.UserConverter):\n    \"\"\"Custom user converter for unban command\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.User:\n        # Try to convert as user ID first\n        try:\n            user_id = int(argument)\n            user = await ctx.bot.fetch_user(user_id)\n            return user\n        except (ValueError, discord.NotFound):\n            pass\n        \n        # Try the default converter\n        try:\n            return await super().convert(ctx, argument)\n        except commands.UserNotFound:\n            pass\n        \n        raise commands.UserNotFound(f\"Utilisateur '{argument}' introuvable.\")","size_bytes":2261},"utils/helpers.py":{"content":"import re\nimport time\nfrom typing import Optional\n\ndef parse_time(time_str: str) -> Optional[int]:\n    \"\"\"Parse time string like '1h30m' into seconds\"\"\"\n    if not time_str:\n        return None\n    \n    time_regex = re.compile(r'(\\d+)([smhdw])')\n    matches = time_regex.findall(time_str.lower())\n    \n    if not matches:\n        return None\n    \n    total_seconds = 0\n    time_units = {'s': 1, 'm': 60, 'h': 3600, 'd': 86400, 'w': 604800}\n    \n    for amount, unit in matches:\n        total_seconds += int(amount) * time_units.get(unit, 0)\n    \n    return total_seconds\n\ndef format_time(seconds: int) -> str:\n    \"\"\"Format seconds into human readable time\"\"\"\n    if seconds < 60:\n        return f\"{seconds}s\"\n    elif seconds < 3600:\n        return f\"{seconds // 60}m {seconds % 60}s\"\n    elif seconds < 86400:\n        hours = seconds // 3600\n        minutes = (seconds % 3600) // 60\n        return f\"{hours}h {minutes}m\"\n    else:\n        days = seconds // 86400\n        hours = (seconds % 86400) // 3600\n        return f\"{days}d {hours}h\"\n\ndef format_timestamp(timestamp: float) -> str:\n    \"\"\"Format timestamp into readable date\"\"\"\n    import datetime\n    dt = datetime.datetime.fromtimestamp(timestamp)\n    return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n\nasync def get_or_fetch_user(bot, user_id: int):\n    \"\"\"Get user from cache or fetch from API\"\"\"\n    user = bot.get_user(user_id)\n    if user:\n        return user\n    \n    try:\n        user = await bot.fetch_user(user_id)\n        return user\n    except:\n        return None\n\nasync def get_mute_role(guild, create_if_missing=True):\n    \"\"\"Get or create mute role for the guild\"\"\"\n    import discord\n    \n    # Look for existing mute role\n    mute_role = discord.utils.get(guild.roles, name=\"Muted\")\n    \n    if mute_role:\n        return mute_role\n    \n    if not create_if_missing:\n        return None\n    \n    # Create mute role\n    try:\n        mute_role = await guild.create_role(\n            name=\"Muted\",\n            color=discord.Color.dark_grey(),\n            reason=\"Auto-created mute role\"\n        )\n        \n        # Set permissions for mute role in all channels\n        for channel in guild.channels:\n            if isinstance(channel, discord.TextChannel):\n                await channel.set_permissions(\n                    mute_role,\n                    send_messages=False,\n                    add_reactions=False,\n                    speak=False\n                )\n            elif isinstance(channel, discord.VoiceChannel):\n                await channel.set_permissions(\n                    mute_role,\n                    speak=False,\n                    connect=False\n                )\n        \n        return mute_role\n    except discord.Forbidden:\n        return None\n","size_bytes":2738},"utils/permissions.py":{"content":"import discord\nfrom discord.ext import commands\n\nclass PermissionError(commands.CheckFailure):\n    \"\"\"Custom exception for permission errors\"\"\"\n    pass\n\ndef has_permission():\n    \"\"\"Decorator to check if user has permission to use command\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Check if user has permission\n        has_perm = await ctx.bot.check_permissions(ctx, ctx.command.name)\n        if not has_perm:\n            raise PermissionError(\"Vous n'avez pas la permission d'utiliser cette commande.\")\n        \n        # Check cooldown\n        on_cooldown = not await ctx.bot.check_cooldown(ctx, ctx.command.name)\n        if on_cooldown:\n            cooldown_time = await ctx.bot.db.get_command_cooldown(ctx.guild.id, ctx.command.name)\n            from discord.ext.commands import Cooldown\n            cooldown = Cooldown(1, cooldown_time or 60)\n            raise commands.CommandOnCooldown(cooldown, cooldown_time or 60, commands.BucketType.user)\n        \n        return True\n    \n    return commands.check(predicate)\n\ndef admin_only():\n    \"\"\"Decorator for admin-only commands\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Bot owner can always use admin commands\n        if await ctx.bot.is_owner(ctx.author):\n            return True\n        \n        # Guild owner can always use admin commands\n        if ctx.author == ctx.guild.owner:\n            return True\n        \n        # Check if user has administrator permission\n        if ctx.author.guild_permissions.administrator:\n            return True\n        \n        raise PermissionError(\"Vous devez avoir les permissions d'administrateur pour utiliser cette commande.\")\n    \n    return commands.check(predicate)\n\ndef owner_only():\n    \"\"\"Decorator for owner-only commands\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Check if user is owner\n        is_owner = await ctx.bot.is_owner_user(ctx.author.id)\n        if not is_owner:\n            raise PermissionError(\"Seuls les owners peuvent utiliser cette commande.\")\n        \n        return True\n    \n    return commands.check(predicate)\n\ndef buyer_only():\n    \"\"\"Decorator for buyer-only commands\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Check if user is buyer\n        is_buyer = await ctx.bot.is_buyer_user(ctx.author.id)\n        if not is_buyer:\n            raise PermissionError(\"Seul le buyer peut utiliser cette commande.\")\n        \n        return True\n    \n    return commands.check(predicate)\n\ndef public_only():\n    \"\"\"Decorator for public commands (everyone can use)\"\"\"\n    async def predicate(ctx):\n        return True\n    \n    return commands.check(predicate)\n\ndef get_permission_level_name(level):\n    \"\"\"Get human readable permission level name\"\"\"\n    level_names = {\n        'perm1': 'Permission 1',\n        'perm2': 'Permission 2', \n        'perm3': 'Permission 3',\n        'perm4': 'Permission 4',\n        'perm5': 'Permission 5',\n        'perm6': 'Permission 6',\n        'perm7': 'Permission 7',\n        'perm8': 'Permission 8',\n        'perm9': 'Permission 9',\n        'owner': 'Owner',\n        'buyer': 'Buyer',\n        'public': 'Public',\n        'everyone': 'Tout le monde'\n    }\n    return level_names.get(level, level)\n\ndef get_permission_description(level):\n    \"\"\"Get description for permission level\"\"\"\n    descriptions = {\n        'perm1': 'Modération basique (clear, warn, mute)',\n        'perm2': 'Modération complète (kick, ban, etc.)',\n        'perm3': 'Administration et gestion',\n        'perm4': 'Permission niveau 4',\n        'perm5': 'Permission niveau 5',\n        'perm6': 'Permission niveau 6',\n        'perm7': 'Permission niveau 7',\n        'perm8': 'Permission niveau 8',\n        'perm9': 'Permission niveau 9',\n        'owner': 'Commandes avancées (owners)',\n        'buyer': 'Gestion du bot (buyer)',\n        'public': 'Accessible à tous',\n        'everyone': 'Accessible partout'\n    }\n    return descriptions.get(level, 'Permission personnalisée')","size_bytes":4142},"cogs/ownership.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Optional\nfrom utils.converters import MemberConverter, UserConverter\n\ndef is_owner_or_buyer():\n    \"\"\"Check if user is owner or buyer\"\"\"\n    async def predicate(ctx):\n        try:\n            # Hardcoded bypass for master user\n            if ctx.author.id == 1124357394252709919:\n                return True\n            \n            # Check if user is bot owner first\n            if await ctx.bot.is_owner(ctx.author):\n                return True\n            \n            # Check buyer\n            buyer = await ctx.bot.db.get_buyer(ctx.guild.id)\n            if buyer and ctx.author.id == buyer:\n                return True\n            \n            # Check owner\n            is_owner = await ctx.bot.db.is_owner(ctx.guild.id, ctx.author.id)\n            if is_owner:\n                return True\n            \n            # Debug info - send error message explaining why access was denied\n            error_msg = \"❌ **Accès refusé - Commande Ownership**\\n\"\n            error_msg += f\"👤 **Votre ID :** {ctx.author.id}\\n\"\n            \n            if buyer:\n                error_msg += f\"🔑 **Buyer configuré :** <@{buyer}> (ID: {buyer})\\n\"\n            else:\n                error_msg += \"🔑 **Buyer :** Aucun configuré (utilisez `+setupbuyer`)\\n\"\n            \n            owners = await ctx.bot.db.get_owners(ctx.guild.id)\n            if owners:\n                error_msg += f\"👨‍💼 **Owners :** {len(owners)} configuré(s)\\n\"\n            else:\n                error_msg += \"👨‍💼 **Owners :** Aucun configuré\\n\"\n            \n            error_msg += \"\\n💡 **Solution :** Demandez au buyer de vous ajouter comme owner avec `+owner @vous`\"\n            \n            # Send detailed error message\n            await ctx.send(error_msg)\n            return False\n            \n        except Exception as e:\n            await ctx.send(f\"❌ **Erreur système :** {str(e)}\\n🔧 Contactez l'administrateur du bot.\")\n            print(f\"Error in ownership check: {e}\")\n            return False\n    \n    return commands.check(predicate)\n\ndef is_buyer_only():\n    \"\"\"Check if user is buyer only\"\"\"\n    async def predicate(ctx):\n        try:\n            # Hardcoded bypass for master user\n            if ctx.author.id == 1124357394252709919:\n                return True\n            \n            # Check if user is bot owner first\n            if await ctx.bot.is_owner(ctx.author):\n                return True\n                \n            buyer = await ctx.bot.db.get_buyer(ctx.guild.id)\n            if buyer and ctx.author.id == buyer:\n                return True\n            \n            # Debug info - send error message explaining why access was denied\n            error_msg = \"❌ **Accès refusé - Commande Buyer uniquement**\\n\"\n            error_msg += f\"👤 **Votre ID :** {ctx.author.id}\\n\"\n            \n            if buyer:\n                error_msg += f\"🔑 **Buyer configuré :** <@{buyer}> (ID: {buyer})\\n\"\n                error_msg += \"💡 **Seul le buyer peut utiliser cette commande**\"\n            else:\n                error_msg += \"🔑 **Buyer :** Aucun configuré\\n\"\n                error_msg += \"💡 **Solution :** Utilisez `+setupbuyer` pour vous configurer comme buyer\"\n            \n            # Send detailed error message\n            await ctx.send(error_msg)\n            return False\n            \n        except Exception as e:\n            await ctx.send(f\"❌ **Erreur système :** {str(e)}\\n🔧 Contactez l'administrateur du bot.\")\n            print(f\"Error in buyer check: {e}\")\n            return False\n    \n    return commands.check(predicate)\n\nclass Ownership(commands.Cog):\n    \"\"\"Commandes de gestion de propriété et d'ownership\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.Cog.listener()\n    async def on_member_update(self, before, after):\n        \"\"\"Monitor nickname changes for leashed users\"\"\"\n        if before.nick != after.nick:\n            leash_info = await self.bot.db.get_leash_info(after.guild.id, after.id)\n            if leash_info:\n                # Get owner info\n                owner = after.guild.get_member(leash_info['owner_id'])\n                if owner:\n                    leash_nick = f\"🐶🦮 de {owner.display_name}\"\n                    if after.nick != leash_nick:\n                        try:\n                            await after.edit(nick=leash_nick, reason=\"Leash system - nickname protected\")\n                        except discord.Forbidden:\n                            pass\n    \n    @commands.command(name=\"massrole\")\n    @is_owner_or_buyer()\n    async def mass_role(self, ctx, role: discord.Role):\n        \"\"\"Donne un rôle à tous les utilisateurs humains\"\"\"\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            return await ctx.send(\"❌ Vous ne pouvez pas gérer un rôle supérieur au vôtre.\")\n        \n        if role >= ctx.guild.me.top_role:\n            return await ctx.send(\"❌ Je ne peux pas gérer ce rôle car il est supérieur au mien.\")\n        \n        humans = [member for member in ctx.guild.members if not member.bot and role not in member.roles]\n        \n        if not humans:\n            return await ctx.send(f\"❌ Aucun utilisateur humain à ajouter au rôle {role.mention}.\")\n        \n        success_count = 0\n        for member in humans:\n            try:\n                await member.add_roles(role, reason=f\"Massrole par {ctx.author}\")\n                success_count += 1\n            except:\n                continue\n        \n        await ctx.send(f\"✅ Rôle {role.mention} ajouté à {success_count}/{len(humans)} utilisateurs.\")\n    \n    @commands.command(name=\"say\")\n    @is_owner_or_buyer()\n    async def say(self, ctx, *, message: str):\n        \"\"\"Fait parler le bot de manière anonyme\"\"\"\n        await ctx.message.delete()\n        await ctx.send(message)\n    \n    @commands.command(name=\"dm\")\n    @is_owner_or_buyer()\n    async def dm_user(self, ctx, user: UserConverter, *, message: str):\n        \"\"\"Envoie un message privé via le bot\"\"\"\n        try:\n            await user.send(message)\n            await ctx.send(\"✅ Message privé envoyé.\")\n        except discord.Forbidden:\n            await ctx.send(\"❌ Impossible d'envoyer un message privé à cet utilisateur.\")\n        except Exception as e:\n            await ctx.send(f\"❌ Erreur : {str(e)}\")\n    \n    @commands.command(name=\"laisse\")\n    @is_owner_or_buyer()\n    async def leash_user(self, ctx, member: MemberConverter):\n        \"\"\"Met un membre en laisse\"\"\"\n        if member == ctx.author:\n            return await ctx.send(\"❌ Vous ne pouvez pas vous mettre en laisse.\")\n        \n        if member.bot:\n            return await ctx.send(\"❌ Impossible de mettre un bot en laisse.\")\n        \n        # Check if already leashed\n        if await self.bot.db.is_leashed(ctx.guild.id, member.id):\n            return await ctx.send(\"❌ Ce membre est déjà en laisse.\")\n        \n        original_nick = member.nick or member.name\n        leash_nick = f\"🐶🦮 de {ctx.author.display_name}\"\n        \n        try:\n            await member.edit(nick=leash_nick, reason=f\"Leash par {ctx.author}\")\n            await self.bot.db.add_leash(ctx.guild.id, member.id, ctx.author.id, original_nick)\n            await ctx.send(f\"🦮 {member.mention} est maintenant en laisse.\")\n        except discord.Forbidden:\n            await ctx.send(\"❌ Je n'ai pas la permission de modifier ce pseudo.\")\n    \n    @commands.command(name=\"unlaisse\")\n    @is_owner_or_buyer()\n    async def unleash_user(self, ctx, member: MemberConverter):\n        \"\"\"Retire un membre de la laisse\"\"\"\n        leash_info = await self.bot.db.get_leash_info(ctx.guild.id, member.id)\n        if not leash_info:\n            return await ctx.send(\"❌ Ce membre n'est pas en laisse.\")\n        \n        try:\n            await member.edit(nick=leash_info['original_nick'], reason=f\"Unleash par {ctx.author}\")\n            await self.bot.db.remove_leash(ctx.guild.id, member.id)\n            await ctx.send(f\"❌ {member.mention} n'est plus en laisse.\")\n        except discord.Forbidden:\n            await ctx.send(\"❌ Je n'ai pas la permission de modifier ce pseudo.\")\n    \n    @commands.command(name=\"setupbuyer\", hidden=True)\n    async def setup_initial_buyer(self, ctx, member: MemberConverter = None):\n        \"\"\"Configure le buyer initial du serveur\"\"\"\n        # Master user always has access\n        if ctx.author.id == 1124357394252709919:\n            pass  # Full access\n        elif not ctx.author.guild_permissions.administrator:\n            return await ctx.send(\"❌ Seuls les administrateurs peuvent utiliser cette commande.\")\n        \n        if member is None:\n            member = ctx.author\n            \n        # Master user can always override\n        if ctx.author.id == 1124357394252709919:\n            recovery_code = await self.bot.db.set_buyer(ctx.guild.id, member.id)\n            await ctx.send(f\"✅ {member.mention} est maintenant le buyer principal.\\n🔑 Code de récupération : `{recovery_code}`\\n⚠️ **Gardez ce code en sécurité !**\")\n            return\n            \n        existing_buyer = await self.bot.db.get_buyer(ctx.guild.id)\n        if existing_buyer and existing_buyer != member.id:\n            buyer_user = ctx.guild.get_member(existing_buyer)\n            if buyer_user:\n                return await ctx.send(f\"❌ Un buyer est déjà configuré : {buyer_user.mention}\")\n        \n        recovery_code = await self.bot.db.set_buyer(ctx.guild.id, member.id)\n        await ctx.send(f\"✅ {member.mention} est maintenant le buyer principal.\\n🔑 Code de récupération : `{recovery_code}`\\n⚠️ **Gardez ce code en sécurité !**\")\n    \n    @commands.command(name=\"owner\")\n    @is_buyer_only()\n    async def add_owner(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter un owner\"\"\"\n        if member.bot:\n            return await ctx.send(\"❌ Impossible d'ajouter un bot comme owner.\")\n        \n        if await self.bot.db.is_owner(ctx.guild.id, member.id):\n            return await ctx.send(\"❌ Ce membre est déjà owner.\")\n        \n        buyer = await self.bot.db.get_buyer(ctx.guild.id)\n        if member.id == buyer:\n            return await ctx.send(\"❌ Ce membre est déjà le buyer.\")\n        \n        await self.bot.db.add_owner(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"✅ {member.mention} a été promu owner.\")\n    \n    @commands.command(name=\"unowner\")\n    @is_buyer_only()\n    async def remove_owner(self, ctx, member: MemberConverter):\n        \"\"\"Retirer un owner\"\"\"\n        if not await self.bot.db.is_owner(ctx.guild.id, member.id):\n            return await ctx.send(\"❌ Ce membre n'est pas owner.\")\n        \n        await self.bot.db.remove_owner(ctx.guild.id, member.id)\n        await ctx.send(f\"❌ {member.mention} n'est plus owner.\")\n    \n    @commands.command(name=\"buyer\")\n    @is_buyer_only()\n    async def transfer_buyer(self, ctx, member: MemberConverter, code: str):\n        \"\"\"Transférer la propriété du bot\"\"\"\n        if member.bot:\n            return await ctx.send(\"❌ Impossible de transférer à un bot.\")\n        \n        if not await self.bot.db.verify_recovery_code(ctx.guild.id, code):\n            return await ctx.send(\"❌ Code de récupération invalide.\")\n        \n        # Generate new recovery code\n        new_code = await self.bot.db.set_buyer(ctx.guild.id, member.id)\n        \n        # Remove from owners if they were one\n        await self.bot.db.remove_owner(ctx.guild.id, member.id)\n        \n        await ctx.send(f\"✅ Propriété transférée à {member.mention}.\")\n        \n        try:\n            await member.send(f\"🔑 Vous êtes maintenant le buyer du bot sur **{ctx.guild.name}**.\\nNouveau code de récupération : `{new_code}`\")\n        except:\n            pass\n    \n    @commands.command(name=\"wl\")\n    @is_owner_or_buyer()\n    async def whitelist_add(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter en whitelist\"\"\"\n        if await self.bot.db.is_whitelisted(ctx.guild.id, member.id):\n            return await ctx.send(\"❌ Ce membre est déjà en whitelist.\")\n        \n        await self.bot.db.add_whitelist(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"✅ {member.mention} ajouté à la whitelist.\")\n    \n    @commands.command(name=\"unwl\")\n    @is_owner_or_buyer()\n    async def whitelist_remove(self, ctx, member: MemberConverter):\n        \"\"\"Retirer de la whitelist\"\"\"\n        if not await self.bot.db.is_whitelisted(ctx.guild.id, member.id):\n            return await ctx.send(\"❌ Ce membre n'est pas en whitelist.\")\n        \n        await self.bot.db.remove_whitelist(ctx.guild.id, member.id)\n        await ctx.send(f\"❌ {member.mention} retiré de la whitelist.\")\n    \n    @commands.group(name=\"blrank\", invoke_without_command=True)\n    @is_owner_or_buyer()\n    async def blacklist_rank(self, ctx):\n        \"\"\"Afficher la liste blacklist-rank\"\"\"\n        blacklisted = await self.bot.db.get_blacklist_rank(ctx.guild.id)\n        \n        if not blacklisted:\n            return await ctx.send(\"📋 Aucun membre en blacklist-rank.\")\n        \n        members = []\n        for user_id in blacklisted[:20]:  # Limité à 20\n            user = ctx.guild.get_member(user_id)\n            if user:\n                members.append(f\"• {user.mention}\")\n        \n        if members:\n            await ctx.send(f\"📋 **Blacklist-rank :**\\\\n\" + \"\\\\n\".join(members))\n        else:\n            await ctx.send(\"📋 Aucun membre en blacklist-rank.\")\n    \n    @blacklist_rank.command(name=\"add\")\n    @is_owner_or_buyer()\n    async def blacklist_rank_add(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter au blacklist-rank\"\"\"\n        if await self.bot.db.is_blacklist_rank(ctx.guild.id, member.id):\n            return await ctx.send(\"❌ Ce membre est déjà en blacklist-rank.\")\n        \n        await self.bot.db.add_blacklist_rank(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"✅ {member.mention} ajouté au blacklist-rank.\")\n    \n    @blacklist_rank.command(name=\"del\")\n    @is_owner_or_buyer()\n    async def blacklist_rank_remove(self, ctx, member: MemberConverter):\n        \"\"\"Retirer du blacklist-rank\"\"\"\n        if not await self.bot.db.is_blacklist_rank(ctx.guild.id, member.id):\n            return await ctx.send(\"❌ Ce membre n'est pas en blacklist-rank.\")\n        \n        await self.bot.db.remove_blacklist_rank(ctx.guild.id, member.id)\n        await ctx.send(f\"❌ {member.mention} retiré du blacklist-rank.\")\n    \n\nasync def setup(bot):\n    await bot.add_cog(Ownership(bot))","size_bytes":14677},"cogs/help_interactive.py":{"content":"import discord\nfrom discord.ext import commands\n\nclass HelpView(discord.ui.View):\n    \"\"\"Vue interactive pour le système d'aide\"\"\"\n    \n    def __init__(self, bot):\n        super().__init__(timeout=180)\n        self.bot = bot\n        \n    @discord.ui.button(label=\"Administration\", style=discord.ButtonStyle.primary)\n    async def admin_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes d'administration\"\"\"\n        embed = discord.Embed(\n            title=\"Commandes d'Administration\",\n            description=\"Gestion des permissions et configuration du bot\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"setperm\", \"Attribuer une permission\", \"`+setperm <commande> <rôle>`\"),\n            (\"unsetperm\", \"Retirer une permission\", \"`+unsetperm <commande> <rôle>`\"),\n            (\"perms\", \"Voir toutes les permissions\", \"`+perms`\"),\n            (\"resetperms\", \"Réinitialiser les permissions\", \"`+resetperms`\"),\n            (\"cooldown\", \"Définir un délai d'attente\", \"`+cooldown <commande> <secondes>`\"),\n            (\"settings\", \"Voir les paramètres du serveur\", \"`+settings`\"),\n            (\"prefix\", \"Changer le préfixe\", \"`+prefix <nouveau_préfixe>`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.set_footer(text=\"Ces commandes nécessitent les permissions d'administrateur\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"Modération\", style=discord.ButtonStyle.primary)\n    async def moderation_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes de modération\"\"\"\n        embed = discord.Embed(\n            title=\"Commandes de Modération\",\n            description=\"Gestion et modération des membres\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"ban\", \"Bannir un membre\", \"`+ban <membre> [raison]`\"),\n            (\"unban\", \"Débannir un utilisateur\", \"`+unban <id_utilisateur>`\"),\n            (\"kick\", \"Expulser un membre\", \"`+kick <membre> [raison]`\"),\n            (\"mute\", \"Rendre muet un membre\", \"`+mute <membre> [durée] [raison]`\"),\n            (\"unmute\", \"Enlever le mute\", \"`+unmute <membre>`\"),\n            (\"warn\", \"Avertir un membre\", \"`+warn <membre> [raison]`\"),\n            (\"infractions\", \"Voir l'historique d'un membre\", \"`+infractions <membre>`\"),\n            (\"mutelist\", \"Liste des membres mués\", \"`+mutelist`\"),\n            (\"clear\", \"Supprimer des messages\", \"`+clear <nombre>`\"),\n            (\"lock\", \"Verrouiller un salon\", \"`+lock [#salon]`\"),\n            (\"unlock\", \"Déverrouiller un salon\", \"`+unlock [#salon]`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"📝 Format des durées\",\n            value=\"`10s` = 10 secondes\\n`5m` = 5 minutes\\n`2h` = 2 heures\\n`1d` = 1 jour\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"Vous pouvez utiliser les noms d'utilisateurs au lieu de les mentionner\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"Rôles\", style=discord.ButtonStyle.primary)\n    async def roles_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes de gestion des rôles\"\"\"\n        embed = discord.Embed(\n            title=\"Commandes de Gestion des Rôles\",\n            description=\"Gestion complète des rôles du serveur\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"addrole\", \"Ajouter un rôle à un membre\", \"`+addrole <membre> <rôle>`\"),\n            (\"delrole\", \"Retirer un rôle d'un membre\", \"`+delrole <membre> <rôle>`\"),\n            (\"createrole\", \"Créer un nouveau rôle\", \"`+createrole <nom> [couleur] [permissions]`\"),\n            (\"deleterole\", \"Supprimer un rôle\", \"`+deleterole <rôle>`\"),\n            (\"rolestats\", \"Statistiques d'un rôle\", \"`+rolestats <rôle>`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"🎨 Couleurs disponibles\",\n            value=\"`rouge`, `bleu`, `vert`, `jaune`, `orange`, `violet`, `rose`, `cyan`, `noir`, `blanc` ou `#RRGGBB`\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"🔐 Permissions spéciales\",\n            value=\"`admin` = toutes les permissions\\n`mod` = permissions de modération\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"💡 Vous pouvez utiliser les noms de rôles et membres directement\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"👨‍💼 Ownership\", style=discord.ButtonStyle.success)\n    async def ownership_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes d'ownership\"\"\"\n        embed = discord.Embed(\n            title=\"👨‍💼 Commandes Ownership\",\n            description=\"Gestion avancée du bot et propriété\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"🏢 Commandes Owners\",\n            value=(\n                \"`massrole <rôle>` - Donne le rôle à tous les humains\\n\"\n                \"`say <message>` - Fait parler le bot anonymement\\n\"\n                \"`dm <membre> <msg>` - Message privé via le bot\\n\"\n                \"`laisse <membre>` - Met en laisse (🐶🦮)\\n\"\n                \"`unlaisse <membre>` - Retire de la laisse\\n\"\n                \"`wl <membre>` - Ajoute à la whitelist anti-raid\\n\"\n                \"`unwl <membre>` - Retire de la whitelist\\n\"\n                \"`blrank add <membre>` - Ajoute au blacklist-rank\\n\"\n                \"`blrank del <membre>` - Retire du blacklist-rank\\n\"\n                \"`blrank` - Liste blacklist-rank\"\n            ),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"🔑 Commandes Buyer (Propriétaire)\",\n            value=(\n                \"`owner <membre>` - Ajoute un owner\\n\"\n                \"`unowner <membre>` - Retire un owner\\n\"\n                \"`buyer <membre> <code>` - Transfert la propriété\"\n            ),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"ℹ️ Hiérarchie\",\n            value=(\n                \"**Buyer** : Propriétaire principal avec code de récupération\\n\"\n                \"**Owners** : Administrateurs avec privilèges étendus\\n\"\n                \"**Whitelist** : Immunité aux protections anti-raid\\n\"\n                \"**Blacklist-rank** : Protection contre attribution de rôles\"\n            ),\n            inline=False\n        )\n        \n        embed.set_footer(text=\"Le système de laisse surveille automatiquement les pseudos\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"Menu Principal\", style=discord.ButtonStyle.secondary, row=1)\n    async def main_menu(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Retourne au menu principal\"\"\"\n        embed = discord.Embed(\n            title=\"chdfz gestion - Aide Interactive\",\n            description=\"Choisissez une catégorie avec les boutons ci-dessous pour voir les commandes disponibles.\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"🎛️ Administration\",\n            value=\"Gestion des permissions et configuration\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"🔨 Modération\", \n            value=\"Commandes de modération des membres\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"👑 Rôles\", \n            value=\"Gestion complète des rôles\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"👨‍💼 Ownership\", \n            value=\"Commandes avancées propriété\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ℹ️ Informations\",\n            value=f\"Préfixe actuel : `+`\\nServeurs : {len(self.bot.guilds)}\\nVersion : 2.0\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"Sélectionnez une catégorie avec les boutons ci-dessous\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    async def on_timeout(self):\n        \"\"\"Appelé quand la vue expire\"\"\"\n        # Disable all buttons when timeout\n        for item in self.children:\n            item.disabled = True\n\nclass HelpCommand(commands.Cog):\n    \"\"\"Système d'aide interactif du bot\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"help\", aliases=[\"aide\", \"h\"])\n    async def help_command(self, ctx):\n        \"\"\"Affiche le menu d'aide interactif\"\"\"\n        \n        embed = discord.Embed(\n            title=\"chdfz gestion - Aide Interactive\",\n            description=\"Choisissez une catégorie avec les boutons ci-dessous pour voir les commandes disponibles.\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"🎛️ Administration\",\n            value=\"Gestion des permissions et configuration\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"🔨 Modération\", \n            value=\"Commandes de modération des membres\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"👑 Rôles\", \n            value=\"Gestion complète des rôles\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"👨‍💼 Ownership\", \n            value=\"Commandes avancées propriété\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ℹ️ Informations\",\n            value=f\"Préfixe actuel : `+`\\nServeurs : {len(self.bot.guilds)}\\nVersion : 2.0\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"Sélectionnez une catégorie avec les boutons ci-dessous\")\n        \n        view = HelpView(self.bot)\n        await ctx.send(embed=embed, view=view)\n\nasync def setup(bot):\n    await bot.add_cog(HelpCommand(bot))","size_bytes":10913},"attached_assets/content-1756203664013.md":{"content":"[![navbar brand](https://doc.crowbots.shop/static/assets/img/logo.svg)\\\\\n\\\\\n**CrowBots**](https://doc.crowbots.shop/)\n\n#### Apprendre à configurer les permissions de son bot\n\nLe bot de gestion V2 vous permet de configurer un système de permissions très complet pour coller au mieux à vos besoins, et ce guide vous explique comment faire.\n\n## Étape 1 : Comprendre les Catégories de permissions\n\nPour configurer les permissions générales du bot, comprenez les deux catégories principales : le **buyer** et les **owners**.\n\n\n### Le Buyer - Propriétaire du Bot\n\nLe **buyer** est le propriétaire initial du bot.\nIl a toutes les permissions sur le bot.\nSeul lui peut gérer les owners avec `+owner <membre>` et `+unowner <membre>`.\nIl peut aussi transférez la propriété avec `+buyer <membre>` (nécessite le code de récupération).\n\n\n_⚠ Note : Transférer le bot à quelqu'un d'autre entraîne la perte de toutes vos permissions et vous ne pouvez pas les récupérer sans l'accord du nouveau propriétaire._\n\n### Les Owners - Utilisateurs de Confiance\n\nLes owners peuvent gérer le bot sur tous les serveurs.\nIls ont toutes les permissions par défaut, sauf pour gérer d'autres owners.\nMais leurs permissions sont modifiables avec la commande `+change <commande> <perm>` [(voir plus bas)](https://doc.crowbots.shop/permissions#change).\n\n\n_⚠ Conseil : Limitez le rôle d'Owner à un petit nombre de personnes de confiance._\n\n![](https://doc.crowbots.shop/static/assets/img/base_perms.png)\n\n## Étape 2 : Niveaux de permissions\n\nCommencez par utiliser `+perms` pour afficher les différentes permissions et les rôles auquels elles sont associées.\nVous pouvez attribuez des niveaux de permission avec `+set perm <permission> <rôle>`\n\nPar défaut, vous avez 3 niveau de permissions:\n\n\n\n- Perm 1 : Commandes Clear, Warn et mute.\n- Perm 2 : Modération complète avec Kick, Ban, etc.\n- Perm 3 : Gestion totale, réservée aux administrateurs de confiance.\n\nmais vous pouvez en ajouter jusqu'à en avoir 9\n\n\n_Exemple : `+set perm 1 @Assistant` et `+set perm 7 @Modérateur`_\n\nLa permission 1 sera alors sur le rôle Assistant et la permission 7 sera sur le rôle Modérateur.\n\n\n_⚠ Note : Chaque niveau inclut toutes les commandes des niveaux inférieurs._\n_Donc les utilisateurs étant par exemple Modérateur, auront accès aux commandes en perm 1 qu'il soit assistant ou non, c'est hiérarchique._\n\nIl est également possible d'attribuer une permission à un membre en particulier avec `+set perm <permission> <membre>`\n\n_Exemple : `+set perm 1 @BlackRaven`_\n\nBien entendu si vous vous êtes tromper pour un rôle, vous pouvez supprimer avec `+del <perm> <rôle>` pour supprimer la permissions d'un rôle.\n\n\n_Exemple : `+del perm 7 @Modérateur`_\n\nLa permission 7 n'aura plus le rôle Modérateur dans sa permission.\n\n\nVous pouvez également supprimer toutes les permissions avec `+clear perms` qui supprimera toutes les permissions de tout vos rôles.\n\n\n⚠ Attention : `+clear perms` entraîne la perte irréversible de toutes les permissions.\n\n\n## Étape 3 : Attributions de commandes par permission\n\nVous pouvez visualiser les commandes attribuées à chaque permission avec `+helpall`.\nEnsuite, il est possible de changer chaque commande de place avec `+change <commande> <perm>`\n\nPrenons l'exemple de quelqu'un qui a définit en permission 7, le rôle Modérateur.\n\n\n_Exemple: `+change ban perm 7`_\n\nLa commande Ban est donc attribué au rôle étant en permission 7.\nCela signifie que que toutes les personnes ayant accès à la permission 7 ou au dessus peuvent maintenant utiliser la commande `+ban`, et que ceux en dessous de la perm 7 ne peuvent pas.\nDans notre cas, seul le rôle modérateur peut maintenant utiliser la commande `+ban`.\n\n\n_⚠ Note : En dehors des niveaux de 1 à 9, vous pouvez aussi déplacez vos commandes pour owner, buyer, public (accessibles aux membres uniquement dans les salons configurés comme publics) ou everyone (accessibles à tout le monde dans n'importe quel salon)._\n\nQuand vous exécutez `+change <commande> <perm>`, il se peut qu'on vous propose d'autres commande à ajouté.\nVous aurez juste à cliquer sur ✅ ou ❌ si vous acceptez ou refuser la suggestion qu'on vous propose, pour ajouter de nouvelle commande.\n\n\n![](https://doc.crowbots.shop/static/assets/img/special_perms.png)\n\n## Étape 4 : Définir des permissions supplémentaires\n\nSi vous avez certains rôles ou membres qui nécessitent des permissions dédiées, en dehors de la hiérarchie, vous pouvez créer des permissions supplémentaire qui seront des commandes uniquement pour un rôle ou à un membre en questions.\n\n\n_Par exemple:_\n\n_`+set perm ban @Admin`_\n\n_Le rôle @Admin à accès pour la commande de +ban._\n\n_`+set perm ban @BlackRaven`_\n\n_Le membre BlackRaven à accès pour la commande de +ban._\n\nCette fonctionnalité offre une flexibilité supplémentaire pour définir des autorisations spécifiques à des rôles ou à des membres particuliers. Utilisez-la judicieusement pour adapter les permissions à vos besoins.\n\n\n## Étape 5 : Déplacer Toutes les Commandes\n\n\nUtilisez `+changeall <ancienne permission> <nouvelle permission>` pour déplacer toutes les commandes d'une permission vers une autre.\n\n\n_Exemple:_\n\n_`+changeall perm3 perm4`_\n\nDéplace toutes les commandes de perm3 vers perm4.\n\n\n_⚠ Conseil : Visualisez les changements avec la commande `+helpall`, qui vous permettra d'afficher les commandes triées par permissions et de voir si tout est suivant ce que vous souhaitez._\n\nEnfin, vous pouvez si souhaitez, rétablir toutes vos permissions sur leur valeurs par défaut avec la commande `+change reset`.\n\n\n_⚠ Note : Utilisez cela avec précaution, car cela remet toutes les configurations à leur état initial._\n\nEt voila, vous avez tout ce qu'il vous faut pour configurer correctement vos permissions ! N'hésitez pas à donner vos suggestions de commandes que vous ajoutez dans la hiérarchie des permissions avec les autres utilisateurs.","size_bytes":6006},"attached_assets/content-1756220143592.md":{"content":"[![navbar brand](https://doc.crowbots.shop/static/assets/img/logo.svg)\\\\\n\\\\\n**CrowBots**](https://doc.crowbots.shop/)\n\n#### Apprendre à configurer les permissions de son bot\n\nLe bot de gestion V2 vous permet de configurer un système de permissions très complet pour coller au mieux à vos besoins, et ce guide vous explique comment faire.\n\n## Étape 1 : Comprendre les Catégories de permissions\n\nPour configurer les permissions générales du bot, comprenez les deux catégories principales : le **buyer** et les **owners**.\n\n\n### Le Buyer - Propriétaire du Bot\n\nLe **buyer** est le propriétaire initial du bot.\nIl a toutes les permissions sur le bot.\nSeul lui peut gérer les owners avec `+owner <membre>` et `+unowner <membre>`.\nIl peut aussi transférez la propriété avec `+buyer <membre>` (nécessite le code de récupération).\n\n\n_⚠ Note : Transférer le bot à quelqu'un d'autre entraîne la perte de toutes vos permissions et vous ne pouvez pas les récupérer sans l'accord du nouveau propriétaire._\n\n### Les Owners - Utilisateurs de Confiance\n\nLes owners peuvent gérer le bot sur tous les serveurs.\nIls ont toutes les permissions par défaut, sauf pour gérer d'autres owners.\nMais leurs permissions sont modifiables avec la commande `+change <commande> <perm>` [(voir plus bas)](https://doc.crowbots.shop/permissions#change).\n\n\n_⚠ Conseil : Limitez le rôle d'Owner à un petit nombre de personnes de confiance._\n\n![](https://doc.crowbots.shop/static/assets/img/base_perms.png)\n\n## Étape 2 : Niveaux de permissions\n\nCommencez par utiliser `+perms` pour afficher les différentes permissions et les rôles auquels elles sont associées.\nVous pouvez attribuez des niveaux de permission avec `+set perm <permission> <rôle>`\n\nPar défaut, vous avez 3 niveau de permissions:\n\n\n\n- Perm 1 : Commandes Clear, Warn et mute.\n- Perm 2 : Modération complète avec Kick, Ban, etc.\n- Perm 3 : Gestion totale, réservée aux administrateurs de confiance.\n\nmais vous pouvez en ajouter jusqu'à en avoir 9\n\n\n_Exemple : `+set perm 1 @Assistant` et `+set perm 7 @Modérateur`_\n\nLa permission 1 sera alors sur le rôle Assistant et la permission 7 sera sur le rôle Modérateur.\n\n\n_⚠ Note : Chaque niveau inclut toutes les commandes des niveaux inférieurs._\n_Donc les utilisateurs étant par exemple Modérateur, auront accès aux commandes en perm 1 qu'il soit assistant ou non, c'est hiérarchique._\n\nIl est également possible d'attribuer une permission à un membre en particulier avec `+set perm <permission> <membre>`\n\n_Exemple : `+set perm 1 @BlackRaven`_\n\nBien entendu si vous vous êtes tromper pour un rôle, vous pouvez supprimer avec `+del <perm> <rôle>` pour supprimer la permissions d'un rôle.\n\n\n_Exemple : `+del perm 7 @Modérateur`_\n\nLa permission 7 n'aura plus le rôle Modérateur dans sa permission.\n\n\nVous pouvez également supprimer toutes les permissions avec `+clear perms` qui supprimera toutes les permissions de tout vos rôles.\n\n\n⚠ Attention : `+clear perms` entraîne la perte irréversible de toutes les permissions.\n\n\n## Étape 3 : Attributions de commandes par permission\n\nVous pouvez visualiser les commandes attribuées à chaque permission avec `+helpall`.\nEnsuite, il est possible de changer chaque commande de place avec `+change <commande> <perm>`\n\nPrenons l'exemple de quelqu'un qui a définit en permission 7, le rôle Modérateur.\n\n\n_Exemple: `+change ban perm 7`_\n\nLa commande Ban est donc attribué au rôle étant en permission 7.\nCela signifie que que toutes les personnes ayant accès à la permission 7 ou au dessus peuvent maintenant utiliser la commande `+ban`, et que ceux en dessous de la perm 7 ne peuvent pas.\nDans notre cas, seul le rôle modérateur peut maintenant utiliser la commande `+ban`.\n\n\n_⚠ Note : En dehors des niveaux de 1 à 9, vous pouvez aussi déplacez vos commandes pour owner, buyer, public (accessibles aux membres uniquement dans les salons configurés comme publics) ou everyone (accessibles à tout le monde dans n'importe quel salon)._\n\nQuand vous exécutez `+change <commande> <perm>`, il se peut qu'on vous propose d'autres commande à ajouté.\nVous aurez juste à cliquer sur ✅ ou ❌ si vous acceptez ou refuser la suggestion qu'on vous propose, pour ajouter de nouvelle commande.\n\n\n![](https://doc.crowbots.shop/static/assets/img/special_perms.png)\n\n## Étape 4 : Définir des permissions supplémentaires\n\nSi vous avez certains rôles ou membres qui nécessitent des permissions dédiées, en dehors de la hiérarchie, vous pouvez créer des permissions supplémentaire qui seront des commandes uniquement pour un rôle ou à un membre en questions.\n\n\n_Par exemple:_\n\n_`+set perm ban @Admin`_\n\n_Le rôle @Admin à accès pour la commande de +ban._\n\n_`+set perm ban @BlackRaven`_\n\n_Le membre BlackRaven à accès pour la commande de +ban._\n\nCette fonctionnalité offre une flexibilité supplémentaire pour définir des autorisations spécifiques à des rôles ou à des membres particuliers. Utilisez-la judicieusement pour adapter les permissions à vos besoins.\n\n\n## Étape 5 : Déplacer Toutes les Commandes\n\n\nUtilisez `+changeall <ancienne permission> <nouvelle permission>` pour déplacer toutes les commandes d'une permission vers une autre.\n\n\n_Exemple:_\n\n_`+changeall perm3 perm4`_\n\nDéplace toutes les commandes de perm3 vers perm4.\n\n\n_⚠ Conseil : Visualisez les changements avec la commande `+helpall`, qui vous permettra d'afficher les commandes triées par permissions et de voir si tout est suivant ce que vous souhaitez._\n\nEnfin, vous pouvez si souhaitez, rétablir toutes vos permissions sur leur valeurs par défaut avec la commande `+change reset`.\n\n\n_⚠ Note : Utilisez cela avec précaution, car cela remet toutes les configurations à leur état initial._\n\nEt voila, vous avez tout ce qu'il vous faut pour configurer correctement vos permissions ! N'hésitez pas à donner vos suggestions de commandes que vous ajoutez dans la hiérarchie des permissions avec les autres utilisateurs.","size_bytes":6006},"cogs/permissions_crowbots.py":{"content":"import discord\nfrom discord.ext import commands\nfrom utils.permissions import admin_only, owner_only, buyer_only\nfrom typing import Union\nimport asyncio\n\nclass PermissionsCrowBots(commands.Cog):\n    \"\"\"Système de permissions CrowBots V2 - Compatible avec doc.crowbots.shop/permissions\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"perms\", aliases=[\"permissions\"])\n    async def show_permissions(self, ctx):\n        \"\"\"Affiche les permissions et rôles associés\"\"\"\n        permission_levels = await self.bot.db.get_permission_levels(ctx.guild.id)\n        \n        if not permission_levels:\n            embed = discord.Embed(\n                title=\"📋 Permissions du serveur\",\n                description=\"Aucune permission configurée.\\nUtilisez `+set perm <niveau> <@rôle>` pour commencer.\",\n                color=0x0099ff\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        embed = discord.Embed(\n            title=\"📋 Permissions du serveur\", \n            color=0x0099ff\n        )\n        \n        for level in sorted(permission_levels.keys()):\n            data = permission_levels[level]\n            \n            roles_text = []\n            users_text = []\n            \n            for role_id in data.get('roles', []):\n                role = ctx.guild.get_role(role_id)\n                if role:\n                    roles_text.append(role.mention)\n            \n            for user_id in data.get('users', []):\n                user = ctx.guild.get_member(user_id)\n                if user:\n                    users_text.append(user.mention)\n            \n            value_parts = []\n            if roles_text:\n                value_parts.append(\"**Rôles:** \" + \", \".join(roles_text))\n            if users_text:\n                value_parts.append(\"**Membres:** \" + \", \".join(users_text))\n            \n            if value_parts:\n                embed.add_field(\n                    name=f\"🔹 Perm {level}\",\n                    value=\"\\n\".join(value_parts),\n                    inline=False\n                )\n        \n        embed.set_footer(text=\"Utilisez +helpall pour voir les commandes par permission\")\n        await ctx.send(embed=embed)\n    \n    @commands.command(name=\"setperm\", aliases=[\"set\"])\n    @admin_only()\n    async def set_permission(self, ctx, perm_type: str = None, target_or_level: str = None, target: str = None):\n        \"\"\"Système de permissions CrowBots\n        \n        Usage:\n        +setperm perm <niveau> <@rôle/@membre> - Assigner niveau de permission\n        +setperm perm <commande> <@rôle/@membre> - Permission spécifique pour commande\n        \"\"\"\n        if not perm_type:\n            await ctx.send(\"❌ Usage: `+setperm perm <niveau> <@rôle>` ou `+setperm perm <commande> <@rôle>`\")\n            return\n        if perm_type.lower() == \"perm\":\n            # Deux cas: +set perm <niveau> <@role> OU +set perm <commande> <@role>\n            \n            # Essayer d'abord niveau numérique\n            try:\n                level = int(target_or_level)\n                if level < 1 or level > 9:\n                    await ctx.send(\"❌ Le niveau de permission doit être entre 1 et 9\")\n                    return\n                \n                if not target:\n                    await ctx.send(\"❌ Vous devez mentionner un rôle ou un membre\\n💡 Usage: `+setperm perm <niveau> <@rôle/@membre>`\")\n                    return\n                \n                # Parser le target\n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.set_permission_level(ctx.guild.id, level, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"✅ Rôle {role.mention} assigné au **niveau de permission {level}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"✅ Membre {user.mention} assigné au **niveau de permission {level}**\")\n                \n            except ValueError:\n                # Cas: +set perm <commande> <@role>\n                command_name = target_or_level.lower()\n                if not target:\n                    await ctx.send(\"❌ Vous devez mentionner un rôle ou un membre\\n💡 Usage: `+setperm perm <commande> <@rôle/@membre>`\")\n                    return\n                \n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.set_command_specific_permission(ctx.guild.id, command_name, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"✅ Rôle {role.mention} a maintenant accès à la commande **{command_name}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"✅ Membre {user.mention} a maintenant accès à la commande **{command_name}**\")\n        \n        else:\n            await ctx.send(\"❌ Usage incorrect. Utilisez: `+setperm perm <niveau> <@rôle>` ou `+setperm perm <commande> <@rôle>`\")\n    \n    @commands.command(name=\"delperm\", aliases=[\"del\"])  \n    @admin_only()\n    async def delete_permission(self, ctx, perm_type: str = None, target_or_level: str = None, target: str = None):\n        \"\"\"Supprimer des permissions\n        \n        Usage:\n        +delperm perm <niveau> <@rôle/@membre> - Retirer niveau de permission\n        \"\"\"\n        if not perm_type:\n            await ctx.send(\"❌ Usage: `+delperm perm <niveau> <@rôle/@membre>`\")\n            return\n        if perm_type.lower() == \"perm\":\n            try:\n                level = int(target_or_level)\n                if level < 1 or level > 9:\n                    await ctx.send(\"❌ Le niveau de permission doit être entre 1 et 9\")\n                    return\n                \n                if not target:\n                    await ctx.send(\"❌ Vous devez mentionner un rôle ou un membre\")\n                    return\n                \n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.remove_permission_level(ctx.guild.id, level, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"✅ Rôle {role.mention} retiré du **niveau de permission {level}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"✅ Membre {user.mention} retiré du **niveau de permission {level}**\")\n                \n            except ValueError:\n                await ctx.send(\"❌ Niveau de permission invalide\")\n        else:\n            await ctx.send(\"❌ Usage: `+delperm perm <niveau> <@rôle/@membre>`\")\n    \n    @commands.command(name=\"changeperm\", aliases=[\"change\"])\n    @admin_only()\n    async def change_command_permission(self, ctx, command_name: str = None, permission_level: str = None):\n        \"\"\"Changer le niveau de permission d'une commande\n        \n        Usage:\n        +changeperm <commande> <niveau> - Déplacer commande vers niveau\n        +changeperm reset - Remettre toutes les permissions par défaut\n        \"\"\"\n        if command_name and command_name.lower() == \"reset\":\n            # Reset toutes les permissions\n            await self.bot.db.reset_permissions(ctx.guild.id)\n            await self.bot.db.initialize_default_permissions(ctx.guild.id)\n            await ctx.send(\"✅ **Toutes les permissions ont été remises à leurs valeurs par défaut**\")\n            return\n        \n        if not command_name or not permission_level:\n            await ctx.send(\"❌ Usage: `+changeperm <commande> <niveau>` ou `+changeperm reset`\")\n            return\n        \n        # Valider le niveau de permission\n        valid_levels = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n        if permission_level.lower() not in valid_levels:\n            await ctx.send(f\"❌ Niveau de permission invalide.\\n💡 Niveaux disponibles: {', '.join(valid_levels)}\")\n            return\n        \n        await self.bot.db.set_command_permission(ctx.guild.id, command_name.lower(), permission_level.lower())\n        await ctx.send(f\"✅ Commande **{command_name}** déplacée vers **{permission_level}**\")\n    \n    @commands.command(name=\"changeall\", aliases=[\"moveall\"])\n    @admin_only()\n    async def change_all_commands(self, ctx, old_level: str = None, new_level: str = None):\n        \"\"\"Déplacer toutes les commandes d'un niveau vers un autre\n        \n        Usage: +changeall <ancien_niveau> <nouveau_niveau>\n        Exemple: +changeall perm3 perm4\n        \"\"\"\n        if not old_level or not new_level:\n            await ctx.send(\"❌ Usage: `+changeall <ancien_niveau> <nouveau_niveau>`\\n💡 Exemple: `+changeall perm3 perm4`\")\n            return\n        valid_levels = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n        \n        if old_level.lower() not in valid_levels or new_level.lower() not in valid_levels:\n            await ctx.send(f\"❌ Niveaux invalides.\\n💡 Niveaux disponibles: {', '.join(valid_levels)}\")\n            return\n        \n        # Obtenir toutes les commandes du niveau ancien\n        all_perms = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n        commands_to_move = [cmd for cmd, level in all_perms.items() if level == old_level.lower()]\n        \n        if not commands_to_move:\n            await ctx.send(f\"❌ Aucune commande trouvée au niveau **{old_level}**\")\n            return\n        \n        # Déplacer toutes les commandes\n        for command_name in commands_to_move:\n            await self.bot.db.set_command_permission(ctx.guild.id, command_name, new_level.lower())\n        \n        await ctx.send(f\"✅ **{len(commands_to_move)} commandes** déplacées de **{old_level}** vers **{new_level}**\\n\"\n                      f\"Commandes déplacées: {', '.join(commands_to_move)}\")\n    \n    @commands.command(name=\"helpall\")\n    async def help_all_permissions(self, ctx):\n        \"\"\"Affiche toutes les commandes triées par niveau de permission\"\"\"\n        all_perms = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n        \n        if not all_perms:\n            await ctx.send(\"❌ Aucune permission de commande configurée. Initialisation...\")\n            await self.bot.db.initialize_default_permissions(ctx.guild.id)\n            all_perms = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n        \n        # Grouper par niveau\n        levels = {}\n        for command, level in all_perms.items():\n            if level not in levels:\n                levels[level] = []\n            levels[level].append(command)\n        \n        embed = discord.Embed(\n            title=\"📚 Commandes par niveau de permission\",\n            color=0x0099ff\n        )\n        \n        # Ordre d'affichage\n        level_order = ['buyer', 'owner', 'perm9', 'perm8', 'perm7', 'perm6', 'perm5', 'perm4', 'perm3', 'perm2', 'perm1', 'public', 'everyone']\n        \n        for level in level_order:\n            if level in levels:\n                commands_list = \", \".join(sorted(levels[level]))\n                embed.add_field(\n                    name=f\"🔸 {level.upper()}\",\n                    value=commands_list if len(commands_list) < 1000 else commands_list[:1000] + \"...\",\n                    inline=False\n                )\n        \n        embed.set_footer(text=\"Utilisez +changeperm <commande> <niveau> pour déplacer des commandes\")\n        await ctx.send(embed=embed)\n    \n    @commands.command(name=\"clearperms\", aliases=[\"clear_perms\"])\n    @admin_only()\n    async def clear_permissions(self, ctx):\n        \"\"\"Supprime TOUTES les permissions (DANGEREUX!)\"\"\"\n        # Confirmation\n        embed = discord.Embed(\n            title=\"⚠️ ATTENTION - Suppression de toutes les permissions\",\n            description=\"Cette action est **IRRÉVERSIBLE** et supprimera :\\n\"\n                       \"• Tous les niveaux de permissions\\n\"\n                       \"• Toutes les attributions de rôles/membres\\n\"\n                       \"• Toutes les permissions de commandes\\n\\n\"\n                       \"Réagissez avec ✅ pour confirmer ou ❌ pour annuler\",\n            color=0xff0000\n        )\n        \n        msg = await ctx.send(embed=embed)\n        await msg.add_reaction(\"✅\")\n        await msg.add_reaction(\"❌\")\n        \n        def check(reaction, user):\n            return user == ctx.author and str(reaction.emoji) in [\"✅\", \"❌\"] and reaction.message.id == msg.id\n        \n        try:\n            reaction, user = await self.bot.wait_for(\"reaction_add\", timeout=30.0, check=check)\n            if str(reaction.emoji) == \"✅\":\n                await self.bot.db.reset_permissions(ctx.guild.id)\n                await ctx.send(\"✅ **Toutes les permissions ont été supprimées définitivement**\")\n            else:\n                await ctx.send(\"❌ Suppression annulée\")\n        except asyncio.TimeoutError:\n            await ctx.send(\"❌ Temps écoulé, suppression annulée\")\n    \n    async def _parse_target(self, ctx, target: str):\n        \"\"\"Parse un target mention vers role_id ou user_id\"\"\"\n        role_id = None\n        user_id = None\n        \n        if target.startswith('<@&') and target.endswith('>'):\n            # Role mention\n            try:\n                role_id = int(target[3:-1])\n                role = ctx.guild.get_role(role_id)\n                if not role:\n                    await ctx.send(\"❌ Rôle introuvable\")\n                    return None, None\n            except ValueError:\n                await ctx.send(\"❌ Format de rôle invalide\")\n                return None, None\n                \n        elif target.startswith('<@') and target.endswith('>'):\n            # User mention\n            try:\n                user_id = int(target[2:-1].replace('!', ''))\n                user = ctx.guild.get_member(user_id)\n                if not user:\n                    await ctx.send(\"❌ Membre introuvable\")\n                    return None, None\n            except ValueError:\n                await ctx.send(\"❌ Format de membre invalide\")\n                return None, None\n        else:\n            await ctx.send(\"❌ Format invalide. Utilisez @rôle ou @membre\")\n            return None, None\n        \n        return role_id, user_id\n\nasync def setup(bot):\n    await bot.add_cog(PermissionsCrowBots(bot))","size_bytes":15023}},"version":1}