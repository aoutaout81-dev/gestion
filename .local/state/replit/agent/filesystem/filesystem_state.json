{"file_contents":{"README.md":{"content":"# ğŸ¯ CrowBot Gestion V2\n\n**CrowBot Gestion V2** est un bot Discord de modÃ©ration et d'administration complet, dÃ©veloppÃ© en Python avec discord.py. Il offre un systÃ¨me de gestion avancÃ© pour les serveurs Discord avec des fonctionnalitÃ©s de modÃ©ration, d'administration et de gestion des rÃ´les.\n\n## ğŸ“‹ Table des matiÃ¨res\n\n- [FonctionnalitÃ©s](#-fonctionnalitÃ©s)\n- [Installation](#-installation)\n- [Configuration](#ï¸-configuration)\n- [Structure du projet](#-structure-du-projet)\n- [Commandes disponibles](#-commandes-disponibles)\n- [Permissions et sÃ©curitÃ©](#-permissions-et-sÃ©curitÃ©)\n- [Architecture du code](#-architecture-du-code)\n- [Guide de dÃ©veloppement](#-guide-de-dÃ©veloppement)\n- [Troubleshooting](#-troubleshooting)\n- [Contribuer](#-contribuer)\n\n## ğŸš€ FonctionnalitÃ©s\n\n### ğŸ›ï¸ **Administration**\n- Gestion des permissions par rÃ´le\n- Configuration des cooldowns\n- Gestion du prÃ©fixe personnalisÃ©\n- RÃ©initialisation des paramÃ¨tres\n- Affichage des configurations\n\n### ğŸ”¨ **ModÃ©ration**\n- Bannissement et dÃ©bannissement\n- Expulsion des membres\n- SystÃ¨me de mute temporaire ou permanent\n- SystÃ¨me d'avertissements\n- Historique des infractions\n- Nettoyage de messages\n- Verrouillage/dÃ©verrouillage de salons\n\n### ğŸ‘‘ **Gestion des rÃ´les**\n- Ajout et suppression de rÃ´les\n- CrÃ©ation de rÃ´les avec couleurs personnalisÃ©es\n- Suppression de rÃ´les existants\n- Statistiques dÃ©taillÃ©es des rÃ´les\n- Support des noms, mentions et IDs\n\n### ğŸ›¡ï¸ **SÃ©curitÃ©**\n- SystÃ¨me de permissions hiÃ©rarchique\n- VÃ©rification des rÃ´les et positions\n- Logs dÃ©taillÃ©s de toutes les actions\n- Protection contre l'auto-modÃ©ration\n- Messages d'erreur en franÃ§ais\n\n## ğŸ’» Installation\n\n### PrÃ©requis\n- Python 3.7 ou supÃ©rieur\n- discord.py 2.6+\n- SQLite3 (inclus avec Python)\n\n### Installation rapide\n\n1. **Clonez le projet**\n```bash\ngit clone <url-du-repo>\ncd crowbot-gestion-v2\n```\n\n2. **Installez les dÃ©pendances**\n```bash\npip install discord.py\n```\n\n3. **Configurez le bot**\n   - CrÃ©ez une application Discord sur [Discord Developer Portal](https://discord.com/developers/applications)\n   - RÃ©cupÃ©rez le token du bot\n   - Configurez les variables d'environnement\n\n4. **Lancez le bot**\n```bash\npython main.py\n```\n\n## âš™ï¸ Configuration\n\n### Variables d'environnement\n\nCrÃ©ez un fichier `.env` ou dÃ©finissez les variables suivantes :\n\n```env\nDISCORD_TOKEN=votre_token_discord_ici\n```\n\n### Permissions Discord requises\n\nLe bot nÃ©cessite les permissions suivantes :\n- `GÃ©rer les rÃ´les`\n- `Expulser des membres`\n- `Bannir des membres` \n- `GÃ©rer les messages`\n- `GÃ©rer les salons`\n- `Lire l'historique des messages`\n- `Mentionner tout le monde`\n\n### Intents requis\n\n```python\nintents.message_content = True\nintents.members = True\nintents.guilds = True\n```\n\n## ğŸ“ Structure du projet\n\n```\ncrowbot-gestion-v2/\nâ”œâ”€â”€ main.py                 # Point d'entrÃ©e principal\nâ”œâ”€â”€ bot.py                  # Classe principale du bot\nâ”œâ”€â”€ config.py               # Configuration et constantes\nâ”œâ”€â”€ database.py             # Gestion de la base de donnÃ©es SQLite\nâ”œâ”€â”€ cogs/                   # Modules de commandes\nâ”‚   â”œâ”€â”€ administration.py   # Commandes d'administration\nâ”‚   â”œâ”€â”€ moderation.py      # Commandes de modÃ©ration\nâ”‚   â”œâ”€â”€ roles.py           # Gestion des rÃ´les\nâ”‚   â””â”€â”€ help.py            # SystÃ¨me d'aide\nâ”œâ”€â”€ utils/                  # Utilitaires\nâ”‚   â”œâ”€â”€ permissions.py     # SystÃ¨me de permissions\nâ”‚   â”œâ”€â”€ helpers.py         # Fonctions d'aide\nâ”‚   â””â”€â”€ converters.py      # Convertisseurs personnalisÃ©s\nâ”œâ”€â”€ crowbot.db             # Base de donnÃ©es SQLite (auto-crÃ©Ã©e)\nâ”œâ”€â”€ crowbot.log            # Fichier de logs\nâ””â”€â”€ README.md              # Ce fichier\n```\n\n## ğŸ“š Commandes disponibles\n\n### ğŸ›ï¸ Administration\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `setperm` | Attribuer une permission | `+setperm <commande> <rÃ´le>` |\n| `unsetperm` | Retirer une permission | `+unsetperm <commande> <rÃ´le>` |\n| `perms` | Voir toutes les permissions | `+perms` |\n| `resetperms` | RÃ©initialiser les permissions | `+resetperms` |\n| `cooldown` | DÃ©finir un dÃ©lai d'attente | `+cooldown <commande> <secondes>` |\n| `settings` | Voir les paramÃ¨tres du serveur | `+settings` |\n| `prefix` | Changer le prÃ©fixe | `+prefix <nouveau_prÃ©fixe>` |\n\n### ğŸ”¨ ModÃ©ration\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `ban` | Bannir un membre | `+ban <membre> [raison]` |\n| `unban` | DÃ©bannir un utilisateur | `+unban <id_utilisateur>` |\n| `kick` | Expulser un membre | `+kick <membre> [raison]` |\n| `mute` | Rendre muet un membre | `+mute <membre> [durÃ©e] [raison]` |\n| `unmute` | Enlever le mute | `+unmute <membre>` |\n| `warn` | Avertir un membre | `+warn <membre> [raison]` |\n| `infractions` | Voir l'historique d'un membre | `+infractions <membre>` |\n| `mutelist` | Liste des membres muÃ©s | `+mutelist` |\n| `clear` | Supprimer des messages | `+clear <nombre>` |\n| `lock` | Verrouiller un salon | `+lock [#salon]` |\n| `unlock` | DÃ©verrouiller un salon | `+unlock [#salon]` |\n\n### ğŸ‘‘ Gestion des rÃ´les\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `addrole` | Ajouter un rÃ´le Ã  un membre | `+addrole <membre> <rÃ´le>` |\n| `delrole` | Retirer un rÃ´le d'un membre | `+delrole <membre> <rÃ´le>` |\n| `createrole` | CrÃ©er un nouveau rÃ´le | `+createrole <nom> [couleur] [permissions]` |\n| `deleterole` | Supprimer un rÃ´le | `+deleterole <rÃ´le>` |\n| `rolestats` | Statistiques d'un rÃ´le | `+rolestats <rÃ´le>` |\n\n### ğŸ“š Aide\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `help` | Menu d'aide principal | `+help [catÃ©gorie]` |\n| `help administration` | Aide administration | `+help administration` |\n| `help moderation` | Aide modÃ©ration | `+help moderation` |\n| `help roles` | Aide gestion des rÃ´les | `+help roles` |\n\n## ğŸ”’ Permissions et sÃ©curitÃ©\n\n### SystÃ¨me de permissions hiÃ©rarchique\n\n1. **PropriÃ©taire du bot** : AccÃ¨s total\n2. **PropriÃ©taire du serveur** : AccÃ¨s total sur son serveur  \n3. **Administrateurs** : Commandes d'administration et modÃ©ration\n4. **RÃ´les personnalisÃ©s** : Selon configuration avec `setperm`\n\n### Protections intÃ©grÃ©es\n\n- âœ… VÃ©rification de la hiÃ©rarchie des rÃ´les\n- âœ… ImpossibilitÃ© d'auto-modÃ©ration\n- âœ… Protection des rÃ´les systÃ¨me\n- âœ… Validation des permissions Discord\n- âœ… Logs complets de toutes les actions\n\n### Format des durÃ©es\n\nPour les commandes temporaires (mute) :\n- `10s` = 10 secondes\n- `5m` = 5 minutes  \n- `2h` = 2 heures\n- `1d` = 1 jour\n- `1w` = 1 semaine\n\n### Couleurs disponibles pour les rÃ´les\n\n**Noms prÃ©dÃ©finis :**\n`rouge`, `bleu`, `vert`, `jaune`, `orange`, `violet`, `rose`, `cyan`, `noir`, `blanc`\n\n**Format hexadÃ©cimal :**\n`#FF0000`, `#00FF00`, `#0000FF`, etc.\n\n## ğŸ—ï¸ Architecture du code\n\n### Composants principaux\n\n#### `main.py`\nPoint d'entrÃ©e du bot qui :\n- Configure les logs\n- RÃ©cupÃ¨re le token\n- Lance le bot avec gestion des erreurs\n\n#### `bot.py` - Classe CrowBot\nClasse principale hÃ©ritant de `commands.Bot` :\n- Configuration des intents\n- Gestion des prÃ©fixes dynamiques\n- Chargement des cogs\n- Gestion globale des erreurs\n- SystÃ¨me de permissions personnalisÃ©\n\n#### `database.py` - Gestion des donnÃ©es\nClasse Database avec SQLite :\n- Tables : guilds, permissions, cooldowns, infractions, mutes, logs\n- OpÃ©rations asynchrones avec verrous\n- MÃ©thodes CRUD complÃ¨tes\n\n#### `config.py` - Configuration\nCentralise toutes les configurations :\n- Couleurs des embeds\n- Listes de commandes par catÃ©gorie\n- UnitÃ©s de temps\n- PrÃ©fixe par dÃ©faut\n\n### Structure des Cogs\n\nChaque cog reprÃ©sente une catÃ©gorie de fonctionnalitÃ©s :\n\n```python\nclass MonCog(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command()\n    @has_permission()  # DÃ©corateur de permissions\n    async def ma_commande(self, ctx, arg: CustomConverter):\n        # Logique de la commande\n        pass\n```\n\n### SystÃ¨me de permissions\n\n#### DÃ©corateurs disponibles\n\n```python\n@has_permission()    # VÃ©rifie permissions + cooldown\n@admin_only()        # Administrateurs uniquement\n```\n\n#### Convertisseurs personnalisÃ©s\n\n```python\nMemberConverter     # Membre par nom/mention/ID\nRoleConverter       # RÃ´le par nom/mention/ID  \nUserConverter       # Utilisateur par nom/ID\n```\n\n## ğŸ› ï¸ Guide de dÃ©veloppement\n\n### Ajouter une nouvelle commande\n\n1. **Choisir le cog appropriÃ©** ou crÃ©er un nouveau\n2. **DÃ©finir la commande avec dÃ©corateurs**\n3. **ImplÃ©menter la logique mÃ©tier**\n4. **Ajouter les vÃ©rifications de sÃ©curitÃ©**\n5. **Logger l'action si nÃ©cessaire**\n6. **Mettre Ã  jour l'aide**\n\n#### Exemple complet\n\n```python\n@commands.command(name=\"macommande\")\n@has_permission()\nasync def ma_commande(self, ctx, membre: MemberConverter, *, raison: str = \"Aucune raison\"):\n    \"\"\"Description de ma commande\"\"\"\n    \n    # VÃ©rifications de sÃ©curitÃ©\n    if membre == ctx.author:\n        embed = discord.Embed(\n            title=\"âŒ Erreur\",\n            description=\"Vous ne pouvez pas vous cibler vous-mÃªme.\",\n            color=self.bot.config.error_color\n        )\n        await ctx.send(embed=embed)\n        return\n    \n    try:\n        # Logique principale\n        # ... votre code ici ...\n        \n        # Log de l'action\n        await self.bot.db.log_moderation_action(\n            ctx.guild.id, membre.id, ctx.author.id, \"macommande\", raison\n        )\n        \n        # Confirmation\n        embed = discord.Embed(\n            title=\"âœ… SuccÃ¨s\",\n            description=f\"Action rÃ©alisÃ©e sur **{membre}**.\",\n            color=self.bot.config.success_color\n        )\n        embed.add_field(name=\"Raison\", value=raison, inline=False)\n        await ctx.send(embed=embed)\n        \n    except Exception as e:\n        embed = discord.Embed(\n            title=\"âŒ Erreur\",\n            description=f\"Ã‰chec de l'opÃ©ration : {str(e)}\",\n            color=self.bot.config.error_color\n        )\n        await ctx.send(embed=embed)\n```\n\n### Ajouter un nouveau cog\n\n1. **CrÃ©er le fichier** `cogs/mon_cog.py`\n2. **ImplÃ©menter la classe** hÃ©ritant de `commands.Cog`\n3. **Ajouter la fonction setup**\n4. **Charger dans bot.py**\n5. **Mettre Ã  jour l'aide**\n\n#### Template de cog\n\n```python\nimport discord\nfrom discord.ext import commands\nfrom utils.permissions import has_permission\nfrom utils.converters import MemberConverter\n\nclass MonCog(commands.Cog):\n    \"\"\"Description de mon cog\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"test\")\n    @has_permission()\n    async def test_command(self, ctx):\n        \"\"\"Commande de test\"\"\"\n        await ctx.send(\"Commande test fonctionnelle !\")\n\nasync def setup(bot):\n    await bot.add_cog(MonCog(bot))\n```\n\n### Ã‰tendre la base de donnÃ©es\n\nPour ajouter une nouvelle table :\n\n```python\n# Dans database.py, mÃ©thode initialize()\ncursor.execute('''\n    CREATE TABLE IF NOT EXISTS ma_table (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        guild_id INTEGER,\n        user_id INTEGER,\n        data TEXT,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n''')\n```\n\nAjouter les mÃ©thodes CRUD correspondantes.\n\n### Tests et debugging\n\n#### Logs disponibles\n\n```python\nself.bot.logger.info(\"Message d'information\")\nself.bot.logger.warning(\"Avertissement\")\nself.bot.logger.error(\"Erreur\")\n```\n\nLes logs sont Ã©crits dans `crowbot.log` et la console.\n\n#### Variables d'environnement de debug\n\n```env\nDISCORD_TOKEN=votre_token\nDEBUG=1  # Active le mode debug (optionnel)\n```\n\n## ğŸ”§ Troubleshooting\n\n### ProblÃ¨mes courants\n\n#### Le bot ne se connecte pas\n- VÃ©rifiez le token Discord\n- VÃ©rifiez les intents dans le Developer Portal\n- VÃ©rifiez que le bot a Ã©tÃ© invitÃ© sur le serveur\n\n#### Commandes ne fonctionnent pas\n- VÃ©rifiez le prÃ©fixe configurÃ© (`+settings`)\n- VÃ©rifiez les permissions Discord du bot\n- VÃ©rifiez les permissions personnalisÃ©es (`+perms`)\n\n#### Erreurs de base de donnÃ©es\n- VÃ©rifiez les permissions d'Ã©criture du dossier\n- Supprimez `crowbot.db` pour rÃ©initialiser (âš ï¸ perte de donnÃ©es)\n\n#### Erreurs de permissions\n- VÃ©rifiez la position du rÃ´le du bot\n- VÃ©rifiez que le bot a les permissions Discord nÃ©cessaires\n- VÃ©rifiez la hiÃ©rarchie des rÃ´les\n\n### Messages d'erreur frÃ©quents\n\n#### \"Membre introuvable\"\nL'utilisateur saisi n'existe pas sur le serveur ou le nom est incorrect.\n\n#### \"RÃ´le introuvable\"  \nLe rÃ´le saisi n'existe pas ou le nom est incorrect.\n\n#### \"Permission insuffisante\"\nLe bot n'a pas les permissions Discord nÃ©cessaires pour cette action.\n\n#### \"Argument requis manquant\"\nUne commande a Ã©tÃ© utilisÃ©e sans tous ses arguments obligatoires.\n\n### Commandes de diagnostic\n\n```bash\n# VÃ©rifier les permissions\n+settings\n\n# Voir les permissions personnalisÃ©es\n+perms\n\n# Tester une commande simple\n+help\n```\n\n## ğŸ“ Changelog\n\n### Version 2.0\n- âœ… SystÃ¨me de gestion des rÃ´les complet\n- âœ… Convertisseurs personnalisÃ©s pour noms/mentions/IDs\n- âœ… Messages d'erreur en franÃ§ais\n- âœ… Commande help avec menu par catÃ©gories\n- âœ… AmÃ©lioration du systÃ¨me de permissions\n- âœ… Logs dÃ©taillÃ©s de toutes les actions\n\n### Version 1.0\n- âœ… SystÃ¨me de modÃ©ration complet\n- âœ… Gestion des permissions par rÃ´le\n- âœ… Base de donnÃ©es SQLite\n- âœ… SystÃ¨me d'infractions et mutes\n- âœ… Configuration par serveur\n\n## ğŸ“„ License\n\nCe projet est sous licence MIT. Voir le fichier `LICENSE` pour plus de dÃ©tails.\n\n## ğŸ¤ Contribuer\n\nLes contributions sont les bienvenues ! \n\n1. **Fork** le projet\n2. **CrÃ©er** une branche feature (`git checkout -b feature/AmazingFeature`)\n3. **Commit** vos changements (`git commit -m 'Add AmazingFeature'`)\n4. **Push** vers la branche (`git push origin feature/AmazingFeature`)\n5. **Ouvrir** une Pull Request\n\n### Guidelines de contribution\n\n- Respecter le style de code existant\n- Ajouter des tests pour les nouvelles fonctionnalitÃ©s\n- Mettre Ã  jour la documentation\n- S'assurer que tous les tests passent\n\n## ğŸ“ Support\n\nPour obtenir de l'aide :\n\n1. Consulter ce README\n2. VÃ©rifier les [Issues GitHub](lien-vers-issues)\n3. Utiliser la commande `+help` dans Discord\n4. Consulter les logs dans `crowbot.log`\n\n---\n\n**DÃ©veloppÃ© avec â¤ï¸ en Python | Powered by discord.py**","size_bytes":14402},"bot.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nimport logging\nfrom database import Database\nfrom config import Config\n\nclass CrowBot(commands.Bot):\n    def __init__(self):\n        # Initialize with default prefix, will be updated from database\n        intents = discord.Intents.default()\n        intents.message_content = True\n        intents.members = True\n        intents.guilds = True\n        \n        super().__init__(\n            command_prefix=self.get_prefix,\n            intents=intents,\n            help_command=None\n        )\n        \n        self.db = Database()\n        self.config = Config()\n        self.logger = logging.getLogger('chdfz gestion')\n        \n    async def get_prefix(self, message):\n        \"\"\"Get the prefix for a guild\"\"\"\n        if message.guild is None:\n            return self.config.default_prefix\n        \n        prefix = await self.db.get_guild_prefix(message.guild.id)\n        return prefix or self.config.default_prefix\n    \n    async def setup_hook(self):\n        await self.db.initialize()\n        cogs = [\n            'cogs.administration',\n            'cogs.moderation',\n            'cogs.roles',\n            'cogs.help_interactive',\n            'cogs.triggers',\n            'cogs.ownership',\n            'cogs.permissions_crowbots'\n        ]\n\n        for cog in cogs:\n            if cog not in self.extensions:  # â† empÃªche le rechargement\n                try:\n                    await self.load_extension(cog)\n                    self.logger.info(f\"Loaded cog: {cog}\")\n                except Exception as e:\n                    self.logger.error(f\"Failed to load cog {cog}: {e}\")\n    \n    async def on_ready(self):\n        \"\"\"Called when the bot is ready\"\"\"\n        self.logger.info(f'{self.user.name if self.user else \"Bot\"} has connected to Discord!')\n        self.logger.info(f'Bot is in {len(self.guilds)} guilds')\n        \n        # Set bot status\n        await self.change_presence(\n            activity=discord.Activity(\n                type=discord.ActivityType.watching,\n                name=\"for infractions | +help\"\n            )\n        )\n    \n    async def on_guild_join(self, guild):\n        \"\"\"Called when the bot joins a new guild\"\"\"\n        self.logger.info(f\"Joined guild: {guild.name} (ID: {guild.id})\")\n        await self.db.setup_guild(guild.id)\n    \n    async def on_command_error(self, ctx, error):\n        \"\"\"Global error handler\"\"\"\n        if isinstance(error, commands.CommandNotFound):\n            return\n        \n        if isinstance(error, commands.CheckFailure):\n            # Don't send error message for check failures, already handled by custom checks\n            return\n        \n        if isinstance(error, commands.MissingPermissions):\n            perms = \", \".join(error.missing_permissions)\n            await ctx.send(f\"âŒ **Permissions manquantes :** `{perms}`\\nğŸ’¡ Vous devez avoir ces permissions pour utiliser cette commande.\")\n            return\n        \n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send(f\"âŒ **Argument manquant :** `{error.param.name}`\\nğŸ’¡ Utilisez `+help` pour voir la syntaxe correcte.\")\n            return\n        \n        if isinstance(error, commands.BadArgument):\n            await ctx.send(f\"âŒ **Argument invalide :** {error}\\nğŸ’¡ VÃ©rifiez la syntaxe de votre commande.\")\n            return\n        \n        if isinstance(error, commands.CommandOnCooldown):\n            await ctx.send(f\"âŒ **Commande en cooldown**\\nâ° RÃ©essayez dans {error.retry_after:.1f} secondes.\")\n            return\n        \n        # Handle custom converter errors\n        if isinstance(error, commands.MemberNotFound):\n            await ctx.send(f\"âŒ **Membre introuvable :** {error}\")\n            return\n        \n        if isinstance(error, commands.RoleNotFound):\n            await ctx.send(f\"âŒ **RÃ´le introuvable :** {error}\")\n            return\n        \n        if isinstance(error, commands.UserNotFound):\n            await ctx.send(f\"âŒ **Utilisateur introuvable :** {error}\")\n            return\n        \n        # Enhanced error logging with more details\n        self.logger.error(f\"Unhandled error in command '{ctx.command}' by {ctx.author} ({ctx.author.id}) in {ctx.guild.name if ctx.guild else 'DM'}: {error}\")\n        await ctx.send(f\"âŒ **Erreur inattendue**\\nğŸ”§ DÃ©tails : `{str(error)[:100]}...`\\nğŸ’¡ Contactez l'administrateur si le problÃ¨me persiste.\")\n    \n    async def check_permissions(self, ctx, command_name):\n        \"\"\"Check if user has permission to use a command\"\"\"\n        # Initialize default permissions if not set\n        existing_perms = await self.db.get_all_command_permissions(ctx.guild.id)\n        if not existing_perms:\n            await self.db.initialize_default_permissions(ctx.guild.id)\n        \n        # Bot owner always has permission\n        if await self.is_owner(ctx.author):\n            return True\n        \n        # Server owner always has permission  \n        if ctx.author == ctx.guild.owner:\n            return True\n        \n        # Check buyer permission\n        if await self.is_buyer_user(ctx.author.id):\n            return True\n        \n        # Check owner permission\n        if await self.is_owner_user(ctx.author.id):\n            command_level = await self.db.get_command_permission_level(ctx.guild.id, command_name)\n            if command_level in ['owner', 'buyer', 'public', 'everyone'] or command_level.startswith('perm'):\n                return True\n        \n        # Get command permission level\n        command_level = await self.db.get_command_permission_level(ctx.guild.id, command_name)\n        if not command_level:\n            return True  # Default allow if no permission set\n        \n        # Check specific command permissions (role/user specific)\n        specific_perms = await self.db.get_command_specific_permissions(ctx.guild.id, command_name)\n        user_roles = [role.id for role in ctx.author.roles]\n        \n        # Check if user has specific permission for this command\n        if ctx.author.id in specific_perms.get('users', []):\n            return True\n        \n        # Check if user has role with specific permission for this command\n        if any(role_id in specific_perms.get('roles', []) for role_id in user_roles):\n            return True\n        \n        # Handle special permission levels\n        if command_level == 'everyone':\n            return True\n        \n        if command_level == 'public':\n            return True  # TODO: Add public channel check if needed\n        \n        if command_level == 'owner':\n            return await self.is_owner_user(ctx.author.id)\n        \n        if command_level == 'buyer':\n            return await self.is_buyer_user(ctx.author.id)\n        \n        # Handle permission levels (perm1-perm9)\n        if command_level.startswith('perm'):\n            try:\n                required_level = int(command_level[4:])  # Extract number from \"perm1\", \"perm2\", etc.\n                user_max_level = await self.get_user_max_permission_level(ctx.author, ctx.guild.id)\n                \n                # Hierarchical: higher levels include lower levels\n                return user_max_level >= required_level\n            except (ValueError, TypeError):\n                return False\n        \n        return False\n    \n    async def get_user_max_permission_level(self, user, guild_id):\n        \"\"\"Get user's highest permission level\"\"\"\n        # Get all permission levels for the guild\n        permission_levels = await self.db.get_permission_levels(guild_id)\n        \n        user_roles = [role.id for role in user.roles]\n        max_level = 0\n        \n        for level, data in permission_levels.items():\n            # Check if user has this level through role or direct assignment\n            has_level = (\n                user.id in data.get('users', []) or\n                any(role_id in data.get('roles', []) for role_id in user_roles)\n            )\n            \n            if has_level and level > max_level:\n                max_level = level\n        \n        return max_level\n    \n    async def check_cooldown(self, ctx, command_name):\n        \"\"\"Check if command is on cooldown for user\"\"\"\n        cooldown_time = await self.db.get_command_cooldown(ctx.guild.id, command_name)\n        if not cooldown_time:\n            return True\n        \n        last_used = await self.db.get_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n        if not last_used:\n            await self.db.update_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n            return True\n        \n        import time\n        if time.time() - last_used < cooldown_time:\n            return False\n        \n        await self.db.update_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n        return True\n","size_bytes":8823},"config.py":{"content":"class Config:\n    def __init__(self):\n        self.default_prefix = \"+\"\n        self.bot_description = \"CrowBot Gestion V2 - Discord Moderation Bot\"\n        self.embed_color = 0x2F3136\n        self.error_color = 0xFF0000\n        self.success_color = 0x00FF00\n        self.warning_color = 0xFFFF00\n        \n        # Command categories\n        self.moderation_commands = [\n            'ban', 'unban', 'kick', 'mute', 'unmute', 'warn', \n            'clear', 'lock', 'unlock', 'infractions', 'mutelist'\n        ]\n        \n        self.admin_commands = [\n            'setperm', 'unsetperm', 'perms', 'resetperms', \n            'cooldown', 'settings', 'prefix'\n        ]\n        \n        # Time parsing formats\n        self.time_units = {\n            's': 1,\n            'm': 60,\n            'h': 3600,\n            'd': 86400,\n            'w': 604800\n        }\n","size_bytes":856},"database.py":{"content":"import sqlite3\nimport asyncio\nimport json\nimport time\nimport secrets\nfrom typing import List, Optional, Dict, Any\n\nclass Database:\n    def __init__(self, db_path: str = \"crowbot.db\"):\n        self.db_path = db_path\n        self._lock = asyncio.Lock()\n    \n    async def initialize(self):\n        \"\"\"Initialize the database with required tables\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Guild settings table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS guild_settings (\n                    guild_id INTEGER PRIMARY KEY,\n                    prefix TEXT DEFAULT '+',\n                    log_channel_id INTEGER,\n                    mute_role_id INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Permission levels table (perm 1-9)\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS permission_levels (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    level INTEGER,\n                    role_id INTEGER,\n                    user_id INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, level, role_id),\n                    UNIQUE(guild_id, level, user_id)\n                )\n            ''')\n            \n            # Command permissions table - now maps commands to permission levels\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_permissions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    command_name TEXT,\n                    permission_level TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, command_name)\n                )\n            ''')\n            \n            # Command-specific permissions (for individual roles/users)\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_specific_permissions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    command_name TEXT,\n                    role_id INTEGER,\n                    user_id INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, command_name, role_id),\n                    UNIQUE(guild_id, command_name, user_id)\n                )\n            ''')\n            \n            # Command cooldowns table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_cooldowns (\n                    guild_id INTEGER,\n                    command_name TEXT,\n                    cooldown_seconds INTEGER,\n                    PRIMARY KEY(guild_id, command_name)\n                )\n            ''')\n            \n            # Command usage tracking\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_usage (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    command_name TEXT,\n                    last_used TIMESTAMP,\n                    PRIMARY KEY(guild_id, user_id, command_name)\n                )\n            ''')\n            \n            # Infractions table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS infractions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    moderator_id INTEGER,\n                    infraction_type TEXT,\n                    reason TEXT,\n                    duration INTEGER,\n                    active BOOLEAN DEFAULT 1,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Muted users table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS muted_users (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    muted_until TIMESTAMP,\n                    reason TEXT,\n                    moderator_id INTEGER,\n                    PRIMARY KEY(guild_id, user_id)\n                )\n            ''')\n            \n            # Moderation logs\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS moderation_logs (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    moderator_id INTEGER,\n                    action TEXT,\n                    reason TEXT,\n                    details TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Bot ownership tables\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS bot_ownership (\n                    guild_id INTEGER PRIMARY KEY,\n                    buyer_id INTEGER,\n                    recovery_code TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Owners table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS owners (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Whitelist table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS whitelist (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Blacklist rank table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS blacklist_rank (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Leash system table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS leash_system (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    owner_id INTEGER,\n                    original_nick TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    PRIMARY KEY(guild_id, user_id)\n                )\n            ''')\n            \n            conn.commit()\n            conn.close()\n    \n    # Extensions from database_extensions.py\n    # Bot Ownership methods\n    async def set_buyer(self, guild_id: int, buyer_id: int) -> str:\n        \"\"\"Set the buyer/owner of the bot for a guild and generate recovery code\"\"\"\n        recovery_code = secrets.token_hex(16)\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO bot_ownership (guild_id, buyer_id, recovery_code)\n                VALUES (?, ?, ?)\n            ''', (guild_id, buyer_id, recovery_code))\n            \n            conn.commit()\n            conn.close()\n            \n        return recovery_code\n    \n    async def get_buyer(self, guild_id: int) -> Optional[int]:\n        \"\"\"Get the buyer ID for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT buyer_id FROM bot_ownership WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def verify_recovery_code(self, guild_id: int, code: str) -> bool:\n        \"\"\"Verify recovery code for buyer transfer\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT recovery_code FROM bot_ownership WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result and result[0] == code\n    \n    # Owners methods\n    async def add_owner(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO owners (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_owner(self, guild_id: int, user_id: int):\n        \"\"\"Remove an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM owners WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_owner(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM owners WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_owners(self, guild_id: int) -> List[int]:\n        \"\"\"Get all owners for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM owners WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Whitelist methods\n    async def add_whitelist(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add user to whitelist\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO whitelist (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_whitelist(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from whitelist\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM whitelist WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_whitelisted(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is whitelisted\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM whitelist WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_whitelist(self, guild_id: int) -> List[int]:\n        \"\"\"Get all whitelisted users\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM whitelist WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Blacklist rank methods\n    async def add_blacklist_rank(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add user to blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO blacklist_rank (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_blacklist_rank(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM blacklist_rank WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_blacklist_rank(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is in blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM blacklist_rank WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_blacklist_rank(self, guild_id: int) -> List[int]:\n        \"\"\"Get all blacklisted rank users\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM blacklist_rank WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Leash system methods\n    async def add_leash(self, guild_id: int, user_id: int, owner_id: int, original_nick: str):\n        \"\"\"Put user on leash\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO leash_system (guild_id, user_id, owner_id, original_nick)\n                VALUES (?, ?, ?, ?)\n            ''', (guild_id, user_id, owner_id, original_nick))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_leash(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from leash\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM leash_system WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_leash_info(self, guild_id: int, user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get leash info for user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT owner_id, original_nick FROM leash_system \n                WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            if result:\n                return {\n                    'owner_id': result[0],\n                    'original_nick': result[1]\n                }\n            return None\n    \n    async def is_leashed(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is leashed\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM leash_system WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def setup_guild(self, guild_id: int):\n        \"\"\"Setup a new guild in the database\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO guild_settings (guild_id) VALUES (?)\n            ''', (guild_id,))\n            \n            conn.commit()\n            conn.close()\n    \n    # Guild settings methods\n    async def get_guild_prefix(self, guild_id: int) -> Optional[str]:\n        \"\"\"Get the prefix for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT prefix FROM guild_settings WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def set_guild_prefix(self, guild_id: int, prefix: str):\n        \"\"\"Set the prefix for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO guild_settings (guild_id, prefix) VALUES (?, ?)\n            ''', (guild_id, prefix))\n            \n            conn.commit()\n            conn.close()\n    \n    # Permission Level methods\n    async def set_permission_level(self, guild_id: int, level: int, role_id: int = None, user_id: int = None):\n        \"\"\"Set a role or user to a permission level\"\"\"\n        level_name = f\"perm{level}\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            if role_id:\n                cursor.execute('''\n                    INSERT OR REPLACE INTO permission_levels (guild_id, level_name, role_id) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, level_name, role_id))\n            elif user_id:\n                cursor.execute('''\n                    INSERT OR REPLACE INTO permission_levels (guild_id, level_name, user_id) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, level_name, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_permission_level(self, guild_id: int, level: int, role_id: int = None, user_id: int = None):\n        \"\"\"Remove a role or user from a permission level\"\"\"\n        level_name = f\"perm{level}\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            if role_id:\n                cursor.execute('''\n                    DELETE FROM permission_levels \n                    WHERE guild_id = ? AND level_name = ? AND role_id = ?\n                ''', (guild_id, level_name, role_id))\n            elif user_id:\n                cursor.execute('''\n                    DELETE FROM permission_levels \n                    WHERE guild_id = ? AND level_name = ? AND user_id = ?\n                ''', (guild_id, level_name, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_permission_levels(self, guild_id: int) -> Dict[int, Dict]:\n        \"\"\"Get all permission levels for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT level_name, role_id, user_id FROM permission_levels \n                WHERE guild_id = ?\n                ORDER BY level_name\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            levels = {}\n            for level_name, role_id, user_id in results:\n                # Convert \"perm1\" to 1\n                if level_name.startswith('perm'):\n                    try:\n                        level_num = int(level_name[4:])\n                        if level_num not in levels:\n                            levels[level_num] = {'roles': [], 'users': []}\n                        if role_id:\n                            levels[level_num]['roles'].append(role_id)\n                        if user_id:\n                            levels[level_num]['users'].append(user_id)\n                    except ValueError:\n                        pass\n            \n            return levels\n    \n    async def set_command_permission(self, guild_id: int, command_name: str, permission_level: str):\n        \"\"\"Set command to a permission level\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO command_permissions (guild_id, command_name, permission_level) \n                VALUES (?, ?, ?)\n            ''', (guild_id, command_name, permission_level))\n            \n            conn.commit()\n            conn.close()\n    \n    async def set_command_specific_permission(self, guild_id: int, command_name: str, role_id: int = None, user_id: int = None):\n        \"\"\"Set specific permission for a command to a role or user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            if role_id:\n                cursor.execute('''\n                    INSERT OR REPLACE INTO command_specific_permissions (guild_id, command_name, role_id) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, command_name, role_id))\n            elif user_id:\n                cursor.execute('''\n                    INSERT OR REPLACE INTO command_specific_permissions (guild_id, command_name, user_id) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, command_name, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_command_specific_permission(self, guild_id: int, command_name: str, role_id: int = None, user_id: int = None):\n        \"\"\"Remove specific permission for a command from a role or user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            if role_id:\n                cursor.execute('''\n                    DELETE FROM command_specific_permissions \n                    WHERE guild_id = ? AND command_name = ? AND role_id = ?\n                ''', (guild_id, command_name, role_id))\n            elif user_id:\n                cursor.execute('''\n                    DELETE FROM command_specific_permissions \n                    WHERE guild_id = ? AND command_name = ? AND user_id = ?\n                ''', (guild_id, command_name, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_command_permission_level(self, guild_id: int, command_name: str) -> str:\n        \"\"\"Get permission level for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT permission_level FROM command_permissions \n                WHERE guild_id = ? AND command_name = ?\n            ''', (guild_id, command_name))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def get_all_command_permissions(self, guild_id: int) -> Dict[str, str]:\n        \"\"\"Get all command permissions for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT command_name, permission_level FROM command_permissions \n                WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return {command_name: permission_level for command_name, permission_level in results}\n    \n    async def get_command_specific_permissions(self, guild_id: int, command_name: str) -> Dict:\n        \"\"\"Get specific permissions for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT role_id, user_id FROM command_specific_permissions \n                WHERE guild_id = ? AND command_name = ?\n            ''', (guild_id, command_name))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            permissions = {'roles': [], 'users': []}\n            for role_id, user_id in results:\n                if role_id:\n                    permissions['roles'].append(role_id)\n                if user_id:\n                    permissions['users'].append(user_id)\n            \n            return permissions\n    \n    async def reset_permissions(self, guild_id: int):\n        \"\"\"Reset all permissions for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('DELETE FROM permission_levels WHERE guild_id = ?', (guild_id,))\n            cursor.execute('DELETE FROM command_permissions WHERE guild_id = ?', (guild_id,))\n            cursor.execute('DELETE FROM command_specific_permissions WHERE guild_id = ?', (guild_id,))\n            \n            conn.commit()\n            conn.close()\n    \n    async def initialize_default_permissions(self, guild_id: int):\n        \"\"\"Initialize default command permissions\"\"\"\n        defaults = {\n            # Perm 1 - Basic moderation\n            'clear': 'perm1',\n            'warn': 'perm1', \n            'mute': 'perm1',\n            \n            # Perm 2 - Full moderation\n            'kick': 'perm2',\n            'ban': 'perm2',\n            'unban': 'perm2',\n            'unmute': 'perm2',\n            'delwarn': 'perm2',\n            'infractions': 'perm2',\n            'mutelist': 'perm2',\n            'lock': 'perm2',\n            'unlock': 'perm2',\n            \n            # Perm 3 - Administration\n            'setperm': 'perm3',\n            'delperm': 'perm3',\n            'clearperm': 'perm3',\n            'change': 'perm3',\n            'changeall': 'perm3',\n            'resetperms': 'perm3',\n            'setcooldown': 'perm3',\n            'settings': 'perm3',\n            'prefix': 'perm3',\n            'addrole': 'perm3',\n            'delrole': 'perm3',\n            'massrole': 'perm3',\n            \n            # Owners only\n            'say': 'owner',\n            'dm': 'owner',\n            'laisse': 'owner',\n            'unlaisse': 'owner',\n            'wl': 'owner',\n            'unwl': 'owner',\n            'blrank': 'owner',\n            \n            # Buyer only\n            'owner': 'buyer',\n            'unowner': 'buyer',\n            'buyer': 'buyer',\n            \n            # Public commands\n            'help': 'public',\n            'helpall': 'public',\n            'ping': 'public',\n            'perms': 'public'\n        }\n        \n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            for command, perm_level in defaults.items():\n                cursor.execute('''\n                    INSERT OR IGNORE INTO command_permissions (guild_id, command_name, permission_level) \n                    VALUES (?, ?, ?)\n                ''', (guild_id, command, perm_level))\n            \n            conn.commit()\n            conn.close()\n    \n    # Cooldown methods\n    async def set_command_cooldown(self, guild_id: int, command_name: str, cooldown_seconds: int):\n        \"\"\"Set cooldown for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO command_cooldowns (guild_id, command_name, cooldown_seconds) \n                VALUES (?, ?, ?)\n            ''', (guild_id, command_name, cooldown_seconds))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_command_cooldown(self, guild_id: int, command_name: str) -> Optional[int]:\n        \"\"\"Get cooldown for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT cooldown_seconds FROM command_cooldowns \n                WHERE guild_id = ? AND command_name = ?\n            ''', (guild_id, command_name))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def get_last_command_use(self, guild_id: int, user_id: int, command_name: str) -> Optional[float]:\n        \"\"\"Get last time user used a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT last_used FROM command_usage \n                WHERE guild_id = ? AND user_id = ? AND command_name = ?\n            ''', (guild_id, user_id, command_name))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return float(result[0]) if result else None\n    \n    async def update_last_command_use(self, guild_id: int, user_id: int, command_name: str):\n        \"\"\"Update last command use time\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO command_usage (guild_id, user_id, command_name, last_used) \n                VALUES (?, ?, ?, ?)\n            ''', (guild_id, user_id, command_name, time.time()))\n            \n            conn.commit()\n            conn.close()\n    \n    # Infraction methods\n    async def add_infraction(self, guild_id: int, user_id: int, moderator_id: int, \n                           infraction_type: str, reason: Optional[str] = None, duration: Optional[int] = None):\n        \"\"\"Add an infraction\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT INTO infractions (guild_id, user_id, moderator_id, infraction_type, reason, duration) \n                VALUES (?, ?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, moderator_id, infraction_type, reason, duration))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_user_infractions(self, guild_id: int, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all infractions for a user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT infraction_type, reason, duration, created_at, moderator_id \n                FROM infractions \n                WHERE guild_id = ? AND user_id = ? \n                ORDER BY created_at DESC\n            ''', (guild_id, user_id))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            infractions = []\n            for result in results:\n                infractions.append({\n                    'type': result[0],\n                    'reason': result[1],\n                    'duration': result[2],\n                    'created_at': result[3],\n                    'moderator_id': result[4]\n                })\n            \n            return infractions\n    \n    async def get_user_warnings(self, guild_id: int, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all warnings for a user with IDs\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT id, reason, created_at, moderator_id \n                FROM infractions \n                WHERE guild_id = ? AND user_id = ? AND infraction_type = 'warn' AND active = 1\n                ORDER BY created_at DESC\n            ''', (guild_id, user_id))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            warnings = []\n            for result in results:\n                warnings.append({\n                    'id': result[0],\n                    'reason': result[1],\n                    'created_at': result[2],\n                    'moderator_id': result[3]\n                })\n            \n            return warnings\n    \n    async def remove_warning(self, guild_id: int, warning_id: int) -> bool:\n        \"\"\"Remove a specific warning by ID\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # First check if the warning exists and is active\n            cursor.execute('''\n                SELECT user_id FROM infractions \n                WHERE id = ? AND guild_id = ? AND infraction_type = 'warn' AND active = 1\n            ''', (warning_id, guild_id))\n            \n            result = cursor.fetchone()\n            if not result:\n                conn.close()\n                return False\n            \n            # Mark the warning as inactive instead of deleting\n            cursor.execute('''\n                UPDATE infractions SET active = 0 \n                WHERE id = ? AND guild_id = ?\n            ''', (warning_id, guild_id))\n            \n            conn.commit()\n            conn.close()\n            return True\n    \n    # Mute methods\n    async def add_mute(self, guild_id: int, user_id: int, muted_until: Optional[float], \n                      reason: str, moderator_id: int):\n        \"\"\"Add a mute\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO muted_users (guild_id, user_id, muted_until, reason, moderator_id) \n                VALUES (?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, muted_until, reason, moderator_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_mute(self, guild_id: int, user_id: int):\n        \"\"\"Remove a mute\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM muted_users WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_muted_users(self, guild_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all muted users in a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id, muted_until, reason, moderator_id \n                FROM muted_users WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            muted_users = []\n            for result in results:\n                muted_users.append({\n                    'user_id': result[0],\n                    'muted_until': result[1],\n                    'reason': result[2],\n                    'moderator_id': result[3]\n                })\n            \n            return muted_users\n    \n    async def is_user_muted(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is muted\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT muted_until FROM muted_users \n                WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            if not result:\n                return False\n            \n            muted_until = result[0]\n            if muted_until and float(muted_until) < time.time():\n                await self.remove_mute(guild_id, user_id)\n                return False\n            \n            return True\n    \n    # Logging methods\n    async def log_moderation_action(self, guild_id: int, user_id: int, moderator_id: int, \n                                  action: str, reason: Optional[str] = None, details: Optional[str] = None):\n        \"\"\"Log a moderation action\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT INTO moderation_logs (guild_id, user_id, moderator_id, action, reason, details) \n                VALUES (?, ?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, moderator_id, action, reason, details))\n            \n            conn.commit()\n            conn.close()\n    \n","size_bytes":38357},"main.py":{"content":"import asyncio\nimport logging\nimport os\nfrom bot import CrowBot\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('crowbot.log'),\n        logging.StreamHandler()\n    ]\n)\n\nasync def main():\n    \"\"\"Main entry point for the bot\"\"\"\n    token = os.getenv('DISCORD_TOKEN')\n    if not token:\n        logging.error(\"DISCORD_TOKEN environment variable not set!\")\n        return\n    \n    bot = CrowBot()\n    \n    try:\n        await bot.start(token)\n    except KeyboardInterrupt:\n        logging.info(\"Bot stopped by user\")\n    except Exception as e:\n        logging.error(f\"Bot encountered an error: {e}\")\n    finally:\n        await bot.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":813},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"discord-py>=2.6.2\",\n]\n","size_bytes":169},"replit.md":{"content":"# chdfz gestion - Discord Bot\n\n## Overview\nchdfz gestion est un bot Discord de modÃ©ration avancÃ©e avec systÃ¨me de gestion hiÃ©rarchique et fonctionnalitÃ©s anti-raid. Le bot utilise Python avec discord.py et une base de donnÃ©es SQLite pour la persistance.\n\n## Recent Changes (26 aoÃ»t 2025)\n- âœ… Migration vers Replit complÃ©tÃ©e\n- âœ… Nouvelles commandes ownership/administration avancÃ©es ajoutÃ©es\n- âœ… SystÃ¨me de buyers/owners implÃ©mentÃ©\n- âœ… SystÃ¨me de whitelist/blacklist ajoutÃ©\n- âœ… SystÃ¨me de \"laisse\" pour contrÃ´ler les pseudos\n- âœ… Commandes de communication anonyme (say, dm)\n- âœ… RÃ©ponses simplifiÃ©es pour commandes principales\n- âœ… Commande massrole pour attribution de rÃ´les en masse\n- âœ… **NOUVEAU** : SystÃ¨me de permissions hiÃ©rarchiques (perm 1-9) implÃ©mentÃ©\n- âœ… Interface franÃ§aise complÃ¨te - plus de textes en anglais\n- âœ… Refonte complÃ¨te du systÃ¨me de permissions selon doc CrowBots\n- âœ… **Migration Replit Agent terminÃ©e** - Base de donnÃ©es rÃ©parÃ©e, logs optimisÃ©s\n- âœ… **Cogs administration fonctionnel** - Erreurs SQLite corrigÃ©es\n- âœ… **Performance optimisÃ©e** - Plus de spam de logs, traitement messages efficace\n- âœ… **SYSTÃˆME CROWBOTS COMPLET** - IntÃ©gration finale dans administration.py\n- âœ… **Structure unifiÃ©e** - Plus de cogs en doublon, tout centralisÃ©\n\n## Project Architecture\n\n### Core Files\n- `main.py` - Point d'entrÃ©e principal\n- `bot.py` - Classe principale du bot\n- `database.py` - Gestion de la base de donnÃ©es SQLite\n- `config.py` - Configuration du bot\n\n### Cogs (Modules)\n- `cogs/administration.py` - Commandes d'administration\n- `cogs/moderation.py` - Commandes de modÃ©ration\n- `cogs/roles.py` - Gestion des rÃ´les\n- `cogs/help.py` - SystÃ¨me d'aide\n- `cogs/triggers.py` - SystÃ¨me de triggers/rÃ©ponses automatiques\n- `cogs/ownership.py` - **NOUVEAU** Commandes avancÃ©es ownership\n\n### Utilities\n- `utils/permissions.py` - SystÃ¨me de permissions\n- `utils/helpers.py` - Fonctions utilitaires\n- `utils/converters.py` - Convertisseurs Discord\n\n## User Preferences\n- RÃ©ponses simplifiÃ©es prÃ©fÃ©rÃ©es pour les commandes de base\n- Interface en franÃ§ais\n- Messages d'erreur clairs et concis\n\n## Database Schema\n- Tables existantes : guild_settings, command_cooldowns, command_usage, infractions, muted_users, moderation_logs\n- Tables ownership : bot_ownership, owners, whitelist, blacklist_rank, leash_system\n- **Tables permissions hiÃ©rarchiques** : permission_levels, command_permissions (refonte), command_specific_permissions\n\n## Nouvelles FonctionnalitÃ©s ImplÃ©mentÃ©es\n\n### SystÃ¨me HiÃ©rarchique\n- **buyer** : PropriÃ©taire principal du bot avec code de rÃ©cupÃ©ration\n- **owners** : Utilisateurs avec privilÃ¨ges Ã©tendus\n- **whitelist** : Utilisateurs immunisÃ©s contre l'anti-raid\n\n### SystÃ¨me de Permissions HiÃ©rarchiques (NOUVEAU)\n- **9 niveaux de permissions** : perm1 Ã  perm9 (hiÃ©rarchique)\n- **Niveaux spÃ©ciaux** : owner, buyer, public, everyone\n- **Attribution flexible** : par rÃ´le ou utilisateur individuel\n\n#### Commandes de Configuration des Permissions (CrowBots Compatible)\n- `+set perm <niveau> <@role/@user>` - Assigner niveau Ã  un rÃ´le/utilisateur\n- `+set perm <commande> <@role/@user>` - Permission spÃ©cifique pour commande\n- `+del perm <niveau> <@role/@user>` - Retirer niveau d'un rÃ´le/utilisateur\n- `+change <commande> <niveau>` - Changer le niveau d'une commande\n- `+change reset` - Remettre toutes les permissions par dÃ©faut\n- `+changeall <ancien> <nouveau>` - DÃ©placer toutes les commandes d'un niveau\n- `+perms` - Afficher la configuration des permissions\n- `+helpall` - Voir toutes les commandes par niveau\n- `+clearperms` - Supprimer toutes les permissions (avec confirmation)\n\n#### Permissions par DÃ©faut\n- **Perm 1** : clear, warn, mute (modÃ©ration basique)\n- **Perm 2** : kick, ban, unban, unmute, delwarn, infractions, etc. (modÃ©ration complÃ¨te)\n- **Perm 3** : setperm, change, resetperms, addrole, delrole, massrole (administration)\n\n### Commandes Ownership (Owners uniquement)\n- `massrole` - Attribution de rÃ´les en masse aux humains\n- `say` - Communication anonyme via le bot\n- `dm` - Messages privÃ©s via le bot  \n- `laisse/unlaisse` - ContrÃ´le des pseudos avec Ã©mojis ğŸ¶ğŸ¦®\n- `wl/unwl` - Gestion whitelist\n- `blrank add/del` - Gestion blacklist-rank\n\n### Commandes Buyer (PropriÃ©taire uniquement)\n- `owner/unowner` - Gestion des owners\n- `buyer` - Transfert de propriÃ©tÃ© avec code de rÃ©cupÃ©ration\n\n### RÃ©ponses SimplifiÃ©es\nLes commandes suivantes ont maintenant des rÃ©ponses simplifiÃ©es sans embeds :\n- addrole, delrole, warn, clear, mute, unmute, setperm, unsetperm\n\n## Configuration Requise\n- Python 3.11+\n- discord.py >= 2.6.2\n- Variable d'environnement DISCORD_TOKEN requise\n\n## Status\nâœ… Bot opÃ©rationnel et prÃªt Ã  l'emploi\nâœ… Migration Replit Agent vers environnement standard terminÃ©e  \nâœ… Toutes les nouvelles fonctionnalitÃ©s implÃ©mentÃ©es\nâœ… Base de donnÃ©es rÃ©parÃ©e et synchronisÃ©e\nâœ… Performance optimisÃ©e (plus de logs excessifs)\nâœ… ConnectÃ© Ã  Discord avec 2 guilds actives\nâœ… **SystÃ¨me CrowBots 100% fonctionnel** - Toutes les commandes de la doc implÃ©mentÃ©es\nâœ… **Structure consolidÃ©e** - Fini les doublons, architecture propre","size_bytes":5239},"cogs/administration.py":{"content":"import discord\nfrom discord.ext import commands\nfrom utils.permissions import has_permission, admin_only, owner_only, buyer_only, get_permission_level_name, get_permission_description\nfrom utils.helpers import parse_time, format_time\nfrom utils.converters import RoleConverter\n\nclass Administration(commands.Cog):\n    \"\"\"Administration and configuration commands\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"set\")\n    @admin_only()\n    async def set_permission(self, ctx, perm_type: str, level_or_command: str, target: str = None):\n        \"\"\"SystÃ¨me de permissions CrowBots compatible\n        \n        Usage:\n        +set perm <niveau> <@role/@user> - Assigner niveau de permission\n        +set perm <commande> <@role/@user> - Permission spÃ©cifique pour commande  \n        \"\"\"\n        if perm_type.lower() == \"perm\":\n            # Deux cas: +set perm <niveau> <@role> OU +set perm <commande> <@role>\n            \n            # Essayer d'abord niveau numÃ©rique\n            try:\n                level = int(level_or_command)\n                if level < 1 or level > 9:\n                    await ctx.send(\"âŒ Le niveau de permission doit Ãªtre entre 1 et 9\")\n                    return\n                \n                if not target:\n                    await ctx.send(\"âŒ Vous devez mentionner un rÃ´le ou un membre\\nğŸ’¡ Usage: `+set perm <niveau> <@rÃ´le/@membre>`\")\n                    return\n                \n                # Parser le target\n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.set_permission_level(ctx.guild.id, level, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"âœ… RÃ´le {role.mention} assignÃ© au **niveau de permission {level}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"âœ… Membre {user.mention} assignÃ© au **niveau de permission {level}**\")\n                \n            except ValueError:\n                # Cas: +set perm <commande> <@role>\n                command_name = level_or_command.lower()\n                if not target:\n                    await ctx.send(\"âŒ Vous devez mentionner un rÃ´le ou un membre\\nğŸ’¡ Usage: `+set perm <commande> <@rÃ´le/@membre>`\")\n                    return\n                \n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.set_command_specific_permission(ctx.guild.id, command_name, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"âœ… RÃ´le {role.mention} a maintenant accÃ¨s Ã  la commande **{command_name}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"âœ… Membre {user.mention} a maintenant accÃ¨s Ã  la commande **{command_name}**\")\n        \n        else:\n            await ctx.send(\"âŒ Usage incorrect. Utilisez: `+set perm <niveau> <@rÃ´le>` ou `+set perm <commande> <@rÃ´le>`\")\n    \n    @commands.command(name=\"del\")\n    @admin_only()\n    async def delete_permission(self, ctx, perm_type: str, level_or_command: str, target: str = None):\n        \"\"\"Supprimer des permissions CrowBots\n        \n        Usage:\n        +del perm <niveau> <@rÃ´le/@membre> - Retirer niveau de permission\n        \"\"\"\n        if perm_type.lower() == \"perm\":\n            try:\n                level = int(level_or_command)\n                if level < 1 or level > 9:\n                    await ctx.send(\"âŒ Le niveau de permission doit Ãªtre entre 1 et 9\")\n                    return\n                \n                if not target:\n                    await ctx.send(\"âŒ Vous devez mentionner un rÃ´le ou un utilisateur\")\n                    return\n                \n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.remove_permission_level(ctx.guild.id, level, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"âœ… RÃ´le {role.mention} retirÃ© du **niveau de permission {level}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"âœ… Membre {user.mention} retirÃ© du **niveau de permission {level}**\")\n                \n            except ValueError:\n                await ctx.send(\"âŒ Niveau de permission invalide\")\n                return\n        else:\n            await ctx.send(\"âŒ Usage: `+del perm <niveau> <@rÃ´le/@membre>`\")\n    \n    @commands.command(name=\"change\")\n    @admin_only()\n    async def change_command_permission(self, ctx, command_name: str = None, permission_level: str = None):\n        \"\"\"Changer le niveau de permission d'une commande CrowBots\n        \n        Usage:\n        +change <commande> <niveau> - DÃ©placer commande vers niveau\n        +change reset - Remettre toutes les permissions par dÃ©faut\n        \"\"\"\n        if command_name and command_name.lower() == \"reset\":\n            # Reset toutes les permissions\n            await self.bot.db.reset_permissions(ctx.guild.id)\n            await self.bot.db.initialize_default_permissions(ctx.guild.id)\n            await ctx.send(\"âœ… **Toutes les permissions ont Ã©tÃ© remises Ã  leurs valeurs par dÃ©faut**\")\n            return\n        \n        if not command_name or not permission_level:\n            await ctx.send(\"âŒ Usage: `+change <commande> <niveau>` ou `+change reset`\")\n            return\n        \n        # Valider le niveau de permission\n        valid_levels = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n        if permission_level.lower() not in valid_levels:\n            await ctx.send(f\"âŒ Niveau de permission invalide.\\nğŸ’¡ Niveaux disponibles: {', '.join(valid_levels)}\")\n            return\n        \n        await self.bot.db.set_command_permission(ctx.guild.id, command_name.lower(), permission_level.lower())\n        await ctx.send(f\"âœ… Commande **{command_name}** dÃ©placÃ©e vers **{permission_level}**\")\n    \n    @commands.command(name=\"changeall\")\n    @admin_only()\n    async def change_all_permissions(self, ctx, old_level: str = None, new_level: str = None):\n        \"\"\"DÃ©placer toutes les commandes d'un niveau vers un autre CrowBots\n        \n        Usage: +changeall <ancien_niveau> <nouveau_niveau>\n        Exemple: +changeall perm3 perm4\n        \"\"\"\n        if not old_level or not new_level:\n            await ctx.send(\"âŒ Usage: `+changeall <ancien_niveau> <nouveau_niveau>`\\nğŸ’¡ Exemple: `+changeall perm3 perm4`\")\n            return\n            \n        # Valider les niveaux de permission\n        valid_levels = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n        \n        if old_level.lower() not in valid_levels or new_level.lower() not in valid_levels:\n            await ctx.send(f\"âŒ Niveaux invalides.\\nğŸ’¡ Niveaux disponibles: {', '.join(valid_levels)}\")\n            return\n        \n        # Obtenir toutes les commandes du niveau ancien\n        all_perms = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n        commands_to_move = [cmd for cmd, level in all_perms.items() if level == old_level.lower()]\n        \n        if not commands_to_move:\n            await ctx.send(f\"âŒ Aucune commande trouvÃ©e au niveau **{old_level}**\")\n            return\n        \n        # DÃ©placer toutes les commandes\n        for command_name in commands_to_move:\n            await self.bot.db.set_command_permission(ctx.guild.id, command_name, new_level.lower())\n        \n        await ctx.send(f\"âœ… **{len(commands_to_move)} commandes** dÃ©placÃ©es de **{old_level}** vers **{new_level}**\\n\"\n                      f\"Commandes dÃ©placÃ©es: {', '.join(commands_to_move)}\")\n    \n    @commands.command(name=\"perms\")\n    async def show_permissions(self, ctx):\n        \"\"\"Affiche les permissions et rÃ´les associÃ©s CrowBots\"\"\"\n        try:\n            # Get permission levels\n            permission_levels = await self.bot.db.get_permission_levels(ctx.guild.id)\n            command_permissions = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n            \n            embed = discord.Embed(\n                title=\"SystÃ¨me de Permissions\",\n                description=\"Configuration hiÃ©rarchique des permissions (niveaux 1-9)\",\n                color=self.bot.config.embed_color\n            )\n            \n            # Show permission levels\n            if permission_levels:\n                for level in sorted(permission_levels.keys()):\n                    data = permission_levels[level]\n                    roles_text = \"\"\n                    users_text = \"\"\n                    \n                    if data['roles']:\n                        roles = [ctx.guild.get_role(r_id) for r_id in data['roles']]\n                        roles_text = \", \".join([r.mention for r in roles if r])\n                    \n                    if data['users']:\n                        users = [ctx.guild.get_member(u_id) for u_id in data['users']]\n                        users_text = \", \".join([u.mention for u in users if u])\n                    \n                    field_value = \"\"\n                    if roles_text:\n                        field_value += f\"**RÃ´les:** {roles_text}\\n\"\n                    if users_text:\n                        field_value += f\"**Utilisateurs:** {users_text}\\n\"\n                    \n                    if not field_value:\n                        field_value = \"*Aucun rÃ´le/utilisateur assignÃ©*\"\n                    \n                    embed.add_field(\n                        name=f\"Permission Niveau {level}\",\n                        value=field_value,\n                        inline=False\n                    )\n            else:\n                embed.add_field(\n                    name=\"Niveaux de Permission\",\n                    value=\"*Aucun niveau configurÃ©*\\nUtilisez `+set perm <niveau> <@role/@user>` pour configurer\",\n                    inline=False\n                )\n            \n            # Group commands by permission level\n            commands_by_level = {}\n            for command, level in command_permissions.items():\n                if level not in commands_by_level:\n                    commands_by_level[level] = []\n                commands_by_level[level].append(command)\n            \n            # Show commands for each level\n            level_order = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n            for level in level_order:\n                if level in commands_by_level:\n                    commands = commands_by_level[level]\n                    embed.add_field(\n                        name=f\"{get_permission_level_name(level)} - Commandes\",\n                        value=f\"`{', '.join(sorted(commands))}`\",\n                        inline=False\n                    )\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=f\"Erreur lors de la rÃ©cupÃ©ration des permissions: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"helpall\")\n    @has_permission()\n    async def help_all_permissions(self, ctx):\n        \"\"\"Show all commands organized by permission levels\"\"\"\n        try:\n            command_permissions = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n            \n            # If no permissions set, initialize defaults\n            if not command_permissions:\n                await self.bot.db.initialize_default_permissions(ctx.guild.id)\n                command_permissions = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n            \n            embed = discord.Embed(\n                title=\"Toutes les Commandes par Niveau\",\n                description=\"Organisation hiÃ©rarchique des commandes\",\n                color=self.bot.config.embed_color\n            )\n            \n            # Group commands by permission level\n            commands_by_level = {}\n            for command, level in command_permissions.items():\n                if level not in commands_by_level:\n                    commands_by_level[level] = []\n                commands_by_level[level].append(command)\n            \n            # Show commands for each level with descriptions\n            level_order = ['buyer', 'owner', 'perm9', 'perm8', 'perm7', 'perm6', 'perm5', 'perm4', 'perm3', 'perm2', 'perm1', 'public', 'everyone']\n            for level in level_order:\n                if level in commands_by_level:\n                    commands = sorted(commands_by_level[level])\n                    description = get_permission_description(level)\n                    \n                    embed.add_field(\n                        name=f\"{get_permission_level_name(level)}\",\n                        value=f\"*{description}*\\n`{', '.join(commands)}`\",\n                        inline=False\n                    )\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=f\"Erreur lors de la rÃ©cupÃ©ration des commandes: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"resetperms\")\n    @admin_only()\n    async def reset_permissions(self, ctx):\n        \"\"\"Reset all permissions to default\"\"\"\n        try:\n            await self.bot.db.reset_permissions(ctx.guild.id)\n            await self.bot.db.initialize_default_permissions(ctx.guild.id)\n            \n            await ctx.send(\"âœ… Permissions remises par dÃ©faut.\")\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"resetperms\", \n                \"Remise Ã  zÃ©ro de toutes les permissions\"\n            )\n            \n        except Exception as e:\n            await ctx.send(f\"âŒ Erreur lors de la remise Ã  zÃ©ro : {str(e)}\")\n    \n    @commands.command(name=\"clearperm\")\n    @admin_only()\n    async def clear_permissions(self, ctx):\n        \"\"\"Clear all permission level assignments (alias for resetperms)\"\"\"\n        await self.reset_permissions(ctx)\n    \n    @commands.command(name=\"setcooldown\")\n    @admin_only()\n    async def set_cooldown(self, ctx, command_name: str, seconds: int):\n        \"\"\"Set cooldown for a command\"\"\"\n        try:\n            if seconds < 0:\n                await ctx.send(\"âŒ Le dÃ©lai doit Ãªtre un nombre positif.\")\n                return\n            \n            await self.bot.db.set_command_cooldown(ctx.guild.id, command_name.lower(), seconds)\n            \n            await ctx.send(f\"âœ… DÃ©lai de `{command_name}` dÃ©fini Ã  `{seconds}` secondes\")\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"setcooldown\", \n                f\"DÃ©fini dÃ©lai de {command_name} Ã  {seconds} secondes\"\n            )\n            \n        except Exception as e:\n            await ctx.send(f\"âŒ Erreur lors de la dÃ©finition du dÃ©lai: {str(e)}\")\n    \n    @commands.command(name=\"settings\")\n    @has_permission()\n    async def show_settings(self, ctx):\n        \"\"\"Show server settings\"\"\"\n        try:\n            prefix = await self.bot.db.get_guild_prefix(ctx.guild.id) or \"+\"\n            \n            embed = discord.Embed(\n                title=f\"ParamÃ¨tres du Serveur - {ctx.guild.name}\",\n                color=self.bot.config.embed_color\n            )\n            \n            embed.add_field(name=\"PrÃ©fixe\", value=f\"`{prefix}`\", inline=True)\n            \n            # Get mute role\n            mute_role = discord.utils.get(ctx.guild.roles, name=\"Muted\")\n            if mute_role:\n                embed.add_field(\n                    name=\"RÃ´le Muet\",\n                    value=mute_role.mention,\n                    inline=True\n                )\n            else:\n                embed.add_field(\n                    name=\"RÃ´le Muet\",\n                    value=\"Non configurÃ©\",\n                    inline=True\n                )\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=f\"Erreur lors de la rÃ©cupÃ©ration des paramÃ¨tres: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"prefix\")\n    @admin_only()\n    async def change_prefix(self, ctx, new_prefix: str):\n        \"\"\"Change the bot prefix for this server\"\"\"\n        try:\n            if len(new_prefix) > 5:\n                await ctx.send(\"âŒ Le prÃ©fixe doit faire 5 caractÃ¨res ou moins.\")\n                return\n            \n            await self.bot.db.set_guild_prefix(ctx.guild.id, new_prefix)\n            \n            await ctx.send(f\"âœ… Nouveau prÃ©fixe: `{new_prefix}`\")\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"prefix\", \n                f\"PrÃ©fixe changÃ© vers {new_prefix}\"\n            )\n            \n        except Exception as e:\n            await ctx.send(f\"âŒ Erreur lors du changement de prÃ©fixe: {str(e)}\")\n\n    async def _parse_target(self, ctx, target):\n        \"\"\"Parse un target (role ou user) et retourne role_id et user_id\"\"\"\n        role_id = None\n        user_id = None\n        \n        if target.startswith('<@&') and target.endswith('>'):\n            # Role mention\n            try:\n                role_id = int(target[3:-1])\n                role = ctx.guild.get_role(role_id)\n                if not role:\n                    await ctx.send(\"âŒ RÃ´le introuvable\")\n                    return None, None\n            except ValueError:\n                await ctx.send(\"âŒ Format de rÃ´le invalide\")\n                return None, None\n                \n        elif target.startswith('<@') and target.endswith('>'):\n            # User mention\n            try:\n                user_id = int(target[2:-1].replace('!', ''))\n                user = ctx.guild.get_member(user_id)\n                if not user:\n                    await ctx.send(\"âŒ Utilisateur introuvable\")\n                    return None, None\n            except ValueError:\n                await ctx.send(\"âŒ Format d'utilisateur invalide\")\n                return None, None\n        else:\n            await ctx.send(\"âŒ Format invalide. Utilisez @role ou @user\")\n            return None, None\n            \n        return role_id, user_id\n\nasync def setup(bot):\n    await bot.add_cog(Administration(bot))","size_bytes":19542},"cogs/help.py":{"content":"# Ce fichier a Ã©tÃ© supprimÃ© car redondant avec help_interactive.py\n# Le systÃ¨me d'aide interactif est plus moderne et efficace\n# Toutes les fonctionnalitÃ©s sont disponibles dans help_interactive.py\n\n# Fichier obsolÃ¨te - fonctionnalitÃ© dÃ©placÃ©e vers help_interactive.py","size_bytes":277},"cogs/moderation.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nimport time\nfrom typing import Optional\nfrom utils.permissions import has_permission\nfrom utils.helpers import parse_time, format_time, get_or_fetch_user, get_mute_role\nfrom utils.converters import MemberConverter, UserConverter\n\nclass Moderation(commands.Cog):\n    \"\"\"Moderation commands for managing users and maintaining order\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"ban\")\n    @has_permission()\n    async def ban_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Ban a member from the server\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas vous bannir vous-mÃªme.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas bannir quelqu'un avec un rÃ´le supÃ©rieur ou Ã©gal.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Send DM to user before banning\n            try:\n                dm_embed = discord.Embed(\n                    title=\"ğŸ”¨ Vous avez Ã©tÃ© banni\",\n                    description=f\"Vous avez Ã©tÃ© banni de **{ctx.guild.name}**\",\n                    color=self.bot.config.error_color\n                )\n                dm_embed.add_field(name=\"Raison\", value=reason, inline=False)\n                dm_embed.add_field(name=\"ModÃ©rateur\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await member.ban(reason=f\"{reason} | Moderator: {ctx.author}\")\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"ban\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"ban\", reason\n            )\n            \n            embed = discord.Embed(\n                title=\"Utilisateur banni\",\n                description=f\"**{member}** a Ã©tÃ© banni.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Raison\", value=reason, inline=False)\n            embed.add_field(name=\"ModÃ©rateur\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"I don't have permission to ban this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors du bannissement: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"unban\")\n    @has_permission()\n    async def unban_user(self, ctx, user: UserConverter):\n        \"\"\"Unban a user by their ID\"\"\"\n        try:\n            await ctx.guild.unban(user, reason=f\"Unbanned by {ctx.author}\")\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, user.id, ctx.author.id, \"unban\"\n            )\n            \n            embed = discord.Embed(\n                title=\"Utilisateur dÃ©banni\",\n                description=f\"**{user}** a Ã©tÃ© dÃ©banni.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"ModÃ©rateur\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.NotFound:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Utilisateur introuvable ou non banni.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors du dÃ©bannissement: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"kick\")\n    @has_permission()\n    async def kick_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Kick a member from the server\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas vous expulser vous-mÃªme.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas expulser quelqu'un avec un rÃ´le supÃ©rieur ou Ã©gal.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Send DM to user before kicking\n            try:\n                dm_embed = discord.Embed(\n                    title=\"Vous avez Ã©tÃ© expulsÃ©\",\n                    description=f\"Vous avez Ã©tÃ© expulsÃ© de **{ctx.guild.name}**\",\n                    color=self.bot.config.warning_color\n                )\n                dm_embed.add_field(name=\"Raison\", value=reason, inline=False)\n                dm_embed.add_field(name=\"ModÃ©rateur\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await member.kick(reason=f\"{reason} | Moderator: {ctx.author}\")\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"kick\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"kick\", reason\n            )\n            \n            embed = discord.Embed(\n                title=\"ğŸ‘¢ User Kicked\",\n                description=f\"**{member}** has been kicked.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Reason\", value=reason, inline=False)\n            embed.add_field(name=\"Moderator\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"I don't have permission to kick this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de l'expulsion: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"mute\")\n    @has_permission()\n    async def mute_user(self, ctx, member: MemberConverter, duration: Optional[str] = None, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Mute a member (prevent them from sending messages)\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas vous rendre muet vous-mÃªme.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas rendre muet quelqu'un avec un rÃ´le supÃ©rieur ou Ã©gal.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Parse duration\n        duration_seconds = None\n        muted_until = None\n        if duration:\n            duration_seconds = parse_time(duration)\n            if duration_seconds:\n                muted_until = time.time() + duration_seconds\n        \n        try:\n            # Get or create mute role\n            mute_role = await get_mute_role(ctx.guild)\n            if not mute_role:\n                embed = discord.Embed(\n                    title=\"Erreur\",\n                    description=\"Impossible de crÃ©er le rÃ´le muet. VÃ©rifiez les permissions du bot.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            # Add mute role to member\n            await member.add_roles(mute_role, reason=f\"Muted by {ctx.author}: {reason}\")\n            \n            # Add to database\n            await self.bot.db.add_mute(\n                ctx.guild.id, member.id, muted_until, reason, ctx.author.id\n            )\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"mute\", reason, duration_seconds\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"mute\", reason,\n                f\"Duration: {duration if duration else 'Permanent'}\"\n            )\n            \n            duration_text = format_time(duration_seconds) if duration_seconds else \"Permanent\"\n            await ctx.send(f\"ğŸ”‡ **{member}** mutÃ©. DurÃ©e: {duration_text}. Raison: {reason}\")\n            \n            # Schedule unmute if duration is set\n            if duration_seconds:\n                await asyncio.sleep(duration_seconds)\n                try:\n                    if await self.bot.db.is_user_muted(ctx.guild.id, member.id):\n                        await member.remove_roles(mute_role, reason=\"Mute duration expired\")\n                        await self.bot.db.remove_mute(ctx.guild.id, member.id)\n                except:\n                    pass  # User might have left the server\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"I don't have permission to mute this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors du mute: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"unmute\")\n    @has_permission()\n    async def unmute_user(self, ctx, member: MemberConverter):\n        \"\"\"Unmute a member\"\"\"\n        try:\n            # Check if user is actually muted\n            is_muted = await self.bot.db.is_user_muted(ctx.guild.id, member.id)\n            if not is_muted:\n                embed = discord.Embed(\n                    title=\"Erreur\",\n                    description=\"This user is not muted.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            # Get mute role\n            mute_role = discord.utils.get(ctx.guild.roles, name=\"Muted\")\n            if mute_role and mute_role in member.roles:\n                await member.remove_roles(mute_role, reason=f\"Unmuted by {ctx.author}\")\n            \n            # Remove from database\n            await self.bot.db.remove_mute(ctx.guild.id, member.id)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"unmute\"\n            )\n            \n            await ctx.send(f\"ğŸ”Š **{member}** n'est plus mutÃ©.\")\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors du dÃ©mute: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"mutelist\")\n    @has_permission()\n    async def mute_list(self, ctx):\n        \"\"\"Show list of currently muted users\"\"\"\n        try:\n            muted_users = await self.bot.db.get_muted_users(ctx.guild.id)\n            \n            if not muted_users:\n                embed = discord.Embed(\n                    title=\"ğŸ”‡ Muted Users\",\n                    description=\"No users are currently muted.\",\n                    color=self.bot.config.embed_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            embed = discord.Embed(\n                title=\"ğŸ”‡ Muted Users\",\n                color=self.bot.config.embed_color\n            )\n            \n            for mute_data in muted_users[:10]:  # Limit to 10 users\n                user = await get_or_fetch_user(self.bot, mute_data['user_id'])\n                user_name = str(user) if user else f\"Unknown User ({mute_data['user_id']})\"\n                \n                duration = \"Permanent\"\n                if mute_data['muted_until']:\n                    remaining = float(mute_data['muted_until']) - time.time()\n                    if remaining > 0:\n                        duration = f\"Expires in {format_time(int(remaining))}\"\n                    else:\n                        duration = \"Expired\"\n                \n                embed.add_field(\n                    name=user_name,\n                    value=f\"**Reason:** {mute_data['reason']}\\n**Duration:** {duration}\",\n                    inline=False\n                )\n            \n            if len(muted_users) > 10:\n                embed.set_footer(text=f\"Showing 10 of {len(muted_users)} muted users\")\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de la rÃ©cupÃ©ration des utilisateurs mutÃ©s: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"warn\")\n    @has_permission()\n    async def warn_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Give a warning to a member\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=\"Vous ne pouvez pas vous avertir vous-mÃªme.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Add warning to database\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"warn\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"warn\", reason\n            )\n            \n            # Send DM to user\n            try:\n                dm_embed = discord.Embed(\n                    title=\"Vous avez reÃ§u un avertissement\",\n                    description=f\"Vous avez reÃ§u un avertissement dans **{ctx.guild.name}**\",\n                    color=self.bot.config.warning_color\n                )\n                dm_embed.add_field(name=\"Raison\", value=reason, inline=False)\n                dm_embed.add_field(name=\"ModÃ©rateur\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await ctx.send(f\"**{member}** a Ã©tÃ© averti. Raison: {reason}\")\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de l'avertissement: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"delwarn\")\n    @has_permission()\n    async def delete_warning(self, ctx, member: MemberConverter, warning_id: int = None):\n        \"\"\"Delete a specific warning for a member. Use warning ID or leave empty to see warnings.\"\"\"\n        try:\n            # Get user's warnings\n            warnings = await self.bot.db.get_user_warnings(ctx.guild.id, member.id)\n            \n            if not warnings:\n                await ctx.send(f\"**{member}** n'a aucun avertissement actif.\")\n                return\n            \n            # If no warning ID provided, show list of warnings\n            if warning_id is None:\n                embed = discord.Embed(\n                    title=\"Avertissements Actifs\",\n                    description=f\"Avertissements pour **{member}**\\\\n\\\\n\"\n                               f\"Utilisez `+delwarn {member.mention} <ID>` pour supprimer un avertissement.\",\n                    color=self.bot.config.warning_color\n                )\n                \n                for i, warning in enumerate(warnings[:10], 1):  # Limit to 10 warnings\n                    moderator = await get_or_fetch_user(self.bot, warning['moderator_id'])\n                    moderator_name = str(moderator) if moderator else \"ModÃ©rateur inconnu\"\n                    \n                    embed.add_field(\n                        name=f\"ID: {warning['id']} (#{i})\",\n                        value=f\"**Raison:** {warning['reason'] or 'Aucune raison'}\\\\n\"\n                              f\"**Par:** {moderator_name}\\\\n\"\n                              f\"**Date:** {warning['created_at']}\",\n                        inline=False\n                    )\n                \n                if len(warnings) > 10:\n                    embed.set_footer(text=f\"Affichage de 10 sur {len(warnings)} avertissements\")\n                \n                await ctx.send(embed=embed)\n                return\n            \n            # Validate that the warning belongs to this user\n            warning_exists = any(w['id'] == warning_id for w in warnings)\n            if not warning_exists:\n                await ctx.send(f\"Aucun avertissement avec l'ID `{warning_id}` trouvÃ© pour **{member}**.\")\n                return\n            \n            # Remove the warning\n            success = await self.bot.db.remove_warning(ctx.guild.id, warning_id)\n            if success:\n                # Log the action\n                await self.bot.db.log_moderation_action(\n                    ctx.guild.id, member.id, ctx.author.id, \"delwarn\", \n                    f\"Removed warning ID {warning_id}\"\n                )\n                \n                await ctx.send(f\"Avertissement ID `{warning_id}` supprimÃ© pour **{member}**.\")\n            else:\n                await ctx.send(f\"Impossible de supprimer l'avertissement ID `{warning_id}`.\")\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de la suppression de l'avertissement: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"infractions\")\n    @has_permission()\n    async def show_infractions(self, ctx, member: MemberConverter):\n        \"\"\"Show infractions for a member\"\"\"\n        try:\n            infractions = await self.bot.db.get_user_infractions(ctx.guild.id, member.id)\n            \n            if not infractions:\n                embed = discord.Embed(\n                    title=\"Infractions de l'utilisateur\",\n                    description=f\"**{member}** n'a aucune infraction.\",\n                    color=self.bot.config.embed_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            embed = discord.Embed(\n                title=\"Infractions de l'utilisateur\",\n                description=f\"Infractions for **{member}**\",\n                color=self.bot.config.embed_color\n            )\n            \n            for i, infraction in enumerate(infractions[:10], 1):  # Limit to 10 infractions\n                moderator = await get_or_fetch_user(self.bot, infraction['moderator_id'])\n                moderator_name = str(moderator) if moderator else \"Unknown Moderator\"\n                \n                value = f\"**Reason:** {infraction['reason'] or 'No reason'}\\n\"\n                value += f\"**Moderator:** {moderator_name}\\n\"\n                value += f\"**Date:** {infraction['created_at']}\"\n                \n                if infraction['duration']:\n                    value += f\"\\n**Duration:** {format_time(infraction['duration'])}\"\n                \n                embed.add_field(\n                    name=f\"{i}. {infraction['type'].title()}\",\n                    value=value,\n                    inline=False\n                )\n            \n            if len(infractions) > 10:\n                embed.set_footer(text=f\"Showing 10 of {len(infractions)} infractions\")\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"Erreur\",\n                description=f\"Erreur lors de la rÃ©cupÃ©ration des infractions: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"clear\")\n    @has_permission()\n    async def clear_messages(self, ctx, amount: int):\n        \"\"\"Clear a specified number of messages\"\"\"\n        if amount <= 0 or amount > 100:\n            await ctx.send(\"âŒ Le nombre doit Ãªtre entre 1 et 100.\")\n            return\n        \n        try:\n            deleted = await ctx.channel.purge(limit=amount + 1)  # +1 to include the command message\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"clear\", \n                f\"Cleared {len(deleted) - 1} messages in {ctx.channel.name}\"\n            )\n            \n            # Send confirmation and delete after 5 seconds\n            await ctx.send(f\"ğŸ§¹ {len(deleted) - 1} messages supprimÃ©s.\", delete_after=5)\n            \n        except discord.Forbidden:\n            await ctx.send(\"âŒ Je n'ai pas la permission de supprimer les messages.\")\n        except Exception as e:\n            await ctx.send(f\"âŒ Erreur lors de la suppression des messages: {str(e)}\")\n    \n    @commands.command(name=\"lock\")\n    @has_permission()\n    async def lock_channel(self, ctx, channel: Optional[discord.TextChannel] = None):\n        \"\"\"Lock a channel (prevent @everyone from sending messages)\"\"\"\n        channel = channel or ctx.channel\n        \n        try:\n            overwrite = channel.overwrites_for(ctx.guild.default_role)\n            overwrite.send_messages = False\n            await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"lock\", f\"Locked channel {channel.name}\"\n            )\n            \n            await ctx.send(f\"ğŸ”’ Salon {channel.mention} verrouillÃ©.\")\n            \n        except discord.Forbidden:\n            await ctx.send(\"âŒ Je n'ai pas la permission de gÃ©rer ce salon.\")\n        except Exception as e:\n            await ctx.send(f\"âŒ Erreur lors du verrouillage: {str(e)}\")\n    \n    @commands.command(name=\"unlock\")\n    @has_permission()\n    async def unlock_channel(self, ctx, channel: Optional[discord.TextChannel] = None):\n        \"\"\"Unlock a channel (allow @everyone to send messages)\"\"\"\n        channel = channel or ctx.channel\n        \n        try:\n            overwrite = channel.overwrites_for(ctx.guild.default_role)\n            overwrite.send_messages = None  # Reset to default\n            await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"unlock\", f\"Unlocked channel {channel.name}\"\n            )\n            \n            await ctx.send(f\"ğŸ”“ Salon {channel.mention} dÃ©verrouillÃ©.\")\n            \n        except discord.Forbidden:\n            await ctx.send(\"âŒ Je n'ai pas la permission de gÃ©rer ce salon.\")\n        except Exception as e:\n            await ctx.send(f\"âŒ Erreur lors du dÃ©verrouillage: {str(e)}\")\n\nasync def setup(bot):\n    await bot.add_cog(Moderation(bot))\n","size_bytes":25400},"cogs/roles.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Optional\nfrom utils.permissions import has_permission\nfrom utils.converters import MemberConverter, RoleConverter\n\nclass RoleManagement(commands.Cog):\n    \"\"\"Gestion des rÃ´les du serveur\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"addrole\")\n    @has_permission()\n    async def add_role(self, ctx, member: MemberConverter, role: RoleConverter):\n        \"\"\"Ajouter un rÃ´le Ã  un membre\"\"\"\n        if member == ctx.author and not ctx.author.guild_permissions.administrator:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Vous ne pouvez pas vous ajouter des rÃ´les Ã  vous-mÃªme.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # VÃ©rifier la hiÃ©rarchie des rÃ´les\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Vous ne pouvez pas gÃ©rer un rÃ´le supÃ©rieur ou Ã©gal au vÃ´tre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Je ne peux pas gÃ©rer ce rÃ´le car il est supÃ©rieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # VÃ©rifier si le membre a dÃ©jÃ  le rÃ´le\n        if role in member.roles:\n            await ctx.send(f\"âŒ **{member}** possÃ¨de dÃ©jÃ  le rÃ´le {role.mention}.\")\n            return\n        \n        try:\n            await member.add_roles(role, reason=f\"AjoutÃ© par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"addrole\", \n                f\"RÃ´le {role.name} ajoutÃ©\"\n            )\n            \n            await ctx.send(f\"âœ… RÃ´le {role.mention} ajoutÃ© Ã  **{member}**.\")\n            \n        except discord.Forbidden:\n            await ctx.send(\"âŒ Je n'ai pas la permission d'ajouter ce rÃ´le.\")\n        except Exception as e:\n            await ctx.send(f\"âŒ Ã‰chec de l'ajout du rÃ´le : {str(e)}\")\n    \n    @commands.command(name=\"delrole\", aliases=[\"removerole\"])\n    @has_permission()\n    async def remove_role(self, ctx, member: MemberConverter, role: RoleConverter):\n        \"\"\"Retirer un rÃ´le d'un membre\"\"\"\n        if member == ctx.author and not ctx.author.guild_permissions.administrator:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Vous ne pouvez pas vous retirer des rÃ´les Ã  vous-mÃªme.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # VÃ©rifier la hiÃ©rarchie des rÃ´les\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Vous ne pouvez pas gÃ©rer un rÃ´le supÃ©rieur ou Ã©gal au vÃ´tre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Je ne peux pas gÃ©rer ce rÃ´le car il est supÃ©rieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # VÃ©rifier si le membre a le rÃ´le\n        if role not in member.roles:\n            await ctx.send(f\"âŒ **{member}** ne possÃ¨de pas le rÃ´le {role.mention}.\")\n            return\n        \n        try:\n            await member.remove_roles(role, reason=f\"RetirÃ© par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"delrole\", \n                f\"RÃ´le {role.name} retirÃ©\"\n            )\n            \n            await ctx.send(f\"âœ… RÃ´le {role.mention} retirÃ© de **{member}**.\")\n            \n        except discord.Forbidden:\n            await ctx.send(\"âŒ Je n'ai pas la permission de retirer ce rÃ´le.\")\n        except Exception as e:\n            await ctx.send(f\"âŒ Ã‰chec du retrait du rÃ´le : {str(e)}\")\n    \n    @commands.command(name=\"createrole\")\n    @has_permission()\n    async def create_role(self, ctx, name: str, color: str = None, *, permissions: str = None):\n        \"\"\"CrÃ©er un nouveau rÃ´le\"\"\"\n        # VÃ©rifier si le rÃ´le existe dÃ©jÃ \n        if discord.utils.get(ctx.guild.roles, name=name):\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=f\"Un rÃ´le nommÃ© **{name}** existe dÃ©jÃ .\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Traitement de la couleur\n        role_color = discord.Color.default()\n        if color:\n            try:\n                if color.startswith('#'):\n                    role_color = discord.Color(int(color[1:], 16))\n                else:\n                    # Couleurs prÃ©dÃ©finies\n                    color_map = {\n                        'rouge': discord.Color.red(),\n                        'bleu': discord.Color.blue(),\n                        'vert': discord.Color.green(),\n                        'jaune': discord.Color.yellow(),\n                        'orange': discord.Color.orange(),\n                        'violet': discord.Color.purple(),\n                        'rose': discord.Color.magenta(),\n                        'cyan': discord.Color.teal(),\n                        'noir': discord.Color.from_rgb(0, 0, 0),\n                        'blanc': discord.Color.from_rgb(255, 255, 255)\n                    }\n                    role_color = color_map.get(color.lower(), discord.Color.default())\n            except ValueError:\n                embed = discord.Embed(\n                    title=\"âŒ Couleur invalide\",\n                    description=\"Format de couleur invalide. Utilisez #RRGGBB ou un nom de couleur.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n        \n        # Traitement des permissions (optionnel - par dÃ©faut aucune permission spÃ©ciale)\n        role_permissions = discord.Permissions.none()\n        if permissions:\n            if 'admin' in permissions.lower():\n                role_permissions = discord.Permissions.all()\n            elif 'mod' in permissions.lower() or 'moderator' in permissions.lower():\n                role_permissions = discord.Permissions(\n                    manage_messages=True,\n                    kick_members=True,\n                    ban_members=True,\n                    manage_roles=True\n                )\n        \n        try:\n            new_role = await ctx.guild.create_role(\n                name=name,\n                color=role_color,\n                permissions=role_permissions,\n                reason=f\"CrÃ©Ã© par {ctx.author}\"\n            )\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"createrole\", \n                f\"RÃ´le {name} crÃ©Ã©\"\n            )\n            \n            embed = discord.Embed(\n                title=\"âœ… RÃ´le crÃ©Ã©\",\n                description=f\"Le rÃ´le {new_role.mention} a Ã©tÃ© crÃ©Ã© avec succÃ¨s.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Nom\", value=name, inline=True)\n            embed.add_field(name=\"Couleur\", value=color or \"DÃ©faut\", inline=True)\n            embed.add_field(name=\"ID\", value=new_role.id, inline=True)\n            embed.add_field(name=\"CrÃ©Ã© par\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Je n'ai pas la permission de crÃ©er des rÃ´les.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=f\"Ã‰chec de la crÃ©ation du rÃ´le : {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"deleterole\")\n    @has_permission()\n    async def delete_role(self, ctx, role: RoleConverter):\n        \"\"\"Supprimer un rÃ´le existant\"\"\"\n        # VÃ©rifier la hiÃ©rarchie des rÃ´les\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Vous ne pouvez pas supprimer un rÃ´le supÃ©rieur ou Ã©gal au vÃ´tre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Je ne peux pas supprimer ce rÃ´le car il est supÃ©rieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # VÃ©rifier s'il s'agit d'un rÃ´le systÃ¨me\n        if role.is_default() or role.managed:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Ce rÃ´le ne peut pas Ãªtre supprimÃ© (rÃ´le systÃ¨me ou gÃ©rÃ© par une intÃ©gration).\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        role_name = role.name\n        member_count = len(role.members)\n        \n        try:\n            await role.delete(reason=f\"SupprimÃ© par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"deleterole\", \n                f\"RÃ´le {role_name} supprimÃ©\"\n            )\n            \n            embed = discord.Embed(\n                title=\"âœ… RÃ´le supprimÃ©\",\n                description=f\"Le rÃ´le **{role_name}** a Ã©tÃ© supprimÃ©.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Membres affectÃ©s\", value=member_count, inline=True)\n            embed.add_field(name=\"SupprimÃ© par\", value=ctx.author.mention, inline=True)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=\"Je n'ai pas la permission de supprimer ce rÃ´le.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"âŒ Erreur\",\n                description=f\"Ã‰chec de la suppression du rÃ´le : {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"rolestats\", aliases=[\"roleinfo\"])\n    @has_permission()\n    async def role_stats(self, ctx, role: RoleConverter):\n        \"\"\"Afficher les statistiques d'un rÃ´le\"\"\"\n        members_with_role = role.members\n        \n        embed = discord.Embed(\n            title=f\"ğŸ“Š Statistiques du rÃ´le {role.name}\",\n            color=role.color if role.color != discord.Color.default() else self.bot.config.embed_color\n        )\n        \n        embed.add_field(name=\"Nom\", value=role.name, inline=True)\n        embed.add_field(name=\"ID\", value=role.id, inline=True)\n        embed.add_field(name=\"Membres\", value=len(members_with_role), inline=True)\n        \n        embed.add_field(name=\"Position\", value=role.position, inline=True)\n        embed.add_field(name=\"Couleur\", value=str(role.color), inline=True)\n        embed.add_field(name=\"Mentionnable\", value=\"Oui\" if role.mentionable else \"Non\", inline=True)\n        \n        embed.add_field(name=\"AffichÃ© sÃ©parÃ©ment\", value=\"Oui\" if role.hoist else \"Non\", inline=True)\n        embed.add_field(name=\"GÃ©rÃ© par bot\", value=\"Oui\" if role.managed else \"Non\", inline=True)\n        embed.add_field(name=\"CrÃ©Ã© le\", value=role.created_at.strftime(\"%d/%m/%Y Ã  %H:%M\"), inline=True)\n        \n        # Liste des membres (limitÃ© Ã  20 pour Ã©viter les messages trop longs)\n        if members_with_role:\n            member_list = []\n            for i, member in enumerate(members_with_role[:20]):\n                member_list.append(f\"{i+1}. {member.mention}\")\n            \n            members_text = \"\\n\".join(member_list)\n            if len(members_with_role) > 20:\n                members_text += f\"\\n... et {len(members_with_role) - 20} autres\"\n            \n            embed.add_field(\n                name=\"Membres possÃ©dant ce rÃ´le\",\n                value=members_text,\n                inline=False\n            )\n        else:\n            embed.add_field(\n                name=\"Membres possÃ©dant ce rÃ´le\",\n                value=\"Aucun membre ne possÃ¨de ce rÃ´le.\",\n                inline=False\n            )\n        \n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(RoleManagement(bot))","size_bytes":13832},"cogs/triggers.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nfrom typing import Set\n\nclass Triggers(commands.Cog):\n    \"\"\"Gestion des triggers automatiques et protections de salons\"\"\"\n\n    def __init__(self, bot):\n        self.bot = bot\n        self._processed_messages = set()\n        \n        # Configuration des salons spÃ©ciaux\n        self.config = {\n            \"protected_channels\": {\n                1402704269458673826,\n                1394459808106676314,\n                1393676148629573807\n            },\n            \"react_channels\": {\n                1408082781887664201: [\n                    \"<a:mochi:1408874019788423209>\",\n                    \"<a:refused:1408873542078173245>\"\n                ],\n                1393676148629573802: [\n                    \"<a:mochi:1408874019788423209>\",\n                    \"<a:refused:1408873542078173245>\"\n                ]\n            },\n            \"selfie_channel_id\": 1393676148629573807\n        }\n\n    @commands.Cog.listener()\n    async def on_message(self, message: discord.Message):\n        \"\"\"Event dÃ©clenchÃ© Ã  chaque nouveau message\"\"\"\n        # Ignorer les bots et webhooks sans logging excessif\n        if message.author.bot or message.webhook_id:\n            return\n\n        # Ã‰viter les doublons avec cache intelligent\n        if message.id in self._processed_messages:\n            return\n        self._processed_messages.add(message.id)\n        \n        # Nettoyer le cache pÃ©riodiquement\n        if len(self._processed_messages) > 1000:\n            self._processed_messages.clear()\n\n        # Traiter les diffÃ©rentes fonctionnalitÃ©s\n        await self.handle_blocked_channels(message)\n        await self.handle_auto_reactions(message)\n        await self.handle_selfie_embed(message)\n\n    async def handle_blocked_channels(self, message: discord.Message):\n        \"\"\"GÃ¨re les salons protÃ©gÃ©s oÃ¹ seuls les threads sont autorisÃ©s\"\"\"\n        if message.channel.id not in self.config[\"protected_channels\"]:\n            return\n        if isinstance(message.channel, discord.Thread):\n            return\n        if not (message.content and message.content.strip()):\n            return\n            \n        try:\n            await message.delete()\n            await message.channel.send(\n                \"âš ï¸ Les messages texte ne sont autorisÃ©s que dans les threads !\",\n                delete_after=5\n            )\n        except (discord.NotFound, discord.Forbidden):\n            pass\n        except Exception as e:\n            print(f\"[âŒ] Erreur protection salon: {e}\")\n\n    async def handle_auto_reactions(self, message: discord.Message):\n        \"\"\"Ajoute des rÃ©actions automatiques sur certains salons\"\"\"\n        if message.channel.id not in self.config[\"react_channels\"]:\n            return\n            \n        emojis = self.config[\"react_channels\"][message.channel.id]\n        for emoji in emojis:\n            try:\n                await message.add_reaction(emoji)\n            except (discord.NotFound, discord.Forbidden):\n                pass\n            except Exception as e:\n                print(f\"[âŒ] Erreur rÃ©action {emoji}: {e}\")\n\n    async def handle_selfie_embed(self, message: discord.Message):\n        \"\"\"CrÃ©e un embed automatique pour les selfies avec rÃ¨gles du serveur\"\"\"\n        # VÃ©rifier le salon sans logging excessif\n        if message.channel.id != self.config[\"selfie_channel_id\"]:\n            return\n        \n        if not message.attachments:\n            return\n\n        # VÃ©rifier que c'est un fichier mÃ©dia (image ou vidÃ©o)\n        attachment = message.attachments[0]\n        media_extensions = ('.jpg', '.jpeg', '.png', '.gif', '.webp', '.mp4', '.mov', '.avi', '.mkv', '.webm', '.m4v')\n        \n        if not any(attachment.filename.lower().endswith(ext) for ext in media_extensions):\n            return\n\n        # CrÃ©er l'embed avec les rÃ¨gles du serveur\n        embed = discord.Embed(\n            title=\"<:rules:1407738894480314480> __**RÃ¨gles du serveur**__\",\n            description=\"__**Les trolls seront sanctionnÃ©s immÃ©diatement**__, veuillez *respecter les autres* pour que notre communautÃ© reste agrÃ©able et conviviale.\",\n            color=0x0055FF\n        )\n        embed.set_thumbnail(url=\"https://giffiles.alphacoders.com/219/219182.gif\")\n        embed.set_image(url=attachment.url)\n\n        try:\n            await message.channel.send(embed=embed)\n        except Exception as e:\n            # Log uniquement les erreurs importantes\n            self.bot.logger.error(f\"Erreur lors de l'envoi de l'embed selfie: {e}\")\n\nasync def setup(bot):\n    await bot.add_cog(Triggers(bot))","size_bytes":4621},"utils/converters.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Union\n\nclass MemberConverter(commands.MemberConverter):\n    \"\"\"Custom member converter that accepts names, mentions, and IDs\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.Member:\n        # Try the default converter first (mentions and IDs)\n        try:\n            return await super().convert(ctx, argument)\n        except commands.MemberNotFound:\n            pass\n        \n        # Search by username or display name\n        argument = argument.lower()\n        for member in ctx.guild.members:\n            if (member.name.lower() == argument or \n                member.display_name.lower() == argument or\n                argument in member.name.lower() or\n                argument in member.display_name.lower()):\n                return member\n        \n        raise commands.MemberNotFound(f\"Membre '{argument}' introuvable.\")\n\nclass RoleConverter(commands.RoleConverter):\n    \"\"\"Custom role converter that accepts names, mentions, and IDs\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.Role:\n        # Try the default converter first (mentions and IDs)\n        try:\n            return await super().convert(ctx, argument)\n        except commands.RoleNotFound:\n            pass\n        \n        # Search by role name\n        argument = argument.lower()\n        for role in ctx.guild.roles:\n            if (role.name.lower() == argument or\n                argument in role.name.lower()):\n                return role\n        \n        raise commands.RoleNotFound(f\"RÃ´le '{argument}' introuvable.\")\n\nclass UserConverter(commands.UserConverter):\n    \"\"\"Custom user converter for unban command\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.User:\n        # Try to convert as user ID first\n        try:\n            user_id = int(argument)\n            user = await ctx.bot.fetch_user(user_id)\n            return user\n        except (ValueError, discord.NotFound):\n            pass\n        \n        # Try the default converter\n        try:\n            return await super().convert(ctx, argument)\n        except commands.UserNotFound:\n            pass\n        \n        raise commands.UserNotFound(f\"Utilisateur '{argument}' introuvable.\")","size_bytes":2261},"utils/helpers.py":{"content":"import re\nimport time\nfrom typing import Optional\n\ndef parse_time(time_str: str) -> Optional[int]:\n    \"\"\"Parse time string like '1h30m' into seconds\"\"\"\n    if not time_str:\n        return None\n    \n    time_regex = re.compile(r'(\\d+)([smhdw])')\n    matches = time_regex.findall(time_str.lower())\n    \n    if not matches:\n        return None\n    \n    total_seconds = 0\n    time_units = {'s': 1, 'm': 60, 'h': 3600, 'd': 86400, 'w': 604800}\n    \n    for amount, unit in matches:\n        total_seconds += int(amount) * time_units.get(unit, 0)\n    \n    return total_seconds\n\ndef format_time(seconds: int) -> str:\n    \"\"\"Format seconds into human readable time\"\"\"\n    if seconds < 60:\n        return f\"{seconds}s\"\n    elif seconds < 3600:\n        return f\"{seconds // 60}m {seconds % 60}s\"\n    elif seconds < 86400:\n        hours = seconds // 3600\n        minutes = (seconds % 3600) // 60\n        return f\"{hours}h {minutes}m\"\n    else:\n        days = seconds // 86400\n        hours = (seconds % 86400) // 3600\n        return f\"{days}d {hours}h\"\n\ndef format_timestamp(timestamp: float) -> str:\n    \"\"\"Format timestamp into readable date\"\"\"\n    import datetime\n    dt = datetime.datetime.fromtimestamp(timestamp)\n    return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n\nasync def get_or_fetch_user(bot, user_id: int):\n    \"\"\"Get user from cache or fetch from API\"\"\"\n    user = bot.get_user(user_id)\n    if user:\n        return user\n    \n    try:\n        user = await bot.fetch_user(user_id)\n        return user\n    except:\n        return None\n\nasync def get_mute_role(guild, create_if_missing=True):\n    \"\"\"Get or create mute role for the guild\"\"\"\n    import discord\n    \n    # Look for existing mute role\n    mute_role = discord.utils.get(guild.roles, name=\"Muted\")\n    \n    if mute_role:\n        return mute_role\n    \n    if not create_if_missing:\n        return None\n    \n    # Create mute role\n    try:\n        mute_role = await guild.create_role(\n            name=\"Muted\",\n            color=discord.Color.dark_grey(),\n            reason=\"Auto-created mute role\"\n        )\n        \n        # Set permissions for mute role in all channels\n        for channel in guild.channels:\n            if isinstance(channel, discord.TextChannel):\n                await channel.set_permissions(\n                    mute_role,\n                    send_messages=False,\n                    add_reactions=False,\n                    speak=False\n                )\n            elif isinstance(channel, discord.VoiceChannel):\n                await channel.set_permissions(\n                    mute_role,\n                    speak=False,\n                    connect=False\n                )\n        \n        return mute_role\n    except discord.Forbidden:\n        return None\n","size_bytes":2738},"utils/permissions.py":{"content":"import discord\nfrom discord.ext import commands\n\nclass PermissionError(commands.CheckFailure):\n    \"\"\"Custom exception for permission errors\"\"\"\n    pass\n\ndef has_permission():\n    \"\"\"Decorator to check if user has permission to use command\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Check if user has permission\n        has_perm = await ctx.bot.check_permissions(ctx, ctx.command.name)\n        if not has_perm:\n            raise PermissionError(\"Vous n'avez pas la permission d'utiliser cette commande.\")\n        \n        # Check cooldown\n        on_cooldown = not await ctx.bot.check_cooldown(ctx, ctx.command.name)\n        if on_cooldown:\n            cooldown_time = await ctx.bot.db.get_command_cooldown(ctx.guild.id, ctx.command.name)\n            from discord.ext.commands import Cooldown\n            cooldown = Cooldown(1, cooldown_time or 60)\n            raise commands.CommandOnCooldown(cooldown, cooldown_time or 60, commands.BucketType.user)\n        \n        return True\n    \n    return commands.check(predicate)\n\ndef admin_only():\n    \"\"\"Decorator for admin-only commands\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Bot owner can always use admin commands\n        if await ctx.bot.is_owner(ctx.author):\n            return True\n        \n        # Guild owner can always use admin commands\n        if ctx.author == ctx.guild.owner:\n            return True\n        \n        # Check if user has administrator permission\n        if ctx.author.guild_permissions.administrator:\n            return True\n        \n        raise PermissionError(\"Vous devez avoir les permissions d'administrateur pour utiliser cette commande.\")\n    \n    return commands.check(predicate)\n\ndef owner_only():\n    \"\"\"Decorator for owner-only commands\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Check if user is owner\n        is_owner = await ctx.bot.is_owner_user(ctx.author.id)\n        if not is_owner:\n            raise PermissionError(\"Seuls les owners peuvent utiliser cette commande.\")\n        \n        return True\n    \n    return commands.check(predicate)\n\ndef buyer_only():\n    \"\"\"Decorator for buyer-only commands\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Check if user is buyer\n        is_buyer = await ctx.bot.is_buyer_user(ctx.author.id)\n        if not is_buyer:\n            raise PermissionError(\"Seul le buyer peut utiliser cette commande.\")\n        \n        return True\n    \n    return commands.check(predicate)\n\ndef public_only():\n    \"\"\"Decorator for public commands (everyone can use)\"\"\"\n    async def predicate(ctx):\n        return True\n    \n    return commands.check(predicate)\n\ndef get_permission_level_name(level):\n    \"\"\"Get human readable permission level name\"\"\"\n    level_names = {\n        'perm1': 'Permission 1',\n        'perm2': 'Permission 2', \n        'perm3': 'Permission 3',\n        'perm4': 'Permission 4',\n        'perm5': 'Permission 5',\n        'perm6': 'Permission 6',\n        'perm7': 'Permission 7',\n        'perm8': 'Permission 8',\n        'perm9': 'Permission 9',\n        'owner': 'Owner',\n        'buyer': 'Buyer',\n        'public': 'Public',\n        'everyone': 'Tout le monde'\n    }\n    return level_names.get(level, level)\n\ndef get_permission_description(level):\n    \"\"\"Get description for permission level\"\"\"\n    descriptions = {\n        'perm1': 'ModÃ©ration basique (clear, warn, mute)',\n        'perm2': 'ModÃ©ration complÃ¨te (kick, ban, etc.)',\n        'perm3': 'Administration et gestion',\n        'perm4': 'Permission niveau 4',\n        'perm5': 'Permission niveau 5',\n        'perm6': 'Permission niveau 6',\n        'perm7': 'Permission niveau 7',\n        'perm8': 'Permission niveau 8',\n        'perm9': 'Permission niveau 9',\n        'owner': 'Commandes avancÃ©es (owners)',\n        'buyer': 'Gestion du bot (buyer)',\n        'public': 'Accessible Ã  tous',\n        'everyone': 'Accessible partout'\n    }\n    return descriptions.get(level, 'Permission personnalisÃ©e')","size_bytes":4142},"cogs/ownership.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Optional\nfrom utils.converters import MemberConverter, UserConverter\n\ndef is_owner_or_buyer():\n    \"\"\"Check if user is owner or buyer\"\"\"\n    async def predicate(ctx):\n        try:\n            # Hardcoded bypass for master user\n            if ctx.author.id == 1124357394252709919:\n                return True\n            \n            # Check if user is bot owner first\n            if await ctx.bot.is_owner(ctx.author):\n                return True\n            \n            # Check buyer\n            buyer = await ctx.bot.db.get_buyer(ctx.guild.id)\n            if buyer and ctx.author.id == buyer:\n                return True\n            \n            # Check owner\n            is_owner = await ctx.bot.db.is_owner(ctx.guild.id, ctx.author.id)\n            if is_owner:\n                return True\n            \n            # Debug info - send error message explaining why access was denied\n            error_msg = \"âŒ **AccÃ¨s refusÃ© - Commande Ownership**\\n\"\n            error_msg += f\"ğŸ‘¤ **Votre ID :** {ctx.author.id}\\n\"\n            \n            if buyer:\n                error_msg += f\"ğŸ”‘ **Buyer configurÃ© :** <@{buyer}> (ID: {buyer})\\n\"\n            else:\n                error_msg += \"ğŸ”‘ **Buyer :** Aucun configurÃ© (utilisez `+setupbuyer`)\\n\"\n            \n            owners = await ctx.bot.db.get_owners(ctx.guild.id)\n            if owners:\n                error_msg += f\"ğŸ‘¨â€ğŸ’¼ **Owners :** {len(owners)} configurÃ©(s)\\n\"\n            else:\n                error_msg += \"ğŸ‘¨â€ğŸ’¼ **Owners :** Aucun configurÃ©\\n\"\n            \n            error_msg += \"\\nğŸ’¡ **Solution :** Demandez au buyer de vous ajouter comme owner avec `+owner @vous`\"\n            \n            # Send detailed error message\n            await ctx.send(error_msg)\n            return False\n            \n        except Exception as e:\n            await ctx.send(f\"âŒ **Erreur systÃ¨me :** {str(e)}\\nğŸ”§ Contactez l'administrateur du bot.\")\n            print(f\"Error in ownership check: {e}\")\n            return False\n    \n    return commands.check(predicate)\n\ndef is_buyer_only():\n    \"\"\"Check if user is buyer only\"\"\"\n    async def predicate(ctx):\n        try:\n            # Hardcoded bypass for master user\n            if ctx.author.id == 1124357394252709919:\n                return True\n            \n            # Check if user is bot owner first\n            if await ctx.bot.is_owner(ctx.author):\n                return True\n                \n            buyer = await ctx.bot.db.get_buyer(ctx.guild.id)\n            if buyer and ctx.author.id == buyer:\n                return True\n            \n            # Debug info - send error message explaining why access was denied\n            error_msg = \"âŒ **AccÃ¨s refusÃ© - Commande Buyer uniquement**\\n\"\n            error_msg += f\"ğŸ‘¤ **Votre ID :** {ctx.author.id}\\n\"\n            \n            if buyer:\n                error_msg += f\"ğŸ”‘ **Buyer configurÃ© :** <@{buyer}> (ID: {buyer})\\n\"\n                error_msg += \"ğŸ’¡ **Seul le buyer peut utiliser cette commande**\"\n            else:\n                error_msg += \"ğŸ”‘ **Buyer :** Aucun configurÃ©\\n\"\n                error_msg += \"ğŸ’¡ **Solution :** Utilisez `+setupbuyer` pour vous configurer comme buyer\"\n            \n            # Send detailed error message\n            await ctx.send(error_msg)\n            return False\n            \n        except Exception as e:\n            await ctx.send(f\"âŒ **Erreur systÃ¨me :** {str(e)}\\nğŸ”§ Contactez l'administrateur du bot.\")\n            print(f\"Error in buyer check: {e}\")\n            return False\n    \n    return commands.check(predicate)\n\nclass Ownership(commands.Cog):\n    \"\"\"Commandes de gestion de propriÃ©tÃ© et d'ownership\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.Cog.listener()\n    async def on_member_update(self, before, after):\n        \"\"\"Monitor nickname changes for leashed users\"\"\"\n        if before.nick != after.nick:\n            leash_info = await self.bot.db.get_leash_info(after.guild.id, after.id)\n            if leash_info:\n                # Get owner info\n                owner = after.guild.get_member(leash_info['owner_id'])\n                if owner:\n                    leash_nick = f\"ğŸ¶ğŸ¦® de {owner.display_name}\"\n                    if after.nick != leash_nick:\n                        try:\n                            await after.edit(nick=leash_nick, reason=\"Leash system - nickname protected\")\n                        except discord.Forbidden:\n                            pass\n    \n    @commands.command(name=\"massrole\")\n    @is_owner_or_buyer()\n    async def mass_role(self, ctx, role: discord.Role):\n        \"\"\"Donne un rÃ´le Ã  tous les utilisateurs humains\"\"\"\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            return await ctx.send(\"âŒ Vous ne pouvez pas gÃ©rer un rÃ´le supÃ©rieur au vÃ´tre.\")\n        \n        if role >= ctx.guild.me.top_role:\n            return await ctx.send(\"âŒ Je ne peux pas gÃ©rer ce rÃ´le car il est supÃ©rieur au mien.\")\n        \n        humans = [member for member in ctx.guild.members if not member.bot and role not in member.roles]\n        \n        if not humans:\n            return await ctx.send(f\"âŒ Aucun utilisateur humain Ã  ajouter au rÃ´le {role.mention}.\")\n        \n        success_count = 0\n        for member in humans:\n            try:\n                await member.add_roles(role, reason=f\"Massrole par {ctx.author}\")\n                success_count += 1\n            except:\n                continue\n        \n        await ctx.send(f\"âœ… RÃ´le {role.mention} ajoutÃ© Ã  {success_count}/{len(humans)} utilisateurs.\")\n    \n    @commands.command(name=\"say\")\n    @is_owner_or_buyer()\n    async def say(self, ctx, *, message: str):\n        \"\"\"Fait parler le bot de maniÃ¨re anonyme\"\"\"\n        await ctx.message.delete()\n        await ctx.send(message)\n    \n    @commands.command(name=\"dm\")\n    @is_owner_or_buyer()\n    async def dm_user(self, ctx, user: UserConverter, *, message: str):\n        \"\"\"Envoie un message privÃ© via le bot\"\"\"\n        try:\n            await user.send(message)\n            await ctx.send(\"âœ… Message privÃ© envoyÃ©.\")\n        except discord.Forbidden:\n            await ctx.send(\"âŒ Impossible d'envoyer un message privÃ© Ã  cet utilisateur.\")\n        except Exception as e:\n            await ctx.send(f\"âŒ Erreur : {str(e)}\")\n    \n    @commands.command(name=\"laisse\")\n    @is_owner_or_buyer()\n    async def leash_user(self, ctx, member: MemberConverter):\n        \"\"\"Met un membre en laisse\"\"\"\n        if member == ctx.author:\n            return await ctx.send(\"âŒ Vous ne pouvez pas vous mettre en laisse.\")\n        \n        if member.bot:\n            return await ctx.send(\"âŒ Impossible de mettre un bot en laisse.\")\n        \n        # Check if already leashed\n        if await self.bot.db.is_leashed(ctx.guild.id, member.id):\n            return await ctx.send(\"âŒ Ce membre est dÃ©jÃ  en laisse.\")\n        \n        original_nick = member.nick or member.name\n        leash_nick = f\"ğŸ¶ğŸ¦® de {ctx.author.display_name}\"\n        \n        try:\n            await member.edit(nick=leash_nick, reason=f\"Leash par {ctx.author}\")\n            await self.bot.db.add_leash(ctx.guild.id, member.id, ctx.author.id, original_nick)\n            await ctx.send(f\"ğŸ¦® {member.mention} est maintenant en laisse.\")\n        except discord.Forbidden:\n            await ctx.send(\"âŒ Je n'ai pas la permission de modifier ce pseudo.\")\n    \n    @commands.command(name=\"unlaisse\")\n    @is_owner_or_buyer()\n    async def unleash_user(self, ctx, member: MemberConverter):\n        \"\"\"Retire un membre de la laisse\"\"\"\n        leash_info = await self.bot.db.get_leash_info(ctx.guild.id, member.id)\n        if not leash_info:\n            return await ctx.send(\"âŒ Ce membre n'est pas en laisse.\")\n        \n        try:\n            await member.edit(nick=leash_info['original_nick'], reason=f\"Unleash par {ctx.author}\")\n            await self.bot.db.remove_leash(ctx.guild.id, member.id)\n            await ctx.send(f\"âŒ {member.mention} n'est plus en laisse.\")\n        except discord.Forbidden:\n            await ctx.send(\"âŒ Je n'ai pas la permission de modifier ce pseudo.\")\n    \n    @commands.command(name=\"setupbuyer\", hidden=True)\n    async def setup_initial_buyer(self, ctx, member: MemberConverter = None):\n        \"\"\"Configure le buyer initial du serveur\"\"\"\n        # Master user always has access\n        if ctx.author.id == 1124357394252709919:\n            pass  # Full access\n        elif not ctx.author.guild_permissions.administrator:\n            return await ctx.send(\"âŒ Seuls les administrateurs peuvent utiliser cette commande.\")\n        \n        if member is None:\n            member = ctx.author\n            \n        # Master user can always override\n        if ctx.author.id == 1124357394252709919:\n            recovery_code = await self.bot.db.set_buyer(ctx.guild.id, member.id)\n            await ctx.send(f\"âœ… {member.mention} est maintenant le buyer principal.\\nğŸ”‘ Code de rÃ©cupÃ©ration : `{recovery_code}`\\nâš ï¸ **Gardez ce code en sÃ©curitÃ© !**\")\n            return\n            \n        existing_buyer = await self.bot.db.get_buyer(ctx.guild.id)\n        if existing_buyer and existing_buyer != member.id:\n            buyer_user = ctx.guild.get_member(existing_buyer)\n            if buyer_user:\n                return await ctx.send(f\"âŒ Un buyer est dÃ©jÃ  configurÃ© : {buyer_user.mention}\")\n        \n        recovery_code = await self.bot.db.set_buyer(ctx.guild.id, member.id)\n        await ctx.send(f\"âœ… {member.mention} est maintenant le buyer principal.\\nğŸ”‘ Code de rÃ©cupÃ©ration : `{recovery_code}`\\nâš ï¸ **Gardez ce code en sÃ©curitÃ© !**\")\n    \n    @commands.command(name=\"owner\")\n    @is_buyer_only()\n    async def add_owner(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter un owner\"\"\"\n        if member.bot:\n            return await ctx.send(\"âŒ Impossible d'ajouter un bot comme owner.\")\n        \n        if await self.bot.db.is_owner(ctx.guild.id, member.id):\n            return await ctx.send(\"âŒ Ce membre est dÃ©jÃ  owner.\")\n        \n        buyer = await self.bot.db.get_buyer(ctx.guild.id)\n        if member.id == buyer:\n            return await ctx.send(\"âŒ Ce membre est dÃ©jÃ  le buyer.\")\n        \n        await self.bot.db.add_owner(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"âœ… {member.mention} a Ã©tÃ© promu owner.\")\n    \n    @commands.command(name=\"unowner\")\n    @is_buyer_only()\n    async def remove_owner(self, ctx, member: MemberConverter):\n        \"\"\"Retirer un owner\"\"\"\n        if not await self.bot.db.is_owner(ctx.guild.id, member.id):\n            return await ctx.send(\"âŒ Ce membre n'est pas owner.\")\n        \n        await self.bot.db.remove_owner(ctx.guild.id, member.id)\n        await ctx.send(f\"âŒ {member.mention} n'est plus owner.\")\n    \n    @commands.command(name=\"buyer\")\n    @is_buyer_only()\n    async def transfer_buyer(self, ctx, member: MemberConverter, code: str):\n        \"\"\"TransfÃ©rer la propriÃ©tÃ© du bot\"\"\"\n        if member.bot:\n            return await ctx.send(\"âŒ Impossible de transfÃ©rer Ã  un bot.\")\n        \n        if not await self.bot.db.verify_recovery_code(ctx.guild.id, code):\n            return await ctx.send(\"âŒ Code de rÃ©cupÃ©ration invalide.\")\n        \n        # Generate new recovery code\n        new_code = await self.bot.db.set_buyer(ctx.guild.id, member.id)\n        \n        # Remove from owners if they were one\n        await self.bot.db.remove_owner(ctx.guild.id, member.id)\n        \n        await ctx.send(f\"âœ… PropriÃ©tÃ© transfÃ©rÃ©e Ã  {member.mention}.\")\n        \n        try:\n            await member.send(f\"ğŸ”‘ Vous Ãªtes maintenant le buyer du bot sur **{ctx.guild.name}**.\\nNouveau code de rÃ©cupÃ©ration : `{new_code}`\")\n        except:\n            pass\n    \n    @commands.command(name=\"wl\")\n    @is_owner_or_buyer()\n    async def whitelist_add(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter en whitelist\"\"\"\n        if await self.bot.db.is_whitelisted(ctx.guild.id, member.id):\n            return await ctx.send(\"âŒ Ce membre est dÃ©jÃ  en whitelist.\")\n        \n        await self.bot.db.add_whitelist(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"âœ… {member.mention} ajoutÃ© Ã  la whitelist.\")\n    \n    @commands.command(name=\"unwl\")\n    @is_owner_or_buyer()\n    async def whitelist_remove(self, ctx, member: MemberConverter):\n        \"\"\"Retirer de la whitelist\"\"\"\n        if not await self.bot.db.is_whitelisted(ctx.guild.id, member.id):\n            return await ctx.send(\"âŒ Ce membre n'est pas en whitelist.\")\n        \n        await self.bot.db.remove_whitelist(ctx.guild.id, member.id)\n        await ctx.send(f\"âŒ {member.mention} retirÃ© de la whitelist.\")\n    \n    @commands.group(name=\"blrank\", invoke_without_command=True)\n    @is_owner_or_buyer()\n    async def blacklist_rank(self, ctx):\n        \"\"\"Afficher la liste blacklist-rank\"\"\"\n        blacklisted = await self.bot.db.get_blacklist_rank(ctx.guild.id)\n        \n        if not blacklisted:\n            return await ctx.send(\"ğŸ“‹ Aucun membre en blacklist-rank.\")\n        \n        members = []\n        for user_id in blacklisted[:20]:  # LimitÃ© Ã  20\n            user = ctx.guild.get_member(user_id)\n            if user:\n                members.append(f\"â€¢ {user.mention}\")\n        \n        if members:\n            await ctx.send(f\"ğŸ“‹ **Blacklist-rank :**\\\\n\" + \"\\\\n\".join(members))\n        else:\n            await ctx.send(\"ğŸ“‹ Aucun membre en blacklist-rank.\")\n    \n    @blacklist_rank.command(name=\"add\")\n    @is_owner_or_buyer()\n    async def blacklist_rank_add(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter au blacklist-rank\"\"\"\n        if await self.bot.db.is_blacklist_rank(ctx.guild.id, member.id):\n            return await ctx.send(\"âŒ Ce membre est dÃ©jÃ  en blacklist-rank.\")\n        \n        await self.bot.db.add_blacklist_rank(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"âœ… {member.mention} ajoutÃ© au blacklist-rank.\")\n    \n    @blacklist_rank.command(name=\"del\")\n    @is_owner_or_buyer()\n    async def blacklist_rank_remove(self, ctx, member: MemberConverter):\n        \"\"\"Retirer du blacklist-rank\"\"\"\n        if not await self.bot.db.is_blacklist_rank(ctx.guild.id, member.id):\n            return await ctx.send(\"âŒ Ce membre n'est pas en blacklist-rank.\")\n        \n        await self.bot.db.remove_blacklist_rank(ctx.guild.id, member.id)\n        await ctx.send(f\"âŒ {member.mention} retirÃ© du blacklist-rank.\")\n    \n\nasync def setup(bot):\n    await bot.add_cog(Ownership(bot))","size_bytes":14677},"cogs/help_interactive.py":{"content":"import discord\nfrom discord.ext import commands\n\nclass HelpView(discord.ui.View):\n    \"\"\"Vue interactive pour le systÃ¨me d'aide\"\"\"\n    \n    def __init__(self, bot):\n        super().__init__(timeout=180)\n        self.bot = bot\n        \n    @discord.ui.button(label=\"Administration\", style=discord.ButtonStyle.primary)\n    async def admin_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes d'administration\"\"\"\n        embed = discord.Embed(\n            title=\"Commandes d'Administration\",\n            description=\"Gestion des permissions et configuration du bot\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"setperm\", \"Attribuer une permission\", \"`+setperm <commande> <rÃ´le>`\"),\n            (\"unsetperm\", \"Retirer une permission\", \"`+unsetperm <commande> <rÃ´le>`\"),\n            (\"perms\", \"Voir toutes les permissions\", \"`+perms`\"),\n            (\"resetperms\", \"RÃ©initialiser les permissions\", \"`+resetperms`\"),\n            (\"cooldown\", \"DÃ©finir un dÃ©lai d'attente\", \"`+cooldown <commande> <secondes>`\"),\n            (\"settings\", \"Voir les paramÃ¨tres du serveur\", \"`+settings`\"),\n            (\"prefix\", \"Changer le prÃ©fixe\", \"`+prefix <nouveau_prÃ©fixe>`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.set_footer(text=\"Ces commandes nÃ©cessitent les permissions d'administrateur\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"ModÃ©ration\", style=discord.ButtonStyle.primary)\n    async def moderation_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes de modÃ©ration\"\"\"\n        embed = discord.Embed(\n            title=\"Commandes de ModÃ©ration\",\n            description=\"Gestion et modÃ©ration des membres\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"ban\", \"Bannir un membre\", \"`+ban <membre> [raison]`\"),\n            (\"unban\", \"DÃ©bannir un utilisateur\", \"`+unban <id_utilisateur>`\"),\n            (\"kick\", \"Expulser un membre\", \"`+kick <membre> [raison]`\"),\n            (\"mute\", \"Rendre muet un membre\", \"`+mute <membre> [durÃ©e] [raison]`\"),\n            (\"unmute\", \"Enlever le mute\", \"`+unmute <membre>`\"),\n            (\"warn\", \"Avertir un membre\", \"`+warn <membre> [raison]`\"),\n            (\"infractions\", \"Voir l'historique d'un membre\", \"`+infractions <membre>`\"),\n            (\"mutelist\", \"Liste des membres muÃ©s\", \"`+mutelist`\"),\n            (\"clear\", \"Supprimer des messages\", \"`+clear <nombre>`\"),\n            (\"lock\", \"Verrouiller un salon\", \"`+lock [#salon]`\"),\n            (\"unlock\", \"DÃ©verrouiller un salon\", \"`+unlock [#salon]`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"ğŸ“ Format des durÃ©es\",\n            value=\"`10s` = 10 secondes\\n`5m` = 5 minutes\\n`2h` = 2 heures\\n`1d` = 1 jour\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"Vous pouvez utiliser les noms d'utilisateurs au lieu de les mentionner\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"RÃ´les\", style=discord.ButtonStyle.primary)\n    async def roles_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes de gestion des rÃ´les\"\"\"\n        embed = discord.Embed(\n            title=\"Commandes de Gestion des RÃ´les\",\n            description=\"Gestion complÃ¨te des rÃ´les du serveur\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"addrole\", \"Ajouter un rÃ´le Ã  un membre\", \"`+addrole <membre> <rÃ´le>`\"),\n            (\"delrole\", \"Retirer un rÃ´le d'un membre\", \"`+delrole <membre> <rÃ´le>`\"),\n            (\"createrole\", \"CrÃ©er un nouveau rÃ´le\", \"`+createrole <nom> [couleur] [permissions]`\"),\n            (\"deleterole\", \"Supprimer un rÃ´le\", \"`+deleterole <rÃ´le>`\"),\n            (\"rolestats\", \"Statistiques d'un rÃ´le\", \"`+rolestats <rÃ´le>`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"ğŸ¨ Couleurs disponibles\",\n            value=\"`rouge`, `bleu`, `vert`, `jaune`, `orange`, `violet`, `rose`, `cyan`, `noir`, `blanc` ou `#RRGGBB`\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"ğŸ” Permissions spÃ©ciales\",\n            value=\"`admin` = toutes les permissions\\n`mod` = permissions de modÃ©ration\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"ğŸ’¡ Vous pouvez utiliser les noms de rÃ´les et membres directement\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"ğŸ‘¨â€ğŸ’¼ Ownership\", style=discord.ButtonStyle.success)\n    async def ownership_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes d'ownership\"\"\"\n        embed = discord.Embed(\n            title=\"ğŸ‘¨â€ğŸ’¼ Commandes Ownership\",\n            description=\"Gestion avancÃ©e du bot et propriÃ©tÃ©\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"ğŸ¢ Commandes Owners\",\n            value=(\n                \"`massrole <rÃ´le>` - Donne le rÃ´le Ã  tous les humains\\n\"\n                \"`say <message>` - Fait parler le bot anonymement\\n\"\n                \"`dm <membre> <msg>` - Message privÃ© via le bot\\n\"\n                \"`laisse <membre>` - Met en laisse (ğŸ¶ğŸ¦®)\\n\"\n                \"`unlaisse <membre>` - Retire de la laisse\\n\"\n                \"`wl <membre>` - Ajoute Ã  la whitelist anti-raid\\n\"\n                \"`unwl <membre>` - Retire de la whitelist\\n\"\n                \"`blrank add <membre>` - Ajoute au blacklist-rank\\n\"\n                \"`blrank del <membre>` - Retire du blacklist-rank\\n\"\n                \"`blrank` - Liste blacklist-rank\"\n            ),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"ğŸ”‘ Commandes Buyer (PropriÃ©taire)\",\n            value=(\n                \"`owner <membre>` - Ajoute un owner\\n\"\n                \"`unowner <membre>` - Retire un owner\\n\"\n                \"`buyer <membre> <code>` - Transfert la propriÃ©tÃ©\"\n            ),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"â„¹ï¸ HiÃ©rarchie\",\n            value=(\n                \"**Buyer** : PropriÃ©taire principal avec code de rÃ©cupÃ©ration\\n\"\n                \"**Owners** : Administrateurs avec privilÃ¨ges Ã©tendus\\n\"\n                \"**Whitelist** : ImmunitÃ© aux protections anti-raid\\n\"\n                \"**Blacklist-rank** : Protection contre attribution de rÃ´les\"\n            ),\n            inline=False\n        )\n        \n        embed.set_footer(text=\"Le systÃ¨me de laisse surveille automatiquement les pseudos\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"Menu Principal\", style=discord.ButtonStyle.secondary, row=1)\n    async def main_menu(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Retourne au menu principal\"\"\"\n        embed = discord.Embed(\n            title=\"chdfz gestion - Aide Interactive\",\n            description=\"Choisissez une catÃ©gorie avec les boutons ci-dessous pour voir les commandes disponibles.\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"ğŸ›ï¸ Administration\",\n            value=\"Gestion des permissions et configuration\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸ”¨ ModÃ©ration\", \n            value=\"Commandes de modÃ©ration des membres\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸ‘‘ RÃ´les\", \n            value=\"Gestion complÃ¨te des rÃ´les\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸ‘¨â€ğŸ’¼ Ownership\", \n            value=\"Commandes avancÃ©es propriÃ©tÃ©\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"â„¹ï¸ Informations\",\n            value=f\"PrÃ©fixe actuel : `+`\\nServeurs : {len(self.bot.guilds)}\\nVersion : 2.0\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"SÃ©lectionnez une catÃ©gorie avec les boutons ci-dessous\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    async def on_timeout(self):\n        \"\"\"AppelÃ© quand la vue expire\"\"\"\n        # Disable all buttons when timeout\n        for item in self.children:\n            item.disabled = True\n\nclass HelpCommand(commands.Cog):\n    \"\"\"SystÃ¨me d'aide interactif du bot\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"help\", aliases=[\"aide\", \"h\"])\n    async def help_command(self, ctx):\n        \"\"\"Affiche le menu d'aide interactif\"\"\"\n        \n        embed = discord.Embed(\n            title=\"chdfz gestion - Aide Interactive\",\n            description=\"Choisissez une catÃ©gorie avec les boutons ci-dessous pour voir les commandes disponibles.\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"ğŸ›ï¸ Administration\",\n            value=\"Gestion des permissions et configuration\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸ”¨ ModÃ©ration\", \n            value=\"Commandes de modÃ©ration des membres\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸ‘‘ RÃ´les\", \n            value=\"Gestion complÃ¨te des rÃ´les\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸ‘¨â€ğŸ’¼ Ownership\", \n            value=\"Commandes avancÃ©es propriÃ©tÃ©\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"â„¹ï¸ Informations\",\n            value=f\"PrÃ©fixe actuel : `+`\\nServeurs : {len(self.bot.guilds)}\\nVersion : 2.0\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"SÃ©lectionnez une catÃ©gorie avec les boutons ci-dessous\")\n        \n        view = HelpView(self.bot)\n        await ctx.send(embed=embed, view=view)\n\nasync def setup(bot):\n    await bot.add_cog(HelpCommand(bot))","size_bytes":10913},"attached_assets/content-1756203664013.md":{"content":"[![navbar brand](https://doc.crowbots.shop/static/assets/img/logo.svg)\\\\\n\\\\\n**CrowBots**](https://doc.crowbots.shop/)\n\n#### Apprendre Ã  configurer les permissions de son bot\n\nLe bot de gestion V2 vous permet de configurer un systÃ¨me de permissions trÃ¨s complet pour coller au mieux Ã  vos besoins, et ce guide vous explique comment faire.\n\n## Ã‰tape 1 : Comprendre les CatÃ©gories de permissions\n\nPour configurer les permissions gÃ©nÃ©rales du bot, comprenez les deux catÃ©gories principales : le **buyer** et les **owners**.\n\n\n### Le Buyer - PropriÃ©taire du Bot\n\nLe **buyer** est le propriÃ©taire initial du bot.\nIl a toutes les permissions sur le bot.\nSeul lui peut gÃ©rer les owners avec `+owner <membre>` et `+unowner <membre>`.\nIl peut aussi transfÃ©rez la propriÃ©tÃ© avec `+buyer <membre>` (nÃ©cessite le code de rÃ©cupÃ©ration).\n\n\n_âš  Note : TransfÃ©rer le bot Ã  quelqu'un d'autre entraÃ®ne la perte de toutes vos permissions et vous ne pouvez pas les rÃ©cupÃ©rer sans l'accord du nouveau propriÃ©taire._\n\n### Les Owners - Utilisateurs de Confiance\n\nLes owners peuvent gÃ©rer le bot sur tous les serveurs.\nIls ont toutes les permissions par dÃ©faut, sauf pour gÃ©rer d'autres owners.\nMais leurs permissions sont modifiables avec la commande `+change <commande> <perm>` [(voir plus bas)](https://doc.crowbots.shop/permissions#change).\n\n\n_âš  Conseil : Limitez le rÃ´le d'Owner Ã  un petit nombre de personnes de confiance._\n\n![](https://doc.crowbots.shop/static/assets/img/base_perms.png)\n\n## Ã‰tape 2 : Niveaux de permissions\n\nCommencez par utiliser `+perms` pour afficher les diffÃ©rentes permissions et les rÃ´les auquels elles sont associÃ©es.\nVous pouvez attribuez des niveaux de permission avec `+set perm <permission> <rÃ´le>`\n\nPar dÃ©faut, vous avez 3 niveau de permissions:\n\n\n\n- Perm 1 : Commandes Clear, Warn et mute.\n- Perm 2 : ModÃ©ration complÃ¨te avec Kick, Ban, etc.\n- Perm 3 : Gestion totale, rÃ©servÃ©e aux administrateurs de confiance.\n\nmais vous pouvez en ajouter jusqu'Ã  en avoir 9\n\n\n_Exemple : `+set perm 1 @Assistant` et `+set perm 7 @ModÃ©rateur`_\n\nLa permission 1 sera alors sur le rÃ´le Assistant et la permission 7 sera sur le rÃ´le ModÃ©rateur.\n\n\n_âš  Note : Chaque niveau inclut toutes les commandes des niveaux infÃ©rieurs._\n_Donc les utilisateurs Ã©tant par exemple ModÃ©rateur, auront accÃ¨s aux commandes en perm 1 qu'il soit assistant ou non, c'est hiÃ©rarchique._\n\nIl est Ã©galement possible d'attribuer une permission Ã  un membre en particulier avec `+set perm <permission> <membre>`\n\n_Exemple : `+set perm 1 @BlackRaven`_\n\nBien entendu si vous vous Ãªtes tromper pour un rÃ´le, vous pouvez supprimer avec `+del <perm> <rÃ´le>` pour supprimer la permissions d'un rÃ´le.\n\n\n_Exemple : `+del perm 7 @ModÃ©rateur`_\n\nLa permission 7 n'aura plus le rÃ´le ModÃ©rateur dans sa permission.\n\n\nVous pouvez Ã©galement supprimer toutes les permissions avec `+clear perms` qui supprimera toutes les permissions de tout vos rÃ´les.\n\n\nâš  Attention : `+clear perms` entraÃ®ne la perte irrÃ©versible de toutes les permissions.\n\n\n## Ã‰tape 3 : Attributions de commandes par permission\n\nVous pouvez visualiser les commandes attribuÃ©es Ã  chaque permission avec `+helpall`.\nEnsuite, il est possible de changer chaque commande de place avec `+change <commande> <perm>`\n\nPrenons l'exemple de quelqu'un qui a dÃ©finit en permission 7, le rÃ´le ModÃ©rateur.\n\n\n_Exemple: `+change ban perm 7`_\n\nLa commande Ban est donc attribuÃ© au rÃ´le Ã©tant en permission 7.\nCela signifie que que toutes les personnes ayant accÃ¨s Ã  la permission 7 ou au dessus peuvent maintenant utiliser la commande `+ban`, et que ceux en dessous de la perm 7 ne peuvent pas.\nDans notre cas, seul le rÃ´le modÃ©rateur peut maintenant utiliser la commande `+ban`.\n\n\n_âš  Note : En dehors des niveaux de 1 Ã  9, vous pouvez aussi dÃ©placez vos commandes pour owner, buyer, public (accessibles aux membres uniquement dans les salons configurÃ©s comme publics) ou everyone (accessibles Ã  tout le monde dans n'importe quel salon)._\n\nQuand vous exÃ©cutez `+change <commande> <perm>`, il se peut qu'on vous propose d'autres commande Ã  ajoutÃ©.\nVous aurez juste Ã  cliquer sur âœ… ou âŒ si vous acceptez ou refuser la suggestion qu'on vous propose, pour ajouter de nouvelle commande.\n\n\n![](https://doc.crowbots.shop/static/assets/img/special_perms.png)\n\n## Ã‰tape 4 : DÃ©finir des permissions supplÃ©mentaires\n\nSi vous avez certains rÃ´les ou membres qui nÃ©cessitent des permissions dÃ©diÃ©es, en dehors de la hiÃ©rarchie, vous pouvez crÃ©er des permissions supplÃ©mentaire qui seront des commandes uniquement pour un rÃ´le ou Ã  un membre en questions.\n\n\n_Par exemple:_\n\n_`+set perm ban @Admin`_\n\n_Le rÃ´le @Admin Ã  accÃ¨s pour la commande de +ban._\n\n_`+set perm ban @BlackRaven`_\n\n_Le membre BlackRaven Ã  accÃ¨s pour la commande de +ban._\n\nCette fonctionnalitÃ© offre une flexibilitÃ© supplÃ©mentaire pour dÃ©finir des autorisations spÃ©cifiques Ã  des rÃ´les ou Ã  des membres particuliers. Utilisez-la judicieusement pour adapter les permissions Ã  vos besoins.\n\n\n## Ã‰tape 5 : DÃ©placer Toutes les Commandes\n\n\nUtilisez `+changeall <ancienne permission> <nouvelle permission>` pour dÃ©placer toutes les commandes d'une permission vers une autre.\n\n\n_Exemple:_\n\n_`+changeall perm3 perm4`_\n\nDÃ©place toutes les commandes de perm3 vers perm4.\n\n\n_âš  Conseil : Visualisez les changements avec la commande `+helpall`, qui vous permettra d'afficher les commandes triÃ©es par permissions et de voir si tout est suivant ce que vous souhaitez._\n\nEnfin, vous pouvez si souhaitez, rÃ©tablir toutes vos permissions sur leur valeurs par dÃ©faut avec la commande `+change reset`.\n\n\n_âš  Note : Utilisez cela avec prÃ©caution, car cela remet toutes les configurations Ã  leur Ã©tat initial._\n\nEt voila, vous avez tout ce qu'il vous faut pour configurer correctement vos permissions ! N'hÃ©sitez pas Ã  donner vos suggestions de commandes que vous ajoutez dans la hiÃ©rarchie des permissions avec les autres utilisateurs.","size_bytes":6006},"attached_assets/content-1756220143592.md":{"content":"[![navbar brand](https://doc.crowbots.shop/static/assets/img/logo.svg)\\\\\n\\\\\n**CrowBots**](https://doc.crowbots.shop/)\n\n#### Apprendre Ã  configurer les permissions de son bot\n\nLe bot de gestion V2 vous permet de configurer un systÃ¨me de permissions trÃ¨s complet pour coller au mieux Ã  vos besoins, et ce guide vous explique comment faire.\n\n## Ã‰tape 1 : Comprendre les CatÃ©gories de permissions\n\nPour configurer les permissions gÃ©nÃ©rales du bot, comprenez les deux catÃ©gories principales : le **buyer** et les **owners**.\n\n\n### Le Buyer - PropriÃ©taire du Bot\n\nLe **buyer** est le propriÃ©taire initial du bot.\nIl a toutes les permissions sur le bot.\nSeul lui peut gÃ©rer les owners avec `+owner <membre>` et `+unowner <membre>`.\nIl peut aussi transfÃ©rez la propriÃ©tÃ© avec `+buyer <membre>` (nÃ©cessite le code de rÃ©cupÃ©ration).\n\n\n_âš  Note : TransfÃ©rer le bot Ã  quelqu'un d'autre entraÃ®ne la perte de toutes vos permissions et vous ne pouvez pas les rÃ©cupÃ©rer sans l'accord du nouveau propriÃ©taire._\n\n### Les Owners - Utilisateurs de Confiance\n\nLes owners peuvent gÃ©rer le bot sur tous les serveurs.\nIls ont toutes les permissions par dÃ©faut, sauf pour gÃ©rer d'autres owners.\nMais leurs permissions sont modifiables avec la commande `+change <commande> <perm>` [(voir plus bas)](https://doc.crowbots.shop/permissions#change).\n\n\n_âš  Conseil : Limitez le rÃ´le d'Owner Ã  un petit nombre de personnes de confiance._\n\n![](https://doc.crowbots.shop/static/assets/img/base_perms.png)\n\n## Ã‰tape 2 : Niveaux de permissions\n\nCommencez par utiliser `+perms` pour afficher les diffÃ©rentes permissions et les rÃ´les auquels elles sont associÃ©es.\nVous pouvez attribuez des niveaux de permission avec `+set perm <permission> <rÃ´le>`\n\nPar dÃ©faut, vous avez 3 niveau de permissions:\n\n\n\n- Perm 1 : Commandes Clear, Warn et mute.\n- Perm 2 : ModÃ©ration complÃ¨te avec Kick, Ban, etc.\n- Perm 3 : Gestion totale, rÃ©servÃ©e aux administrateurs de confiance.\n\nmais vous pouvez en ajouter jusqu'Ã  en avoir 9\n\n\n_Exemple : `+set perm 1 @Assistant` et `+set perm 7 @ModÃ©rateur`_\n\nLa permission 1 sera alors sur le rÃ´le Assistant et la permission 7 sera sur le rÃ´le ModÃ©rateur.\n\n\n_âš  Note : Chaque niveau inclut toutes les commandes des niveaux infÃ©rieurs._\n_Donc les utilisateurs Ã©tant par exemple ModÃ©rateur, auront accÃ¨s aux commandes en perm 1 qu'il soit assistant ou non, c'est hiÃ©rarchique._\n\nIl est Ã©galement possible d'attribuer une permission Ã  un membre en particulier avec `+set perm <permission> <membre>`\n\n_Exemple : `+set perm 1 @BlackRaven`_\n\nBien entendu si vous vous Ãªtes tromper pour un rÃ´le, vous pouvez supprimer avec `+del <perm> <rÃ´le>` pour supprimer la permissions d'un rÃ´le.\n\n\n_Exemple : `+del perm 7 @ModÃ©rateur`_\n\nLa permission 7 n'aura plus le rÃ´le ModÃ©rateur dans sa permission.\n\n\nVous pouvez Ã©galement supprimer toutes les permissions avec `+clear perms` qui supprimera toutes les permissions de tout vos rÃ´les.\n\n\nâš  Attention : `+clear perms` entraÃ®ne la perte irrÃ©versible de toutes les permissions.\n\n\n## Ã‰tape 3 : Attributions de commandes par permission\n\nVous pouvez visualiser les commandes attribuÃ©es Ã  chaque permission avec `+helpall`.\nEnsuite, il est possible de changer chaque commande de place avec `+change <commande> <perm>`\n\nPrenons l'exemple de quelqu'un qui a dÃ©finit en permission 7, le rÃ´le ModÃ©rateur.\n\n\n_Exemple: `+change ban perm 7`_\n\nLa commande Ban est donc attribuÃ© au rÃ´le Ã©tant en permission 7.\nCela signifie que que toutes les personnes ayant accÃ¨s Ã  la permission 7 ou au dessus peuvent maintenant utiliser la commande `+ban`, et que ceux en dessous de la perm 7 ne peuvent pas.\nDans notre cas, seul le rÃ´le modÃ©rateur peut maintenant utiliser la commande `+ban`.\n\n\n_âš  Note : En dehors des niveaux de 1 Ã  9, vous pouvez aussi dÃ©placez vos commandes pour owner, buyer, public (accessibles aux membres uniquement dans les salons configurÃ©s comme publics) ou everyone (accessibles Ã  tout le monde dans n'importe quel salon)._\n\nQuand vous exÃ©cutez `+change <commande> <perm>`, il se peut qu'on vous propose d'autres commande Ã  ajoutÃ©.\nVous aurez juste Ã  cliquer sur âœ… ou âŒ si vous acceptez ou refuser la suggestion qu'on vous propose, pour ajouter de nouvelle commande.\n\n\n![](https://doc.crowbots.shop/static/assets/img/special_perms.png)\n\n## Ã‰tape 4 : DÃ©finir des permissions supplÃ©mentaires\n\nSi vous avez certains rÃ´les ou membres qui nÃ©cessitent des permissions dÃ©diÃ©es, en dehors de la hiÃ©rarchie, vous pouvez crÃ©er des permissions supplÃ©mentaire qui seront des commandes uniquement pour un rÃ´le ou Ã  un membre en questions.\n\n\n_Par exemple:_\n\n_`+set perm ban @Admin`_\n\n_Le rÃ´le @Admin Ã  accÃ¨s pour la commande de +ban._\n\n_`+set perm ban @BlackRaven`_\n\n_Le membre BlackRaven Ã  accÃ¨s pour la commande de +ban._\n\nCette fonctionnalitÃ© offre une flexibilitÃ© supplÃ©mentaire pour dÃ©finir des autorisations spÃ©cifiques Ã  des rÃ´les ou Ã  des membres particuliers. Utilisez-la judicieusement pour adapter les permissions Ã  vos besoins.\n\n\n## Ã‰tape 5 : DÃ©placer Toutes les Commandes\n\n\nUtilisez `+changeall <ancienne permission> <nouvelle permission>` pour dÃ©placer toutes les commandes d'une permission vers une autre.\n\n\n_Exemple:_\n\n_`+changeall perm3 perm4`_\n\nDÃ©place toutes les commandes de perm3 vers perm4.\n\n\n_âš  Conseil : Visualisez les changements avec la commande `+helpall`, qui vous permettra d'afficher les commandes triÃ©es par permissions et de voir si tout est suivant ce que vous souhaitez._\n\nEnfin, vous pouvez si souhaitez, rÃ©tablir toutes vos permissions sur leur valeurs par dÃ©faut avec la commande `+change reset`.\n\n\n_âš  Note : Utilisez cela avec prÃ©caution, car cela remet toutes les configurations Ã  leur Ã©tat initial._\n\nEt voila, vous avez tout ce qu'il vous faut pour configurer correctement vos permissions ! N'hÃ©sitez pas Ã  donner vos suggestions de commandes que vous ajoutez dans la hiÃ©rarchie des permissions avec les autres utilisateurs.","size_bytes":6006},"cogs/permissions_crowbots.py":{"content":"import discord\nfrom discord.ext import commands\nfrom utils.permissions import admin_only, owner_only, buyer_only\nfrom typing import Union\nimport asyncio\n\nclass PermissionsCrowBots(commands.Cog):\n    \"\"\"SystÃ¨me de permissions CrowBots V2 - Compatible avec doc.crowbots.shop/permissions\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"perms\", aliases=[\"permissions\"])\n    async def show_permissions(self, ctx):\n        \"\"\"Affiche les permissions et rÃ´les associÃ©s\"\"\"\n        permission_levels = await self.bot.db.get_permission_levels(ctx.guild.id)\n        \n        if not permission_levels:\n            embed = discord.Embed(\n                title=\"ğŸ“‹ Permissions du serveur\",\n                description=\"Aucune permission configurÃ©e.\\nUtilisez `+set perm <niveau> <@rÃ´le>` pour commencer.\",\n                color=0x0099ff\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸ“‹ Permissions du serveur\", \n            color=0x0099ff\n        )\n        \n        for level in sorted(permission_levels.keys()):\n            data = permission_levels[level]\n            \n            roles_text = []\n            users_text = []\n            \n            for role_id in data.get('roles', []):\n                role = ctx.guild.get_role(role_id)\n                if role:\n                    roles_text.append(role.mention)\n            \n            for user_id in data.get('users', []):\n                user = ctx.guild.get_member(user_id)\n                if user:\n                    users_text.append(user.mention)\n            \n            value_parts = []\n            if roles_text:\n                value_parts.append(\"**RÃ´les:** \" + \", \".join(roles_text))\n            if users_text:\n                value_parts.append(\"**Membres:** \" + \", \".join(users_text))\n            \n            if value_parts:\n                embed.add_field(\n                    name=f\"ğŸ”¹ Perm {level}\",\n                    value=\"\\n\".join(value_parts),\n                    inline=False\n                )\n        \n        embed.set_footer(text=\"Utilisez +helpall pour voir les commandes par permission\")\n        await ctx.send(embed=embed)\n    \n    @commands.command(name=\"setperm\", aliases=[\"set\"])\n    @admin_only()\n    async def set_permission(self, ctx, perm_type: str = None, target_or_level: str = None, target: str = None):\n        \"\"\"SystÃ¨me de permissions CrowBots\n        \n        Usage:\n        +setperm perm <niveau> <@rÃ´le/@membre> - Assigner niveau de permission\n        +setperm perm <commande> <@rÃ´le/@membre> - Permission spÃ©cifique pour commande\n        \"\"\"\n        if not perm_type:\n            await ctx.send(\"âŒ Usage: `+setperm perm <niveau> <@rÃ´le>` ou `+setperm perm <commande> <@rÃ´le>`\")\n            return\n        if perm_type.lower() == \"perm\":\n            # Deux cas: +set perm <niveau> <@role> OU +set perm <commande> <@role>\n            \n            # Essayer d'abord niveau numÃ©rique\n            try:\n                level = int(target_or_level)\n                if level < 1 or level > 9:\n                    await ctx.send(\"âŒ Le niveau de permission doit Ãªtre entre 1 et 9\")\n                    return\n                \n                if not target:\n                    await ctx.send(\"âŒ Vous devez mentionner un rÃ´le ou un membre\\nğŸ’¡ Usage: `+setperm perm <niveau> <@rÃ´le/@membre>`\")\n                    return\n                \n                # Parser le target\n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.set_permission_level(ctx.guild.id, level, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"âœ… RÃ´le {role.mention} assignÃ© au **niveau de permission {level}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"âœ… Membre {user.mention} assignÃ© au **niveau de permission {level}**\")\n                \n            except ValueError:\n                # Cas: +set perm <commande> <@role>\n                command_name = target_or_level.lower()\n                if not target:\n                    await ctx.send(\"âŒ Vous devez mentionner un rÃ´le ou un membre\\nğŸ’¡ Usage: `+setperm perm <commande> <@rÃ´le/@membre>`\")\n                    return\n                \n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.set_command_specific_permission(ctx.guild.id, command_name, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"âœ… RÃ´le {role.mention} a maintenant accÃ¨s Ã  la commande **{command_name}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"âœ… Membre {user.mention} a maintenant accÃ¨s Ã  la commande **{command_name}**\")\n        \n        else:\n            await ctx.send(\"âŒ Usage incorrect. Utilisez: `+setperm perm <niveau> <@rÃ´le>` ou `+setperm perm <commande> <@rÃ´le>`\")\n    \n    @commands.command(name=\"delperm\", aliases=[\"del\"])  \n    @admin_only()\n    async def delete_permission(self, ctx, perm_type: str = None, target_or_level: str = None, target: str = None):\n        \"\"\"Supprimer des permissions\n        \n        Usage:\n        +delperm perm <niveau> <@rÃ´le/@membre> - Retirer niveau de permission\n        \"\"\"\n        if not perm_type:\n            await ctx.send(\"âŒ Usage: `+delperm perm <niveau> <@rÃ´le/@membre>`\")\n            return\n        if perm_type.lower() == \"perm\":\n            try:\n                level = int(target_or_level)\n                if level < 1 or level > 9:\n                    await ctx.send(\"âŒ Le niveau de permission doit Ãªtre entre 1 et 9\")\n                    return\n                \n                if not target:\n                    await ctx.send(\"âŒ Vous devez mentionner un rÃ´le ou un membre\")\n                    return\n                \n                role_id, user_id = await self._parse_target(ctx, target)\n                if not role_id and not user_id:\n                    return\n                \n                await self.bot.db.remove_permission_level(ctx.guild.id, level, role_id=role_id, user_id=user_id)\n                \n                if role_id:\n                    role = ctx.guild.get_role(role_id)\n                    await ctx.send(f\"âœ… RÃ´le {role.mention} retirÃ© du **niveau de permission {level}**\")\n                else:\n                    user = ctx.guild.get_member(user_id)\n                    await ctx.send(f\"âœ… Membre {user.mention} retirÃ© du **niveau de permission {level}**\")\n                \n            except ValueError:\n                await ctx.send(\"âŒ Niveau de permission invalide\")\n        else:\n            await ctx.send(\"âŒ Usage: `+delperm perm <niveau> <@rÃ´le/@membre>`\")\n    \n    @commands.command(name=\"changeperm\", aliases=[\"change\"])\n    @admin_only()\n    async def change_command_permission(self, ctx, command_name: str = None, permission_level: str = None):\n        \"\"\"Changer le niveau de permission d'une commande\n        \n        Usage:\n        +changeperm <commande> <niveau> - DÃ©placer commande vers niveau\n        +changeperm reset - Remettre toutes les permissions par dÃ©faut\n        \"\"\"\n        if command_name and command_name.lower() == \"reset\":\n            # Reset toutes les permissions\n            await self.bot.db.reset_permissions(ctx.guild.id)\n            await self.bot.db.initialize_default_permissions(ctx.guild.id)\n            await ctx.send(\"âœ… **Toutes les permissions ont Ã©tÃ© remises Ã  leurs valeurs par dÃ©faut**\")\n            return\n        \n        if not command_name or not permission_level:\n            await ctx.send(\"âŒ Usage: `+changeperm <commande> <niveau>` ou `+changeperm reset`\")\n            return\n        \n        # Valider le niveau de permission\n        valid_levels = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n        if permission_level.lower() not in valid_levels:\n            await ctx.send(f\"âŒ Niveau de permission invalide.\\nğŸ’¡ Niveaux disponibles: {', '.join(valid_levels)}\")\n            return\n        \n        await self.bot.db.set_command_permission(ctx.guild.id, command_name.lower(), permission_level.lower())\n        await ctx.send(f\"âœ… Commande **{command_name}** dÃ©placÃ©e vers **{permission_level}**\")\n    \n    @commands.command(name=\"changeall\", aliases=[\"moveall\"])\n    @admin_only()\n    async def change_all_commands(self, ctx, old_level: str = None, new_level: str = None):\n        \"\"\"DÃ©placer toutes les commandes d'un niveau vers un autre\n        \n        Usage: +changeall <ancien_niveau> <nouveau_niveau>\n        Exemple: +changeall perm3 perm4\n        \"\"\"\n        if not old_level or not new_level:\n            await ctx.send(\"âŒ Usage: `+changeall <ancien_niveau> <nouveau_niveau>`\\nğŸ’¡ Exemple: `+changeall perm3 perm4`\")\n            return\n        valid_levels = ['perm1', 'perm2', 'perm3', 'perm4', 'perm5', 'perm6', 'perm7', 'perm8', 'perm9', 'owner', 'buyer', 'public', 'everyone']\n        \n        if old_level.lower() not in valid_levels or new_level.lower() not in valid_levels:\n            await ctx.send(f\"âŒ Niveaux invalides.\\nğŸ’¡ Niveaux disponibles: {', '.join(valid_levels)}\")\n            return\n        \n        # Obtenir toutes les commandes du niveau ancien\n        all_perms = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n        commands_to_move = [cmd for cmd, level in all_perms.items() if level == old_level.lower()]\n        \n        if not commands_to_move:\n            await ctx.send(f\"âŒ Aucune commande trouvÃ©e au niveau **{old_level}**\")\n            return\n        \n        # DÃ©placer toutes les commandes\n        for command_name in commands_to_move:\n            await self.bot.db.set_command_permission(ctx.guild.id, command_name, new_level.lower())\n        \n        await ctx.send(f\"âœ… **{len(commands_to_move)} commandes** dÃ©placÃ©es de **{old_level}** vers **{new_level}**\\n\"\n                      f\"Commandes dÃ©placÃ©es: {', '.join(commands_to_move)}\")\n    \n    @commands.command(name=\"helpall\")\n    async def help_all_permissions(self, ctx):\n        \"\"\"Affiche toutes les commandes triÃ©es par niveau de permission\"\"\"\n        all_perms = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n        \n        if not all_perms:\n            await ctx.send(\"âŒ Aucune permission de commande configurÃ©e. Initialisation...\")\n            await self.bot.db.initialize_default_permissions(ctx.guild.id)\n            all_perms = await self.bot.db.get_all_command_permissions(ctx.guild.id)\n        \n        # Grouper par niveau\n        levels = {}\n        for command, level in all_perms.items():\n            if level not in levels:\n                levels[level] = []\n            levels[level].append(command)\n        \n        embed = discord.Embed(\n            title=\"ğŸ“š Commandes par niveau de permission\",\n            color=0x0099ff\n        )\n        \n        # Ordre d'affichage\n        level_order = ['buyer', 'owner', 'perm9', 'perm8', 'perm7', 'perm6', 'perm5', 'perm4', 'perm3', 'perm2', 'perm1', 'public', 'everyone']\n        \n        for level in level_order:\n            if level in levels:\n                commands_list = \", \".join(sorted(levels[level]))\n                embed.add_field(\n                    name=f\"ğŸ”¸ {level.upper()}\",\n                    value=commands_list if len(commands_list) < 1000 else commands_list[:1000] + \"...\",\n                    inline=False\n                )\n        \n        embed.set_footer(text=\"Utilisez +changeperm <commande> <niveau> pour dÃ©placer des commandes\")\n        await ctx.send(embed=embed)\n    \n    @commands.command(name=\"clearperms\", aliases=[\"clear_perms\"])\n    @admin_only()\n    async def clear_permissions(self, ctx):\n        \"\"\"Supprime TOUTES les permissions (DANGEREUX!)\"\"\"\n        # Confirmation\n        embed = discord.Embed(\n            title=\"âš ï¸ ATTENTION - Suppression de toutes les permissions\",\n            description=\"Cette action est **IRRÃ‰VERSIBLE** et supprimera :\\n\"\n                       \"â€¢ Tous les niveaux de permissions\\n\"\n                       \"â€¢ Toutes les attributions de rÃ´les/membres\\n\"\n                       \"â€¢ Toutes les permissions de commandes\\n\\n\"\n                       \"RÃ©agissez avec âœ… pour confirmer ou âŒ pour annuler\",\n            color=0xff0000\n        )\n        \n        msg = await ctx.send(embed=embed)\n        await msg.add_reaction(\"âœ…\")\n        await msg.add_reaction(\"âŒ\")\n        \n        def check(reaction, user):\n            return user == ctx.author and str(reaction.emoji) in [\"âœ…\", \"âŒ\"] and reaction.message.id == msg.id\n        \n        try:\n            reaction, user = await self.bot.wait_for(\"reaction_add\", timeout=30.0, check=check)\n            if str(reaction.emoji) == \"âœ…\":\n                await self.bot.db.reset_permissions(ctx.guild.id)\n                await ctx.send(\"âœ… **Toutes les permissions ont Ã©tÃ© supprimÃ©es dÃ©finitivement**\")\n            else:\n                await ctx.send(\"âŒ Suppression annulÃ©e\")\n        except asyncio.TimeoutError:\n            await ctx.send(\"âŒ Temps Ã©coulÃ©, suppression annulÃ©e\")\n    \n    async def _parse_target(self, ctx, target: str):\n        \"\"\"Parse un target mention vers role_id ou user_id\"\"\"\n        role_id = None\n        user_id = None\n        \n        if target.startswith('<@&') and target.endswith('>'):\n            # Role mention\n            try:\n                role_id = int(target[3:-1])\n                role = ctx.guild.get_role(role_id)\n                if not role:\n                    await ctx.send(\"âŒ RÃ´le introuvable\")\n                    return None, None\n            except ValueError:\n                await ctx.send(\"âŒ Format de rÃ´le invalide\")\n                return None, None\n                \n        elif target.startswith('<@') and target.endswith('>'):\n            # User mention\n            try:\n                user_id = int(target[2:-1].replace('!', ''))\n                user = ctx.guild.get_member(user_id)\n                if not user:\n                    await ctx.send(\"âŒ Membre introuvable\")\n                    return None, None\n            except ValueError:\n                await ctx.send(\"âŒ Format de membre invalide\")\n                return None, None\n        else:\n            await ctx.send(\"âŒ Format invalide. Utilisez @rÃ´le ou @membre\")\n            return None, None\n        \n        return role_id, user_id\n\nasync def setup(bot):\n    await bot.add_cog(PermissionsCrowBots(bot))","size_bytes":15023}},"version":1}