{"file_contents":{"README.md":{"content":"# üéØ CrowBot Gestion V2\n\n**CrowBot Gestion V2** est un bot Discord de mod√©ration et d'administration complet, d√©velopp√© en Python avec discord.py. Il offre un syst√®me de gestion avanc√© pour les serveurs Discord avec des fonctionnalit√©s de mod√©ration, d'administration et de gestion des r√¥les.\n\n## üìã Table des mati√®res\n\n- [Fonctionnalit√©s](#-fonctionnalit√©s)\n- [Installation](#-installation)\n- [Configuration](#Ô∏è-configuration)\n- [Structure du projet](#-structure-du-projet)\n- [Commandes disponibles](#-commandes-disponibles)\n- [Permissions et s√©curit√©](#-permissions-et-s√©curit√©)\n- [Architecture du code](#-architecture-du-code)\n- [Guide de d√©veloppement](#-guide-de-d√©veloppement)\n- [Troubleshooting](#-troubleshooting)\n- [Contribuer](#-contribuer)\n\n## üöÄ Fonctionnalit√©s\n\n### üéõÔ∏è **Administration**\n- Gestion des permissions par r√¥le\n- Configuration des cooldowns\n- Gestion du pr√©fixe personnalis√©\n- R√©initialisation des param√®tres\n- Affichage des configurations\n\n### üî® **Mod√©ration**\n- Bannissement et d√©bannissement\n- Expulsion des membres\n- Syst√®me de mute temporaire ou permanent\n- Syst√®me d'avertissements\n- Historique des infractions\n- Nettoyage de messages\n- Verrouillage/d√©verrouillage de salons\n\n### üëë **Gestion des r√¥les**\n- Ajout et suppression de r√¥les\n- Cr√©ation de r√¥les avec couleurs personnalis√©es\n- Suppression de r√¥les existants\n- Statistiques d√©taill√©es des r√¥les\n- Support des noms, mentions et IDs\n\n### üõ°Ô∏è **S√©curit√©**\n- Syst√®me de permissions hi√©rarchique\n- V√©rification des r√¥les et positions\n- Logs d√©taill√©s de toutes les actions\n- Protection contre l'auto-mod√©ration\n- Messages d'erreur en fran√ßais\n\n## üíª Installation\n\n### Pr√©requis\n- Python 3.7 ou sup√©rieur\n- discord.py 2.6+\n- SQLite3 (inclus avec Python)\n\n### Installation rapide\n\n1. **Clonez le projet**\n```bash\ngit clone <url-du-repo>\ncd crowbot-gestion-v2\n```\n\n2. **Installez les d√©pendances**\n```bash\npip install discord.py\n```\n\n3. **Configurez le bot**\n   - Cr√©ez une application Discord sur [Discord Developer Portal](https://discord.com/developers/applications)\n   - R√©cup√©rez le token du bot\n   - Configurez les variables d'environnement\n\n4. **Lancez le bot**\n```bash\npython main.py\n```\n\n## ‚öôÔ∏è Configuration\n\n### Variables d'environnement\n\nCr√©ez un fichier `.env` ou d√©finissez les variables suivantes :\n\n```env\nDISCORD_TOKEN=votre_token_discord_ici\n```\n\n### Permissions Discord requises\n\nLe bot n√©cessite les permissions suivantes :\n- `G√©rer les r√¥les`\n- `Expulser des membres`\n- `Bannir des membres` \n- `G√©rer les messages`\n- `G√©rer les salons`\n- `Lire l'historique des messages`\n- `Mentionner tout le monde`\n\n### Intents requis\n\n```python\nintents.message_content = True\nintents.members = True\nintents.guilds = True\n```\n\n## üìÅ Structure du projet\n\n```\ncrowbot-gestion-v2/\n‚îú‚îÄ‚îÄ main.py                 # Point d'entr√©e principal\n‚îú‚îÄ‚îÄ bot.py                  # Classe principale du bot\n‚îú‚îÄ‚îÄ config.py               # Configuration et constantes\n‚îú‚îÄ‚îÄ database.py             # Gestion de la base de donn√©es SQLite\n‚îú‚îÄ‚îÄ cogs/                   # Modules de commandes\n‚îÇ   ‚îú‚îÄ‚îÄ administration.py   # Commandes d'administration\n‚îÇ   ‚îú‚îÄ‚îÄ moderation.py      # Commandes de mod√©ration\n‚îÇ   ‚îú‚îÄ‚îÄ roles.py           # Gestion des r√¥les\n‚îÇ   ‚îî‚îÄ‚îÄ help.py            # Syst√®me d'aide\n‚îú‚îÄ‚îÄ utils/                  # Utilitaires\n‚îÇ   ‚îú‚îÄ‚îÄ permissions.py     # Syst√®me de permissions\n‚îÇ   ‚îú‚îÄ‚îÄ helpers.py         # Fonctions d'aide\n‚îÇ   ‚îî‚îÄ‚îÄ converters.py      # Convertisseurs personnalis√©s\n‚îú‚îÄ‚îÄ crowbot.db             # Base de donn√©es SQLite (auto-cr√©√©e)\n‚îú‚îÄ‚îÄ crowbot.log            # Fichier de logs\n‚îî‚îÄ‚îÄ README.md              # Ce fichier\n```\n\n## üìö Commandes disponibles\n\n### üéõÔ∏è Administration\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `setperm` | Attribuer une permission | `+setperm <commande> <r√¥le>` |\n| `unsetperm` | Retirer une permission | `+unsetperm <commande> <r√¥le>` |\n| `perms` | Voir toutes les permissions | `+perms` |\n| `resetperms` | R√©initialiser les permissions | `+resetperms` |\n| `cooldown` | D√©finir un d√©lai d'attente | `+cooldown <commande> <secondes>` |\n| `settings` | Voir les param√®tres du serveur | `+settings` |\n| `prefix` | Changer le pr√©fixe | `+prefix <nouveau_pr√©fixe>` |\n\n### üî® Mod√©ration\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `ban` | Bannir un membre | `+ban <membre> [raison]` |\n| `unban` | D√©bannir un utilisateur | `+unban <id_utilisateur>` |\n| `kick` | Expulser un membre | `+kick <membre> [raison]` |\n| `mute` | Rendre muet un membre | `+mute <membre> [dur√©e] [raison]` |\n| `unmute` | Enlever le mute | `+unmute <membre>` |\n| `warn` | Avertir un membre | `+warn <membre> [raison]` |\n| `infractions` | Voir l'historique d'un membre | `+infractions <membre>` |\n| `mutelist` | Liste des membres mu√©s | `+mutelist` |\n| `clear` | Supprimer des messages | `+clear <nombre>` |\n| `lock` | Verrouiller un salon | `+lock [#salon]` |\n| `unlock` | D√©verrouiller un salon | `+unlock [#salon]` |\n\n### üëë Gestion des r√¥les\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `addrole` | Ajouter un r√¥le √† un membre | `+addrole <membre> <r√¥le>` |\n| `delrole` | Retirer un r√¥le d'un membre | `+delrole <membre> <r√¥le>` |\n| `createrole` | Cr√©er un nouveau r√¥le | `+createrole <nom> [couleur] [permissions]` |\n| `deleterole` | Supprimer un r√¥le | `+deleterole <r√¥le>` |\n| `rolestats` | Statistiques d'un r√¥le | `+rolestats <r√¥le>` |\n\n### üìö Aide\n\n| Commande | Description | Usage |\n|----------|-------------|--------|\n| `help` | Menu d'aide principal | `+help [cat√©gorie]` |\n| `help administration` | Aide administration | `+help administration` |\n| `help moderation` | Aide mod√©ration | `+help moderation` |\n| `help roles` | Aide gestion des r√¥les | `+help roles` |\n\n## üîí Permissions et s√©curit√©\n\n### Syst√®me de permissions hi√©rarchique\n\n1. **Propri√©taire du bot** : Acc√®s total\n2. **Propri√©taire du serveur** : Acc√®s total sur son serveur  \n3. **Administrateurs** : Commandes d'administration et mod√©ration\n4. **R√¥les personnalis√©s** : Selon configuration avec `setperm`\n\n### Protections int√©gr√©es\n\n- ‚úÖ V√©rification de la hi√©rarchie des r√¥les\n- ‚úÖ Impossibilit√© d'auto-mod√©ration\n- ‚úÖ Protection des r√¥les syst√®me\n- ‚úÖ Validation des permissions Discord\n- ‚úÖ Logs complets de toutes les actions\n\n### Format des dur√©es\n\nPour les commandes temporaires (mute) :\n- `10s` = 10 secondes\n- `5m` = 5 minutes  \n- `2h` = 2 heures\n- `1d` = 1 jour\n- `1w` = 1 semaine\n\n### Couleurs disponibles pour les r√¥les\n\n**Noms pr√©d√©finis :**\n`rouge`, `bleu`, `vert`, `jaune`, `orange`, `violet`, `rose`, `cyan`, `noir`, `blanc`\n\n**Format hexad√©cimal :**\n`#FF0000`, `#00FF00`, `#0000FF`, etc.\n\n## üèóÔ∏è Architecture du code\n\n### Composants principaux\n\n#### `main.py`\nPoint d'entr√©e du bot qui :\n- Configure les logs\n- R√©cup√®re le token\n- Lance le bot avec gestion des erreurs\n\n#### `bot.py` - Classe CrowBot\nClasse principale h√©ritant de `commands.Bot` :\n- Configuration des intents\n- Gestion des pr√©fixes dynamiques\n- Chargement des cogs\n- Gestion globale des erreurs\n- Syst√®me de permissions personnalis√©\n\n#### `database.py` - Gestion des donn√©es\nClasse Database avec SQLite :\n- Tables : guilds, permissions, cooldowns, infractions, mutes, logs\n- Op√©rations asynchrones avec verrous\n- M√©thodes CRUD compl√®tes\n\n#### `config.py` - Configuration\nCentralise toutes les configurations :\n- Couleurs des embeds\n- Listes de commandes par cat√©gorie\n- Unit√©s de temps\n- Pr√©fixe par d√©faut\n\n### Structure des Cogs\n\nChaque cog repr√©sente une cat√©gorie de fonctionnalit√©s :\n\n```python\nclass MonCog(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command()\n    @has_permission()  # D√©corateur de permissions\n    async def ma_commande(self, ctx, arg: CustomConverter):\n        # Logique de la commande\n        pass\n```\n\n### Syst√®me de permissions\n\n#### D√©corateurs disponibles\n\n```python\n@has_permission()    # V√©rifie permissions + cooldown\n@admin_only()        # Administrateurs uniquement\n```\n\n#### Convertisseurs personnalis√©s\n\n```python\nMemberConverter     # Membre par nom/mention/ID\nRoleConverter       # R√¥le par nom/mention/ID  \nUserConverter       # Utilisateur par nom/ID\n```\n\n## üõ†Ô∏è Guide de d√©veloppement\n\n### Ajouter une nouvelle commande\n\n1. **Choisir le cog appropri√©** ou cr√©er un nouveau\n2. **D√©finir la commande avec d√©corateurs**\n3. **Impl√©menter la logique m√©tier**\n4. **Ajouter les v√©rifications de s√©curit√©**\n5. **Logger l'action si n√©cessaire**\n6. **Mettre √† jour l'aide**\n\n#### Exemple complet\n\n```python\n@commands.command(name=\"macommande\")\n@has_permission()\nasync def ma_commande(self, ctx, membre: MemberConverter, *, raison: str = \"Aucune raison\"):\n    \"\"\"Description de ma commande\"\"\"\n    \n    # V√©rifications de s√©curit√©\n    if membre == ctx.author:\n        embed = discord.Embed(\n            title=\"‚ùå Erreur\",\n            description=\"Vous ne pouvez pas vous cibler vous-m√™me.\",\n            color=self.bot.config.error_color\n        )\n        await ctx.send(embed=embed)\n        return\n    \n    try:\n        # Logique principale\n        # ... votre code ici ...\n        \n        # Log de l'action\n        await self.bot.db.log_moderation_action(\n            ctx.guild.id, membre.id, ctx.author.id, \"macommande\", raison\n        )\n        \n        # Confirmation\n        embed = discord.Embed(\n            title=\"‚úÖ Succ√®s\",\n            description=f\"Action r√©alis√©e sur **{membre}**.\",\n            color=self.bot.config.success_color\n        )\n        embed.add_field(name=\"Raison\", value=raison, inline=False)\n        await ctx.send(embed=embed)\n        \n    except Exception as e:\n        embed = discord.Embed(\n            title=\"‚ùå Erreur\",\n            description=f\"√âchec de l'op√©ration : {str(e)}\",\n            color=self.bot.config.error_color\n        )\n        await ctx.send(embed=embed)\n```\n\n### Ajouter un nouveau cog\n\n1. **Cr√©er le fichier** `cogs/mon_cog.py`\n2. **Impl√©menter la classe** h√©ritant de `commands.Cog`\n3. **Ajouter la fonction setup**\n4. **Charger dans bot.py**\n5. **Mettre √† jour l'aide**\n\n#### Template de cog\n\n```python\nimport discord\nfrom discord.ext import commands\nfrom utils.permissions import has_permission\nfrom utils.converters import MemberConverter\n\nclass MonCog(commands.Cog):\n    \"\"\"Description de mon cog\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"test\")\n    @has_permission()\n    async def test_command(self, ctx):\n        \"\"\"Commande de test\"\"\"\n        await ctx.send(\"Commande test fonctionnelle !\")\n\nasync def setup(bot):\n    await bot.add_cog(MonCog(bot))\n```\n\n### √âtendre la base de donn√©es\n\nPour ajouter une nouvelle table :\n\n```python\n# Dans database.py, m√©thode initialize()\ncursor.execute('''\n    CREATE TABLE IF NOT EXISTS ma_table (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        guild_id INTEGER,\n        user_id INTEGER,\n        data TEXT,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n''')\n```\n\nAjouter les m√©thodes CRUD correspondantes.\n\n### Tests et debugging\n\n#### Logs disponibles\n\n```python\nself.bot.logger.info(\"Message d'information\")\nself.bot.logger.warning(\"Avertissement\")\nself.bot.logger.error(\"Erreur\")\n```\n\nLes logs sont √©crits dans `crowbot.log` et la console.\n\n#### Variables d'environnement de debug\n\n```env\nDISCORD_TOKEN=votre_token\nDEBUG=1  # Active le mode debug (optionnel)\n```\n\n## üîß Troubleshooting\n\n### Probl√®mes courants\n\n#### Le bot ne se connecte pas\n- V√©rifiez le token Discord\n- V√©rifiez les intents dans le Developer Portal\n- V√©rifiez que le bot a √©t√© invit√© sur le serveur\n\n#### Commandes ne fonctionnent pas\n- V√©rifiez le pr√©fixe configur√© (`+settings`)\n- V√©rifiez les permissions Discord du bot\n- V√©rifiez les permissions personnalis√©es (`+perms`)\n\n#### Erreurs de base de donn√©es\n- V√©rifiez les permissions d'√©criture du dossier\n- Supprimez `crowbot.db` pour r√©initialiser (‚ö†Ô∏è perte de donn√©es)\n\n#### Erreurs de permissions\n- V√©rifiez la position du r√¥le du bot\n- V√©rifiez que le bot a les permissions Discord n√©cessaires\n- V√©rifiez la hi√©rarchie des r√¥les\n\n### Messages d'erreur fr√©quents\n\n#### \"Membre introuvable\"\nL'utilisateur saisi n'existe pas sur le serveur ou le nom est incorrect.\n\n#### \"R√¥le introuvable\"  \nLe r√¥le saisi n'existe pas ou le nom est incorrect.\n\n#### \"Permission insuffisante\"\nLe bot n'a pas les permissions Discord n√©cessaires pour cette action.\n\n#### \"Argument requis manquant\"\nUne commande a √©t√© utilis√©e sans tous ses arguments obligatoires.\n\n### Commandes de diagnostic\n\n```bash\n# V√©rifier les permissions\n+settings\n\n# Voir les permissions personnalis√©es\n+perms\n\n# Tester une commande simple\n+help\n```\n\n## üìù Changelog\n\n### Version 2.0\n- ‚úÖ Syst√®me de gestion des r√¥les complet\n- ‚úÖ Convertisseurs personnalis√©s pour noms/mentions/IDs\n- ‚úÖ Messages d'erreur en fran√ßais\n- ‚úÖ Commande help avec menu par cat√©gories\n- ‚úÖ Am√©lioration du syst√®me de permissions\n- ‚úÖ Logs d√©taill√©s de toutes les actions\n\n### Version 1.0\n- ‚úÖ Syst√®me de mod√©ration complet\n- ‚úÖ Gestion des permissions par r√¥le\n- ‚úÖ Base de donn√©es SQLite\n- ‚úÖ Syst√®me d'infractions et mutes\n- ‚úÖ Configuration par serveur\n\n## üìÑ License\n\nCe projet est sous licence MIT. Voir le fichier `LICENSE` pour plus de d√©tails.\n\n## ü§ù Contribuer\n\nLes contributions sont les bienvenues ! \n\n1. **Fork** le projet\n2. **Cr√©er** une branche feature (`git checkout -b feature/AmazingFeature`)\n3. **Commit** vos changements (`git commit -m 'Add AmazingFeature'`)\n4. **Push** vers la branche (`git push origin feature/AmazingFeature`)\n5. **Ouvrir** une Pull Request\n\n### Guidelines de contribution\n\n- Respecter le style de code existant\n- Ajouter des tests pour les nouvelles fonctionnalit√©s\n- Mettre √† jour la documentation\n- S'assurer que tous les tests passent\n\n## üìû Support\n\nPour obtenir de l'aide :\n\n1. Consulter ce README\n2. V√©rifier les [Issues GitHub](lien-vers-issues)\n3. Utiliser la commande `+help` dans Discord\n4. Consulter les logs dans `crowbot.log`\n\n---\n\n**D√©velopp√© avec ‚ù§Ô∏è en Python | Powered by discord.py**","size_bytes":14402},"bot.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nimport logging\nfrom database import Database\nfrom config import Config\n\nclass CrowBot(commands.Bot):\n    def __init__(self):\n        # Initialize with default prefix, will be updated from database\n        intents = discord.Intents.default()\n        intents.message_content = True\n        intents.members = True\n        intents.guilds = True\n        \n        super().__init__(\n            command_prefix=self.get_prefix,\n            intents=intents,\n            help_command=None\n        )\n        \n        self.db = Database()\n        self.config = Config()\n        self.logger = logging.getLogger('CrowBot')\n        \n    async def get_prefix(self, message):\n        \"\"\"Get the prefix for a guild\"\"\"\n        if message.guild is None:\n            return self.config.default_prefix\n        \n        prefix = await self.db.get_guild_prefix(message.guild.id)\n        return prefix or self.config.default_prefix\n    \n    async def setup_hook(self):\n        await self.db.initialize()\n        cogs = [\n            'cogs.administration',\n            'cogs.moderation',\n            'cogs.roles',\n            'cogs.help_interactive',\n            'cogs.triggers',\n            'cogs.ownership'\n        ]\n\n        for cog in cogs:\n            if cog not in self.extensions:  # ‚Üê emp√™che le rechargement\n                try:\n                    await self.load_extension(cog)\n                    self.logger.info(f\"Loaded cog: {cog}\")\n                except Exception as e:\n                    self.logger.error(f\"Failed to load cog {cog}: {e}\")\n    \n    async def on_ready(self):\n        \"\"\"Called when the bot is ready\"\"\"\n        self.logger.info(f'{self.user.name if self.user else \"Bot\"} has connected to Discord!')\n        self.logger.info(f'Bot is in {len(self.guilds)} guilds')\n        \n        # Set bot status\n        await self.change_presence(\n            activity=discord.Activity(\n                type=discord.ActivityType.watching,\n                name=\"for infractions | +help\"\n            )\n        )\n    \n    async def on_guild_join(self, guild):\n        \"\"\"Called when the bot joins a new guild\"\"\"\n        self.logger.info(f\"Joined guild: {guild.name} (ID: {guild.id})\")\n        await self.db.setup_guild(guild.id)\n    \n    async def on_command_error(self, ctx, error):\n        \"\"\"Global error handler\"\"\"\n        if isinstance(error, commands.CommandNotFound):\n            return\n        \n        if isinstance(error, commands.MissingPermissions):\n            await ctx.send(\"‚ùå Vous n'avez pas la permission d'utiliser cette commande.\")\n            return\n        \n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send(f\"‚ùå Argument requis manquant : `{error.param.name}`\")\n            return\n        \n        if isinstance(error, commands.BadArgument):\n            await ctx.send(f\"‚ùå Argument invalide : {error}\")\n            return\n        \n        if isinstance(error, commands.CommandOnCooldown):\n            await ctx.send(f\"‚ùå Commande en cooldown. R√©essayez dans {error.retry_after:.2f} secondes.\")\n            return\n        \n        # Handle custom converter errors\n        if isinstance(error, commands.MemberNotFound):\n            await ctx.send(f\"‚ùå {error}\")\n            return\n        \n        if isinstance(error, commands.RoleNotFound):\n            await ctx.send(f\"‚ùå {error}\")\n            return\n        \n        if isinstance(error, commands.UserNotFound):\n            await ctx.send(f\"‚ùå {error}\")\n            return\n        \n        self.logger.error(f\"Unhandled error in command {ctx.command}: {error}\")\n        await ctx.send(\"‚ùå Une erreur inattendue s'est produite lors du traitement de la commande.\")\n    \n    async def check_permissions(self, ctx, command_name):\n        \"\"\"Check if user has permission to use a command\"\"\"\n        # Bot owner always has permission\n        if await self.is_owner(ctx.author):\n            return True\n        \n        # Server owner always has permission\n        if ctx.author == ctx.guild.owner:\n            return True\n        \n        # Check custom permissions\n        user_roles = [role.id for role in ctx.author.roles]\n        allowed_roles = await self.db.get_command_permissions(ctx.guild.id, command_name)\n        \n        if allowed_roles:\n            return any(role_id in allowed_roles for role_id in user_roles)\n        \n        # Default: only administrators can use moderation commands\n        moderation_commands = [\n            'ban', 'unban', 'kick', 'mute', 'unmute', 'warn', 'clear', \n            'lock', 'unlock', 'setperm', 'unsetperm', 'resetperms'\n        ]\n        \n        if command_name in moderation_commands:\n            return ctx.author.guild_permissions.administrator\n        \n        return True\n    \n    async def check_cooldown(self, ctx, command_name):\n        \"\"\"Check if command is on cooldown for user\"\"\"\n        cooldown_time = await self.db.get_command_cooldown(ctx.guild.id, command_name)\n        if not cooldown_time:\n            return True\n        \n        last_used = await self.db.get_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n        if not last_used:\n            await self.db.update_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n            return True\n        \n        import time\n        if time.time() - last_used < cooldown_time:\n            return False\n        \n        await self.db.update_last_command_use(ctx.guild.id, ctx.author.id, command_name)\n        return True\n","size_bytes":5538},"config.py":{"content":"class Config:\n    def __init__(self):\n        self.default_prefix = \"+\"\n        self.bot_description = \"CrowBot Gestion V2 - Discord Moderation Bot\"\n        self.embed_color = 0x2F3136\n        self.error_color = 0xFF0000\n        self.success_color = 0x00FF00\n        self.warning_color = 0xFFFF00\n        \n        # Command categories\n        self.moderation_commands = [\n            'ban', 'unban', 'kick', 'mute', 'unmute', 'warn', \n            'clear', 'lock', 'unlock', 'infractions', 'mutelist'\n        ]\n        \n        self.admin_commands = [\n            'setperm', 'unsetperm', 'perms', 'resetperms', \n            'cooldown', 'settings', 'prefix'\n        ]\n        \n        # Time parsing formats\n        self.time_units = {\n            's': 1,\n            'm': 60,\n            'h': 3600,\n            'd': 86400,\n            'w': 604800\n        }\n","size_bytes":856},"database.py":{"content":"import sqlite3\nimport asyncio\nimport json\nimport time\nimport secrets\nfrom typing import List, Optional, Dict, Any\n\nclass Database:\n    def __init__(self, db_path: str = \"crowbot.db\"):\n        self.db_path = db_path\n        self._lock = asyncio.Lock()\n    \n    async def initialize(self):\n        \"\"\"Initialize the database with required tables\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            # Guild settings table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS guild_settings (\n                    guild_id INTEGER PRIMARY KEY,\n                    prefix TEXT DEFAULT '+',\n                    log_channel_id INTEGER,\n                    mute_role_id INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Command permissions table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_permissions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    command_name TEXT,\n                    role_id INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, command_name, role_id)\n                )\n            ''')\n            \n            # Command cooldowns table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_cooldowns (\n                    guild_id INTEGER,\n                    command_name TEXT,\n                    cooldown_seconds INTEGER,\n                    PRIMARY KEY(guild_id, command_name)\n                )\n            ''')\n            \n            # Command usage tracking\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS command_usage (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    command_name TEXT,\n                    last_used TIMESTAMP,\n                    PRIMARY KEY(guild_id, user_id, command_name)\n                )\n            ''')\n            \n            # Infractions table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS infractions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    moderator_id INTEGER,\n                    infraction_type TEXT,\n                    reason TEXT,\n                    duration INTEGER,\n                    active BOOLEAN DEFAULT 1,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Muted users table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS muted_users (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    muted_until TIMESTAMP,\n                    reason TEXT,\n                    moderator_id INTEGER,\n                    PRIMARY KEY(guild_id, user_id)\n                )\n            ''')\n            \n            # Moderation logs\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS moderation_logs (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    moderator_id INTEGER,\n                    action TEXT,\n                    reason TEXT,\n                    details TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Bot ownership tables\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS bot_ownership (\n                    guild_id INTEGER PRIMARY KEY,\n                    buyer_id INTEGER,\n                    recovery_code TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            ''')\n            \n            # Owners table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS owners (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Whitelist table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS whitelist (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Blacklist rank table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS blacklist_rank (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    added_by INTEGER,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(guild_id, user_id)\n                )\n            ''')\n            \n            # Leash system table\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS leash_system (\n                    guild_id INTEGER,\n                    user_id INTEGER,\n                    owner_id INTEGER,\n                    original_nick TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    PRIMARY KEY(guild_id, user_id)\n                )\n            ''')\n            \n            conn.commit()\n            conn.close()\n    \n    # Extensions from database_extensions.py\n    # Bot Ownership methods\n    async def set_buyer(self, guild_id: int, buyer_id: int) -> str:\n        \"\"\"Set the buyer/owner of the bot for a guild and generate recovery code\"\"\"\n        recovery_code = secrets.token_hex(16)\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO bot_ownership (guild_id, buyer_id, recovery_code)\n                VALUES (?, ?, ?)\n            ''', (guild_id, buyer_id, recovery_code))\n            \n            conn.commit()\n            conn.close()\n            \n        return recovery_code\n    \n    async def get_buyer(self, guild_id: int) -> Optional[int]:\n        \"\"\"Get the buyer ID for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT buyer_id FROM bot_ownership WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def verify_recovery_code(self, guild_id: int, code: str) -> bool:\n        \"\"\"Verify recovery code for buyer transfer\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT recovery_code FROM bot_ownership WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result and result[0] == code\n    \n    # Owners methods\n    async def add_owner(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO owners (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_owner(self, guild_id: int, user_id: int):\n        \"\"\"Remove an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM owners WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_owner(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is an owner\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM owners WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_owners(self, guild_id: int) -> List[int]:\n        \"\"\"Get all owners for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM owners WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Whitelist methods\n    async def add_whitelist(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add user to whitelist\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO whitelist (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_whitelist(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from whitelist\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM whitelist WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_whitelisted(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is whitelisted\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM whitelist WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_whitelist(self, guild_id: int) -> List[int]:\n        \"\"\"Get all whitelisted users\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM whitelist WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Blacklist rank methods\n    async def add_blacklist_rank(self, guild_id: int, user_id: int, added_by: int):\n        \"\"\"Add user to blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO blacklist_rank (guild_id, user_id, added_by)\n                VALUES (?, ?, ?)\n            ''', (guild_id, user_id, added_by))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_blacklist_rank(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM blacklist_rank WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def is_blacklist_rank(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is in blacklist rank\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM blacklist_rank WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def get_blacklist_rank(self, guild_id: int) -> List[int]:\n        \"\"\"Get all blacklisted rank users\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id FROM blacklist_rank WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    # Leash system methods\n    async def add_leash(self, guild_id: int, user_id: int, owner_id: int, original_nick: str):\n        \"\"\"Put user on leash\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO leash_system (guild_id, user_id, owner_id, original_nick)\n                VALUES (?, ?, ?, ?)\n            ''', (guild_id, user_id, owner_id, original_nick))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_leash(self, guild_id: int, user_id: int):\n        \"\"\"Remove user from leash\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM leash_system WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_leash_info(self, guild_id: int, user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get leash info for user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT owner_id, original_nick FROM leash_system \n                WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            if result:\n                return {\n                    'owner_id': result[0],\n                    'original_nick': result[1]\n                }\n            return None\n    \n    async def is_leashed(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is leashed\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT 1 FROM leash_system WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return bool(result)\n    \n    async def setup_guild(self, guild_id: int):\n        \"\"\"Setup a new guild in the database\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO guild_settings (guild_id) VALUES (?)\n            ''', (guild_id,))\n            \n            conn.commit()\n            conn.close()\n    \n    # Guild settings methods\n    async def get_guild_prefix(self, guild_id: int) -> Optional[str]:\n        \"\"\"Get the prefix for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT prefix FROM guild_settings WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def set_guild_prefix(self, guild_id: int, prefix: str):\n        \"\"\"Set the prefix for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO guild_settings (guild_id, prefix) VALUES (?, ?)\n            ''', (guild_id, prefix))\n            \n            conn.commit()\n            conn.close()\n    \n    # Permission methods\n    async def set_command_permission(self, guild_id: int, command_name: str, role_id: int):\n        \"\"\"Set permission for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR IGNORE INTO command_permissions (guild_id, command_name, role_id) \n                VALUES (?, ?, ?)\n            ''', (guild_id, command_name, role_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_command_permission(self, guild_id: int, command_name: str, role_id: int):\n        \"\"\"Remove permission for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM command_permissions \n                WHERE guild_id = ? AND command_name = ? AND role_id = ?\n            ''', (guild_id, command_name, role_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_command_permissions(self, guild_id: int, command_name: str) -> List[int]:\n        \"\"\"Get allowed roles for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT role_id FROM command_permissions \n                WHERE guild_id = ? AND command_name = ?\n            ''', (guild_id, command_name))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            return [result[0] for result in results]\n    \n    async def get_all_permissions(self, guild_id: int) -> Dict[str, List[int]]:\n        \"\"\"Get all command permissions for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT command_name, role_id FROM command_permissions \n                WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            permissions = {}\n            for command_name, role_id in results:\n                if command_name not in permissions:\n                    permissions[command_name] = []\n                permissions[command_name].append(role_id)\n            \n            return permissions\n    \n    async def reset_permissions(self, guild_id: int):\n        \"\"\"Reset all permissions for a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM command_permissions WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            conn.commit()\n            conn.close()\n    \n    # Cooldown methods\n    async def set_command_cooldown(self, guild_id: int, command_name: str, cooldown_seconds: int):\n        \"\"\"Set cooldown for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO command_cooldowns (guild_id, command_name, cooldown_seconds) \n                VALUES (?, ?, ?)\n            ''', (guild_id, command_name, cooldown_seconds))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_command_cooldown(self, guild_id: int, command_name: str) -> Optional[int]:\n        \"\"\"Get cooldown for a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT cooldown_seconds FROM command_cooldowns \n                WHERE guild_id = ? AND command_name = ?\n            ''', (guild_id, command_name))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return result[0] if result else None\n    \n    async def get_last_command_use(self, guild_id: int, user_id: int, command_name: str) -> Optional[float]:\n        \"\"\"Get last time user used a command\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT last_used FROM command_usage \n                WHERE guild_id = ? AND user_id = ? AND command_name = ?\n            ''', (guild_id, user_id, command_name))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            return float(result[0]) if result else None\n    \n    async def update_last_command_use(self, guild_id: int, user_id: int, command_name: str):\n        \"\"\"Update last command use time\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO command_usage (guild_id, user_id, command_name, last_used) \n                VALUES (?, ?, ?, ?)\n            ''', (guild_id, user_id, command_name, time.time()))\n            \n            conn.commit()\n            conn.close()\n    \n    # Infraction methods\n    async def add_infraction(self, guild_id: int, user_id: int, moderator_id: int, \n                           infraction_type: str, reason: Optional[str] = None, duration: Optional[int] = None):\n        \"\"\"Add an infraction\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT INTO infractions (guild_id, user_id, moderator_id, infraction_type, reason, duration) \n                VALUES (?, ?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, moderator_id, infraction_type, reason, duration))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_user_infractions(self, guild_id: int, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all infractions for a user\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT infraction_type, reason, duration, created_at, moderator_id \n                FROM infractions \n                WHERE guild_id = ? AND user_id = ? \n                ORDER BY created_at DESC\n            ''', (guild_id, user_id))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            infractions = []\n            for result in results:\n                infractions.append({\n                    'type': result[0],\n                    'reason': result[1],\n                    'duration': result[2],\n                    'created_at': result[3],\n                    'moderator_id': result[4]\n                })\n            \n            return infractions\n    \n    # Mute methods\n    async def add_mute(self, guild_id: int, user_id: int, muted_until: Optional[float], \n                      reason: str, moderator_id: int):\n        \"\"\"Add a mute\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT OR REPLACE INTO muted_users (guild_id, user_id, muted_until, reason, moderator_id) \n                VALUES (?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, muted_until, reason, moderator_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def remove_mute(self, guild_id: int, user_id: int):\n        \"\"\"Remove a mute\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                DELETE FROM muted_users WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            conn.commit()\n            conn.close()\n    \n    async def get_muted_users(self, guild_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all muted users in a guild\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT user_id, muted_until, reason, moderator_id \n                FROM muted_users WHERE guild_id = ?\n            ''', (guild_id,))\n            \n            results = cursor.fetchall()\n            conn.close()\n            \n            muted_users = []\n            for result in results:\n                muted_users.append({\n                    'user_id': result[0],\n                    'muted_until': result[1],\n                    'reason': result[2],\n                    'moderator_id': result[3]\n                })\n            \n            return muted_users\n    \n    async def is_user_muted(self, guild_id: int, user_id: int) -> bool:\n        \"\"\"Check if user is muted\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                SELECT muted_until FROM muted_users \n                WHERE guild_id = ? AND user_id = ?\n            ''', (guild_id, user_id))\n            \n            result = cursor.fetchone()\n            conn.close()\n            \n            if not result:\n                return False\n            \n            muted_until = result[0]\n            if muted_until and float(muted_until) < time.time():\n                await self.remove_mute(guild_id, user_id)\n                return False\n            \n            return True\n    \n    # Logging methods\n    async def log_moderation_action(self, guild_id: int, user_id: int, moderator_id: int, \n                                  action: str, reason: Optional[str] = None, details: Optional[str] = None):\n        \"\"\"Log a moderation action\"\"\"\n        async with self._lock:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n            \n            cursor.execute('''\n                INSERT INTO moderation_logs (guild_id, user_id, moderator_id, action, reason, details) \n                VALUES (?, ?, ?, ?, ?, ?)\n            ''', (guild_id, user_id, moderator_id, action, reason, details))\n            \n            conn.commit()\n            conn.close()\n    \n","size_bytes":27802},"main.py":{"content":"import asyncio\nimport logging\nimport os\nfrom bot import CrowBot\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('crowbot.log'),\n        logging.StreamHandler()\n    ]\n)\n\nasync def main():\n    \"\"\"Main entry point for the bot\"\"\"\n    token = os.getenv('DISCORD_TOKEN')\n    if not token:\n        logging.error(\"DISCORD_TOKEN environment variable not set!\")\n        return\n    \n    bot = CrowBot()\n    \n    try:\n        await bot.start(token)\n    except KeyboardInterrupt:\n        logging.info(\"Bot stopped by user\")\n    except Exception as e:\n        logging.error(f\"Bot encountered an error: {e}\")\n    finally:\n        await bot.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":813},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"discord-py>=2.6.2\",\n]\n","size_bytes":169},"replit.md":{"content":"# CrowBot Gestion V2 - Discord Bot\n\n## Overview\nCrowBot est un bot Discord de mod√©ration avanc√©e avec syst√®me de gestion hi√©rarchique et fonctionnalit√©s anti-raid. Le bot utilise Python avec discord.py et une base de donn√©es SQLite pour la persistance.\n\n## Recent Changes (25 ao√ªt 2025)\n- ‚úÖ Migration vers Replit compl√©t√©e\n- ‚úÖ Nouvelles commandes ownership/administration avanc√©es ajout√©es\n- ‚úÖ Syst√®me de buyers/owners impl√©ment√©\n- ‚úÖ Syst√®me de whitelist/blacklist ajout√©\n- ‚úÖ Syst√®me de \"laisse\" pour contr√¥ler les pseudos\n- ‚úÖ Commandes de communication anonyme (say, dm)\n- ‚úÖ R√©ponses simplifi√©es pour commandes principales\n- ‚úÖ Commande massrole pour attribution de r√¥les en masse\n\n## Project Architecture\n\n### Core Files\n- `main.py` - Point d'entr√©e principal\n- `bot.py` - Classe principale du bot\n- `database.py` - Gestion de la base de donn√©es SQLite\n- `config.py` - Configuration du bot\n\n### Cogs (Modules)\n- `cogs/administration.py` - Commandes d'administration\n- `cogs/moderation.py` - Commandes de mod√©ration\n- `cogs/roles.py` - Gestion des r√¥les\n- `cogs/help.py` - Syst√®me d'aide\n- `cogs/triggers.py` - Syst√®me de triggers/r√©ponses automatiques\n- `cogs/ownership.py` - **NOUVEAU** Commandes avanc√©es ownership\n\n### Utilities\n- `utils/permissions.py` - Syst√®me de permissions\n- `utils/helpers.py` - Fonctions utilitaires\n- `utils/converters.py` - Convertisseurs Discord\n\n## User Preferences\n- R√©ponses simplifi√©es pr√©f√©r√©es pour les commandes de base\n- Interface en fran√ßais\n- Messages d'erreur clairs et concis\n\n## Database Schema\n- Tables existantes : guild_settings, command_permissions, command_cooldowns, command_usage, infractions, muted_users, moderation_logs\n- **Nouvelles tables** : bot_ownership, owners, whitelist, blacklist_rank, leash_system\n\n## Nouvelles Fonctionnalit√©s Impl√©ment√©es\n\n### Syst√®me Hi√©rarchique\n- **buyer** : Propri√©taire principal du bot avec code de r√©cup√©ration\n- **owners** : Utilisateurs avec privil√®ges √©tendus\n- **whitelist** : Utilisateurs immunis√©s contre l'anti-raid\n\n### Commandes Ownership (Owners uniquement)\n- `massrole` - Attribution de r√¥les en masse aux humains\n- `say` - Communication anonyme via le bot\n- `dm` - Messages priv√©s via le bot  \n- `laisse/unlaisse` - Contr√¥le des pseudos avec √©mojis üê∂ü¶Æ\n- `wl/unwl` - Gestion whitelist\n- `blrank add/del` - Gestion blacklist-rank\n\n### Commandes Buyer (Propri√©taire uniquement)\n- `owner/unowner` - Gestion des owners\n- `buyer` - Transfert de propri√©t√© avec code de r√©cup√©ration\n\n### R√©ponses Simplifi√©es\nLes commandes suivantes ont maintenant des r√©ponses simplifi√©es sans embeds :\n- addrole, delrole, warn, clear, mute, unmute, setperm, unsetperm\n\n## Configuration Requise\n- Python 3.11+\n- discord.py >= 2.6.2\n- Variable d'environnement DISCORD_TOKEN requise\n\n## Status\n‚úÖ Bot op√©rationnel et pr√™t √† l'emploi\n‚úÖ Migration Replit termin√©e\n‚úÖ Toutes les nouvelles fonctionnalit√©s impl√©ment√©es","size_bytes":2982},"cogs/administration.py":{"content":"import discord\nfrom discord.ext import commands\nfrom utils.permissions import has_permission, admin_only\nfrom utils.helpers import parse_time, format_time\nfrom utils.converters import RoleConverter\n\nclass Administration(commands.Cog):\n    \"\"\"Administration and configuration commands\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"setperm\")\n    @admin_only()\n    async def set_permission(self, ctx, command_name: str, role: RoleConverter):\n        \"\"\"Set permission for a command to a role\"\"\"\n        try:\n            await self.bot.db.set_command_permission(ctx.guild.id, command_name.lower(), role.id)\n            \n            await ctx.send(f\"‚úÖ R√¥le {role.mention} peut utiliser `{command_name}`.\")\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"setperm\", \n                f\"Granted {role.name} permission for {command_name}\"\n            )\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to set permission: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"unsetperm\")\n    @admin_only()\n    async def unset_permission(self, ctx, command_name: str, role: RoleConverter):\n        \"\"\"Remove permission for a command from a role\"\"\"\n        try:\n            await self.bot.db.remove_command_permission(ctx.guild.id, command_name.lower(), role.id)\n            \n            await ctx.send(f\"‚úÖ R√¥le {role.mention} ne peut plus utiliser `{command_name}`.\")\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"unsetperm\", \n                f\"Removed {role.name} permission for {command_name}\"\n            )\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to remove permission: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"perms\")\n    @has_permission()\n    async def show_permissions(self, ctx):\n        \"\"\"Show all command permissions for this server\"\"\"\n        try:\n            permissions = await self.bot.db.get_all_permissions(ctx.guild.id)\n            \n            if not permissions:\n                embed = discord.Embed(\n                    title=\"üìã Command Permissions\",\n                    description=\"No custom permissions set. All commands use default permissions.\",\n                    color=self.bot.config.embed_color\n                )\n            else:\n                embed = discord.Embed(\n                    title=\"üìã Command Permissions\",\n                    color=self.bot.config.embed_color\n                )\n                \n                for command_name, role_ids in permissions.items():\n                    roles = []\n                    for role_id in role_ids:\n                        role = ctx.guild.get_role(role_id)\n                        if role:\n                            roles.append(role.mention)\n                    \n                    if roles:\n                        embed.add_field(\n                            name=f\"`{command_name}`\",\n                            value=\", \".join(roles),\n                            inline=False\n                        )\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to retrieve permissions: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"resetperms\")\n    @admin_only()\n    async def reset_permissions(self, ctx):\n        \"\"\"Reset all command permissions to default\"\"\"\n        try:\n            await self.bot.db.reset_permissions(ctx.guild.id)\n            \n            embed = discord.Embed(\n                title=\"‚úÖ Permissions Reset\",\n                description=\"All command permissions have been reset to default.\",\n                color=self.bot.config.success_color\n            )\n            await ctx.send(embed=embed)\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"resetperms\", \n                \"Reset all command permissions\"\n            )\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to reset permissions: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"cooldown\")\n    @admin_only()\n    async def set_cooldown(self, ctx, command_name: str, seconds: int):\n        \"\"\"Set cooldown for a command\"\"\"\n        if seconds < 0:\n            embed = discord.Embed(\n                title=\"‚ùå Invalid Cooldown\",\n                description=\"Cooldown must be a positive number.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            await self.bot.db.set_command_cooldown(ctx.guild.id, command_name.lower(), seconds)\n            \n            embed = discord.Embed(\n                title=\"‚úÖ Cooldown Set\",\n                description=f\"Command `{command_name}` now has a {seconds} second cooldown.\",\n                color=self.bot.config.success_color\n            )\n            await ctx.send(embed=embed)\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"cooldown\", \n                f\"Set {command_name} cooldown to {seconds} seconds\"\n            )\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to set cooldown: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"settings\")\n    @has_permission()\n    async def show_settings(self, ctx):\n        \"\"\"Show current bot settings for this server\"\"\"\n        try:\n            prefix = await self.bot.db.get_guild_prefix(ctx.guild.id) or self.bot.config.default_prefix\n            \n            embed = discord.Embed(\n                title=\"‚öôÔ∏è Server Settings\",\n                color=self.bot.config.embed_color\n            )\n            \n            embed.add_field(\n                name=\"Prefix\",\n                value=f\"`{prefix}`\",\n                inline=True\n            )\n            \n            embed.add_field(\n                name=\"Guild ID\",\n                value=str(ctx.guild.id),\n                inline=True\n            )\n            \n            embed.add_field(\n                name=\"Members\",\n                value=str(ctx.guild.member_count),\n                inline=True\n            )\n            \n            # Check if mute role exists\n            mute_role = discord.utils.get(ctx.guild.roles, name=\"Muted\")\n            embed.add_field(\n                name=\"Mute Role\",\n                value=mute_role.mention if mute_role else \"Not created\",\n                inline=True\n            )\n            \n            embed.set_footer(text=f\"Bot ID: {self.bot.user.id}\")\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to retrieve settings: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"prefix\")\n    @admin_only()\n    async def set_prefix(self, ctx, new_prefix: str):\n        \"\"\"Change the bot prefix for this server\"\"\"\n        if len(new_prefix) > 5:\n            embed = discord.Embed(\n                title=\"‚ùå Invalid Prefix\",\n                description=\"Prefix must be 5 characters or less.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            await self.bot.db.set_guild_prefix(ctx.guild.id, new_prefix)\n            \n            embed = discord.Embed(\n                title=\"‚úÖ Prefix Changed\",\n                description=f\"Bot prefix has been changed to `{new_prefix}`\",\n                color=self.bot.config.success_color\n            )\n            await ctx.send(embed=embed)\n            \n            # Log the action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"prefix\", \n                f\"Changed prefix to {new_prefix}\"\n            )\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to change prefix: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(Administration(bot))\n","size_bytes":9369},"cogs/help.py":{"content":"import discord\nfrom discord.ext import commands\n\nclass HelpCommand(commands.Cog):\n    \"\"\"Syst√®me d'aide du bot\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"help\", aliases=[\"aide\", \"h\"])\n    async def help_command(self, ctx, *, category: str = None):\n        \"\"\"Affiche la liste des commandes disponibles\"\"\"\n        \n        # Si une cat√©gorie sp√©cifique est demand√©e\n        if category:\n            category = category.lower()\n            if category in [\"admin\", \"administration\"]:\n                await self._send_admin_help(ctx)\n            elif category in [\"mod\", \"moderation\", \"mod√©ration\"]:\n                await self._send_moderation_help(ctx)\n            elif category in [\"role\", \"roles\", \"r√¥le\", \"r√¥les\"]:\n                await self._send_roles_help(ctx)\n            else:\n                embed = discord.Embed(\n                    title=\"‚ùå Cat√©gorie introuvable\",\n                    description=\"Cat√©gories disponibles : `administration`, `moderation`, `roles`\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n            return\n        \n        # Menu principal\n        embed = discord.Embed(\n            title=\"üìö CrowBot Gestion V2 - Aide\",\n            description=\"Choisissez une cat√©gorie pour voir les commandes disponibles.\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"üéõÔ∏è Administration\",\n            value=\"`+help administration` - Gestion des permissions et configuration\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"üî® Mod√©ration\", \n            value=\"`+help moderation` - Commandes de mod√©ration des membres\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"üëë Gestion des R√¥les\", \n            value=\"`+help roles` - Commandes de gestion des r√¥les\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"‚ÑπÔ∏è Informations\",\n            value=f\"Pr√©fixe actuel : `+`\\n\"\n                  f\"Serveurs : {len(self.bot.guilds)}\\n\"\n                  f\"Version : 2.0\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"Utilisez +help <cat√©gorie> pour voir les commandes d√©taill√©es\")\n        \n        await ctx.send(embed=embed)\n    \n    async def _send_admin_help(self, ctx):\n        \"\"\"Envoie l'aide pour les commandes d'administration\"\"\"\n        embed = discord.Embed(\n            title=\"üéõÔ∏è Commandes d'Administration\",\n            description=\"Gestion des permissions et configuration du bot\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"setperm\", \"Attribuer une permission\", \"`+setperm <commande> <r√¥le>`\"),\n            (\"unsetperm\", \"Retirer une permission\", \"`+unsetperm <commande> <r√¥le>`\"),\n            (\"perms\", \"Voir toutes les permissions\", \"`+perms`\"),\n            (\"resetperms\", \"R√©initialiser les permissions\", \"`+resetperms`\"),\n            (\"cooldown\", \"D√©finir un d√©lai d'attente\", \"`+cooldown <commande> <secondes>`\"),\n            (\"settings\", \"Voir les param√®tres du serveur\", \"`+settings`\"),\n            (\"prefix\", \"Changer le pr√©fixe\", \"`+prefix <nouveau_pr√©fixe>`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.set_footer(text=\"‚ö†Ô∏è Ces commandes n√©cessitent les permissions d'administrateur\")\n        \n        await ctx.send(embed=embed)\n    \n    async def _send_moderation_help(self, ctx):\n        \"\"\"Envoie l'aide pour les commandes de mod√©ration\"\"\"\n        embed = discord.Embed(\n            title=\"üî® Commandes de Mod√©ration\",\n            description=\"Gestion et mod√©ration des membres\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"ban\", \"Bannir un membre\", \"`+ban <membre> [raison]`\"),\n            (\"unban\", \"D√©bannir un utilisateur\", \"`+unban <id_utilisateur>`\"),\n            (\"kick\", \"Expulser un membre\", \"`+kick <membre> [raison]`\"),\n            (\"mute\", \"Rendre muet un membre\", \"`+mute <membre> [dur√©e] [raison]`\"),\n            (\"unmute\", \"Enlever le mute\", \"`+unmute <membre>`\"),\n            (\"warn\", \"Avertir un membre\", \"`+warn <membre> [raison]`\"),\n            (\"infractions\", \"Voir l'historique d'un membre\", \"`+infractions <membre>`\"),\n            (\"mutelist\", \"Liste des membres mu√©s\", \"`+mutelist`\"),\n            (\"clear\", \"Supprimer des messages\", \"`+clear <nombre>`\"),\n            (\"lock\", \"Verrouiller un salon\", \"`+lock [#salon]`\"),\n            (\"unlock\", \"D√©verrouiller un salon\", \"`+unlock [#salon]`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"üìù Format des dur√©es\",\n            value=\"`10s` = 10 secondes\\n`5m` = 5 minutes\\n`2h` = 2 heures\\n`1d` = 1 jour\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"üí° Vous pouvez utiliser les noms d'utilisateurs au lieu de les mentionner\")\n        \n        await ctx.send(embed=embed)\n    \n    async def _send_roles_help(self, ctx):\n        \"\"\"Envoie l'aide pour les commandes de gestion des r√¥les\"\"\"\n        embed = discord.Embed(\n            title=\"üëë Commandes de Gestion des R√¥les\",\n            description=\"Gestion compl√®te des r√¥les du serveur\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"addrole\", \"Ajouter un r√¥le √† un membre\", \"`+addrole <membre> <r√¥le>`\"),\n            (\"delrole\", \"Retirer un r√¥le d'un membre\", \"`+delrole <membre> <r√¥le>`\"),\n            (\"createrole\", \"Cr√©er un nouveau r√¥le\", \"`+createrole <nom> [couleur] [permissions]`\"),\n            (\"deleterole\", \"Supprimer un r√¥le\", \"`+deleterole <r√¥le>`\"),\n            (\"rolestats\", \"Statistiques d'un r√¥le\", \"`+rolestats <r√¥le>`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"üé® Couleurs disponibles\",\n            value=\"`rouge`, `bleu`, `vert`, `jaune`, `orange`, `violet`, `rose`, `cyan`, `noir`, `blanc` ou `#RRGGBB`\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"üîê Permissions sp√©ciales\",\n            value=\"`admin` = toutes les permissions\\n`mod` = permissions de mod√©ration\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"üí° Vous pouvez utiliser les noms de r√¥les et membres directement\")\n        \n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(HelpCommand(bot))","size_bytes":7113},"cogs/moderation.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nimport time\nfrom typing import Optional\nfrom utils.permissions import has_permission\nfrom utils.helpers import parse_time, format_time, get_or_fetch_user, get_mute_role\nfrom utils.converters import MemberConverter, UserConverter\n\nclass Moderation(commands.Cog):\n    \"\"\"Moderation commands for managing users and maintaining order\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"ban\")\n    @has_permission()\n    async def ban_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Ban a member from the server\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Vous ne pouvez pas vous bannir vous-m√™me.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Vous ne pouvez pas bannir quelqu'un avec un r√¥le sup√©rieur ou √©gal.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Send DM to user before banning\n            try:\n                dm_embed = discord.Embed(\n                    title=\"üî® Vous avez √©t√© banni\",\n                    description=f\"Vous avez √©t√© banni de **{ctx.guild.name}**\",\n                    color=self.bot.config.error_color\n                )\n                dm_embed.add_field(name=\"Raison\", value=reason, inline=False)\n                dm_embed.add_field(name=\"Mod√©rateur\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await member.ban(reason=f\"{reason} | Moderator: {ctx.author}\")\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"ban\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"ban\", reason\n            )\n            \n            embed = discord.Embed(\n                title=\"üî® Utilisateur banni\",\n                description=f\"**{member}** a √©t√© banni.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Raison\", value=reason, inline=False)\n            embed.add_field(name=\"Mod√©rateur\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"I don't have permission to ban this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to ban user: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"unban\")\n    @has_permission()\n    async def unban_user(self, ctx, user: UserConverter):\n        \"\"\"Unban a user by their ID\"\"\"\n        try:\n            await ctx.guild.unban(user, reason=f\"Unbanned by {ctx.author}\")\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, user.id, ctx.author.id, \"unban\"\n            )\n            \n            embed = discord.Embed(\n                title=\"‚úÖ Utilisateur d√©banni\",\n                description=f\"**{user}** a √©t√© d√©banni.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Mod√©rateur\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.NotFound:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Utilisateur introuvable ou non banni.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to unban user: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"kick\")\n    @has_permission()\n    async def kick_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Kick a member from the server\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"You cannot kick yourself.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"You cannot kick someone with a higher or equal role.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Send DM to user before kicking\n            try:\n                dm_embed = discord.Embed(\n                    title=\"üë¢ You have been kicked\",\n                    description=f\"You have been kicked from **{ctx.guild.name}**\",\n                    color=self.bot.config.warning_color\n                )\n                dm_embed.add_field(name=\"Reason\", value=reason, inline=False)\n                dm_embed.add_field(name=\"Moderator\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await member.kick(reason=f\"{reason} | Moderator: {ctx.author}\")\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"kick\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"kick\", reason\n            )\n            \n            embed = discord.Embed(\n                title=\"üë¢ User Kicked\",\n                description=f\"**{member}** has been kicked.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Reason\", value=reason, inline=False)\n            embed.add_field(name=\"Moderator\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"I don't have permission to kick this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to kick user: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"mute\")\n    @has_permission()\n    async def mute_user(self, ctx, member: MemberConverter, duration: Optional[str] = None, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Mute a member (prevent them from sending messages)\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"You cannot mute yourself.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"You cannot mute someone with a higher or equal role.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Parse duration\n        duration_seconds = None\n        muted_until = None\n        if duration:\n            duration_seconds = parse_time(duration)\n            if duration_seconds:\n                muted_until = time.time() + duration_seconds\n        \n        try:\n            # Get or create mute role\n            mute_role = await get_mute_role(ctx.guild)\n            if not mute_role:\n                embed = discord.Embed(\n                    title=\"‚ùå Error\",\n                    description=\"Failed to create mute role. Check bot permissions.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            # Add mute role to member\n            await member.add_roles(mute_role, reason=f\"Muted by {ctx.author}: {reason}\")\n            \n            # Add to database\n            await self.bot.db.add_mute(\n                ctx.guild.id, member.id, muted_until, reason, ctx.author.id\n            )\n            \n            # Log the infraction\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"mute\", reason, duration_seconds\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"mute\", reason,\n                f\"Duration: {duration if duration else 'Permanent'}\"\n            )\n            \n            duration_text = format_time(duration_seconds) if duration_seconds else \"Permanent\"\n            await ctx.send(f\"üîá **{member}** mut√©. Dur√©e: {duration_text}. Raison: {reason}\")\n            \n            # Schedule unmute if duration is set\n            if duration_seconds:\n                await asyncio.sleep(duration_seconds)\n                try:\n                    if await self.bot.db.is_user_muted(ctx.guild.id, member.id):\n                        await member.remove_roles(mute_role, reason=\"Mute duration expired\")\n                        await self.bot.db.remove_mute(ctx.guild.id, member.id)\n                except:\n                    pass  # User might have left the server\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"I don't have permission to mute this user.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to mute user: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"unmute\")\n    @has_permission()\n    async def unmute_user(self, ctx, member: MemberConverter):\n        \"\"\"Unmute a member\"\"\"\n        try:\n            # Check if user is actually muted\n            is_muted = await self.bot.db.is_user_muted(ctx.guild.id, member.id)\n            if not is_muted:\n                embed = discord.Embed(\n                    title=\"‚ùå Error\",\n                    description=\"This user is not muted.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            # Get mute role\n            mute_role = discord.utils.get(ctx.guild.roles, name=\"Muted\")\n            if mute_role and mute_role in member.roles:\n                await member.remove_roles(mute_role, reason=f\"Unmuted by {ctx.author}\")\n            \n            # Remove from database\n            await self.bot.db.remove_mute(ctx.guild.id, member.id)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"unmute\"\n            )\n            \n            await ctx.send(f\"üîä **{member}** n'est plus mut√©.\")\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to unmute user: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"mutelist\")\n    @has_permission()\n    async def mute_list(self, ctx):\n        \"\"\"Show list of currently muted users\"\"\"\n        try:\n            muted_users = await self.bot.db.get_muted_users(ctx.guild.id)\n            \n            if not muted_users:\n                embed = discord.Embed(\n                    title=\"üîá Muted Users\",\n                    description=\"No users are currently muted.\",\n                    color=self.bot.config.embed_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            embed = discord.Embed(\n                title=\"üîá Muted Users\",\n                color=self.bot.config.embed_color\n            )\n            \n            for mute_data in muted_users[:10]:  # Limit to 10 users\n                user = await get_or_fetch_user(self.bot, mute_data['user_id'])\n                user_name = str(user) if user else f\"Unknown User ({mute_data['user_id']})\"\n                \n                duration = \"Permanent\"\n                if mute_data['muted_until']:\n                    remaining = float(mute_data['muted_until']) - time.time()\n                    if remaining > 0:\n                        duration = f\"Expires in {format_time(int(remaining))}\"\n                    else:\n                        duration = \"Expired\"\n                \n                embed.add_field(\n                    name=user_name,\n                    value=f\"**Reason:** {mute_data['reason']}\\n**Duration:** {duration}\",\n                    inline=False\n                )\n            \n            if len(muted_users) > 10:\n                embed.set_footer(text=f\"Showing 10 of {len(muted_users)} muted users\")\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to retrieve muted users: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"warn\")\n    @has_permission()\n    async def warn_user(self, ctx, member: MemberConverter, *, reason: str = \"Aucune raison fournie\"):\n        \"\"\"Give a warning to a member\"\"\"\n        if member == ctx.author:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"You cannot warn yourself.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            # Add warning to database\n            await self.bot.db.add_infraction(\n                ctx.guild.id, member.id, ctx.author.id, \"warn\", reason\n            )\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"warn\", reason\n            )\n            \n            # Send DM to user\n            try:\n                dm_embed = discord.Embed(\n                    title=\"‚ö†Ô∏è You have received a warning\",\n                    description=f\"You have been warned in **{ctx.guild.name}**\",\n                    color=self.bot.config.warning_color\n                )\n                dm_embed.add_field(name=\"Reason\", value=reason, inline=False)\n                dm_embed.add_field(name=\"Moderator\", value=str(ctx.author), inline=False)\n                await member.send(embed=dm_embed)\n            except:\n                pass  # User has DMs disabled\n            \n            await ctx.send(f\"‚ö†Ô∏è **{member}** a √©t√© averti. Raison: {reason}\")\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to warn user: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"infractions\")\n    @has_permission()\n    async def show_infractions(self, ctx, member: MemberConverter):\n        \"\"\"Show infractions for a member\"\"\"\n        try:\n            infractions = await self.bot.db.get_user_infractions(ctx.guild.id, member.id)\n            \n            if not infractions:\n                embed = discord.Embed(\n                    title=\"üìã User Infractions\",\n                    description=f\"**{member}** has no infractions.\",\n                    color=self.bot.config.embed_color\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            embed = discord.Embed(\n                title=\"üìã User Infractions\",\n                description=f\"Infractions for **{member}**\",\n                color=self.bot.config.embed_color\n            )\n            \n            for i, infraction in enumerate(infractions[:10], 1):  # Limit to 10 infractions\n                moderator = await get_or_fetch_user(self.bot, infraction['moderator_id'])\n                moderator_name = str(moderator) if moderator else \"Unknown Moderator\"\n                \n                value = f\"**Reason:** {infraction['reason'] or 'No reason'}\\n\"\n                value += f\"**Moderator:** {moderator_name}\\n\"\n                value += f\"**Date:** {infraction['created_at']}\"\n                \n                if infraction['duration']:\n                    value += f\"\\n**Duration:** {format_time(infraction['duration'])}\"\n                \n                embed.add_field(\n                    name=f\"{i}. {infraction['type'].title()}\",\n                    value=value,\n                    inline=False\n                )\n            \n            if len(infractions) > 10:\n                embed.set_footer(text=f\"Showing 10 of {len(infractions)} infractions\")\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to retrieve infractions: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"clear\")\n    @has_permission()\n    async def clear_messages(self, ctx, amount: int):\n        \"\"\"Clear a specified number of messages\"\"\"\n        if amount <= 0 or amount > 100:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"Amount must be between 1 and 100.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            deleted = await ctx.channel.purge(limit=amount + 1)  # +1 to include the command message\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"clear\", \n                f\"Cleared {len(deleted) - 1} messages in {ctx.channel.name}\"\n            )\n            \n            # Send confirmation and delete after 5 seconds\n            await ctx.send(f\"üßπ {len(deleted) - 1} messages supprim√©s.\", delete_after=5)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"I don't have permission to delete messages.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to clear messages: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"lock\")\n    @has_permission()\n    async def lock_channel(self, ctx, channel: Optional[discord.TextChannel] = None):\n        \"\"\"Lock a channel (prevent @everyone from sending messages)\"\"\"\n        channel = channel or ctx.channel\n        \n        try:\n            overwrite = channel.overwrites_for(ctx.guild.default_role)\n            overwrite.send_messages = False\n            await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"lock\", f\"Locked channel {channel.name}\"\n            )\n            \n            embed = discord.Embed(\n                title=\"üîí Channel Locked\",\n                description=f\"{channel.mention} has been locked.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Moderator\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"I don't have permission to manage this channel.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to lock channel: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"unlock\")\n    @has_permission()\n    async def unlock_channel(self, ctx, channel: Optional[discord.TextChannel] = None):\n        \"\"\"Unlock a channel (allow @everyone to send messages)\"\"\"\n        channel = channel or ctx.channel\n        \n        try:\n            overwrite = channel.overwrites_for(ctx.guild.default_role)\n            overwrite.send_messages = None  # Reset to default\n            await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)\n            \n            # Log moderation action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"unlock\", f\"Unlocked channel {channel.name}\"\n            )\n            \n            embed = discord.Embed(\n                title=\"üîì Channel Unlocked\",\n                description=f\"{channel.mention} has been unlocked.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Moderator\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=\"I don't have permission to manage this channel.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Error\",\n                description=f\"Failed to unlock channel: {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(Moderation(bot))\n","size_bytes":23800},"cogs/roles.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Optional\nfrom utils.permissions import has_permission\nfrom utils.converters import MemberConverter, RoleConverter\n\nclass RoleManagement(commands.Cog):\n    \"\"\"Gestion des r√¥les du serveur\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"addrole\")\n    @has_permission()\n    async def add_role(self, ctx, member: MemberConverter, role: RoleConverter):\n        \"\"\"Ajouter un r√¥le √† un membre\"\"\"\n        if member == ctx.author and not ctx.author.guild_permissions.administrator:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Vous ne pouvez pas vous ajouter des r√¥les √† vous-m√™me.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # V√©rifier la hi√©rarchie des r√¥les\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Vous ne pouvez pas g√©rer un r√¥le sup√©rieur ou √©gal au v√¥tre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Je ne peux pas g√©rer ce r√¥le car il est sup√©rieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # V√©rifier si le membre a d√©j√† le r√¥le\n        if role in member.roles:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=f\"**{member}** poss√®de d√©j√† le r√¥le {role.mention}.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            await member.add_roles(role, reason=f\"Ajout√© par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"addrole\", \n                f\"R√¥le {role.name} ajout√©\"\n            )\n            \n            await ctx.send(f\"‚úÖ R√¥le {role.mention} ajout√© √† **{member}**.\")\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Je n'ai pas la permission d'ajouter ce r√¥le.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=f\"√âchec de l'ajout du r√¥le : {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"delrole\", aliases=[\"removerole\"])\n    @has_permission()\n    async def remove_role(self, ctx, member: MemberConverter, role: RoleConverter):\n        \"\"\"Retirer un r√¥le d'un membre\"\"\"\n        if member == ctx.author and not ctx.author.guild_permissions.administrator:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Vous ne pouvez pas vous retirer des r√¥les √† vous-m√™me.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # V√©rifier la hi√©rarchie des r√¥les\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Vous ne pouvez pas g√©rer un r√¥le sup√©rieur ou √©gal au v√¥tre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Je ne peux pas g√©rer ce r√¥le car il est sup√©rieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # V√©rifier si le membre a le r√¥le\n        if role not in member.roles:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=f\"**{member}** ne poss√®de pas le r√¥le {role.mention}.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        try:\n            await member.remove_roles(role, reason=f\"Retir√© par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, member.id, ctx.author.id, \"delrole\", \n                f\"R√¥le {role.name} retir√©\"\n            )\n            \n            await ctx.send(f\"‚úÖ R√¥le {role.mention} retir√© de **{member}**.\")\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Je n'ai pas la permission de retirer ce r√¥le.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=f\"√âchec du retrait du r√¥le : {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"createrole\")\n    @has_permission()\n    async def create_role(self, ctx, name: str, color: str = None, *, permissions: str = None):\n        \"\"\"Cr√©er un nouveau r√¥le\"\"\"\n        # V√©rifier si le r√¥le existe d√©j√†\n        if discord.utils.get(ctx.guild.roles, name=name):\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=f\"Un r√¥le nomm√© **{name}** existe d√©j√†.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # Traitement de la couleur\n        role_color = discord.Color.default()\n        if color:\n            try:\n                if color.startswith('#'):\n                    role_color = discord.Color(int(color[1:], 16))\n                else:\n                    # Couleurs pr√©d√©finies\n                    color_map = {\n                        'rouge': discord.Color.red(),\n                        'bleu': discord.Color.blue(),\n                        'vert': discord.Color.green(),\n                        'jaune': discord.Color.yellow(),\n                        'orange': discord.Color.orange(),\n                        'violet': discord.Color.purple(),\n                        'rose': discord.Color.magenta(),\n                        'cyan': discord.Color.teal(),\n                        'noir': discord.Color.from_rgb(0, 0, 0),\n                        'blanc': discord.Color.from_rgb(255, 255, 255)\n                    }\n                    role_color = color_map.get(color.lower(), discord.Color.default())\n            except ValueError:\n                embed = discord.Embed(\n                    title=\"‚ùå Couleur invalide\",\n                    description=\"Format de couleur invalide. Utilisez #RRGGBB ou un nom de couleur.\",\n                    color=self.bot.config.error_color\n                )\n                await ctx.send(embed=embed)\n                return\n        \n        # Traitement des permissions (optionnel - par d√©faut aucune permission sp√©ciale)\n        role_permissions = discord.Permissions.none()\n        if permissions:\n            if 'admin' in permissions.lower():\n                role_permissions = discord.Permissions.all()\n            elif 'mod' in permissions.lower() or 'moderator' in permissions.lower():\n                role_permissions = discord.Permissions(\n                    manage_messages=True,\n                    kick_members=True,\n                    ban_members=True,\n                    manage_roles=True\n                )\n        \n        try:\n            new_role = await ctx.guild.create_role(\n                name=name,\n                color=role_color,\n                permissions=role_permissions,\n                reason=f\"Cr√©√© par {ctx.author}\"\n            )\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"createrole\", \n                f\"R√¥le {name} cr√©√©\"\n            )\n            \n            embed = discord.Embed(\n                title=\"‚úÖ R√¥le cr√©√©\",\n                description=f\"Le r√¥le {new_role.mention} a √©t√© cr√©√© avec succ√®s.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Nom\", value=name, inline=True)\n            embed.add_field(name=\"Couleur\", value=color or \"D√©faut\", inline=True)\n            embed.add_field(name=\"ID\", value=new_role.id, inline=True)\n            embed.add_field(name=\"Cr√©√© par\", value=ctx.author.mention, inline=False)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Je n'ai pas la permission de cr√©er des r√¥les.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=f\"√âchec de la cr√©ation du r√¥le : {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"deleterole\")\n    @has_permission()\n    async def delete_role(self, ctx, role: RoleConverter):\n        \"\"\"Supprimer un r√¥le existant\"\"\"\n        # V√©rifier la hi√©rarchie des r√¥les\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Vous ne pouvez pas supprimer un r√¥le sup√©rieur ou √©gal au v√¥tre.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if role >= ctx.guild.me.top_role:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Je ne peux pas supprimer ce r√¥le car il est sup√©rieur au mien.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        # V√©rifier s'il s'agit d'un r√¥le syst√®me\n        if role.is_default() or role.managed:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Ce r√¥le ne peut pas √™tre supprim√© (r√¥le syst√®me ou g√©r√© par une int√©gration).\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        role_name = role.name\n        member_count = len(role.members)\n        \n        try:\n            await role.delete(reason=f\"Supprim√© par {ctx.author}\")\n            \n            # Log de l'action\n            await self.bot.db.log_moderation_action(\n                ctx.guild.id, 0, ctx.author.id, \"deleterole\", \n                f\"R√¥le {role_name} supprim√©\"\n            )\n            \n            embed = discord.Embed(\n                title=\"‚úÖ R√¥le supprim√©\",\n                description=f\"Le r√¥le **{role_name}** a √©t√© supprim√©.\",\n                color=self.bot.config.success_color\n            )\n            embed.add_field(name=\"Membres affect√©s\", value=member_count, inline=True)\n            embed.add_field(name=\"Supprim√© par\", value=ctx.author.mention, inline=True)\n            await ctx.send(embed=embed)\n            \n        except discord.Forbidden:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=\"Je n'ai pas la permission de supprimer ce r√¥le.\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"‚ùå Erreur\",\n                description=f\"√âchec de la suppression du r√¥le : {str(e)}\",\n                color=self.bot.config.error_color\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name=\"rolestats\", aliases=[\"roleinfo\"])\n    @has_permission()\n    async def role_stats(self, ctx, role: RoleConverter):\n        \"\"\"Afficher les statistiques d'un r√¥le\"\"\"\n        members_with_role = role.members\n        \n        embed = discord.Embed(\n            title=f\"üìä Statistiques du r√¥le {role.name}\",\n            color=role.color if role.color != discord.Color.default() else self.bot.config.embed_color\n        )\n        \n        embed.add_field(name=\"Nom\", value=role.name, inline=True)\n        embed.add_field(name=\"ID\", value=role.id, inline=True)\n        embed.add_field(name=\"Membres\", value=len(members_with_role), inline=True)\n        \n        embed.add_field(name=\"Position\", value=role.position, inline=True)\n        embed.add_field(name=\"Couleur\", value=str(role.color), inline=True)\n        embed.add_field(name=\"Mentionnable\", value=\"Oui\" if role.mentionable else \"Non\", inline=True)\n        \n        embed.add_field(name=\"Affich√© s√©par√©ment\", value=\"Oui\" if role.hoist else \"Non\", inline=True)\n        embed.add_field(name=\"G√©r√© par bot\", value=\"Oui\" if role.managed else \"Non\", inline=True)\n        embed.add_field(name=\"Cr√©√© le\", value=role.created_at.strftime(\"%d/%m/%Y √† %H:%M\"), inline=True)\n        \n        # Liste des membres (limit√© √† 20 pour √©viter les messages trop longs)\n        if members_with_role:\n            member_list = []\n            for i, member in enumerate(members_with_role[:20]):\n                member_list.append(f\"{i+1}. {member.mention}\")\n            \n            members_text = \"\\n\".join(member_list)\n            if len(members_with_role) > 20:\n                members_text += f\"\\n... et {len(members_with_role) - 20} autres\"\n            \n            embed.add_field(\n                name=\"Membres poss√©dant ce r√¥le\",\n                value=members_text,\n                inline=False\n            )\n        else:\n            embed.add_field(\n                name=\"Membres poss√©dant ce r√¥le\",\n                value=\"Aucun membre ne poss√®de ce r√¥le.\",\n                inline=False\n            )\n        \n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(RoleManagement(bot))","size_bytes":14864},"cogs/triggers.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\n\nclass Triggers(commands.Cog):\n    \"\"\"Gestion des triggers automatiques et protections de salons\"\"\"\n\n    def __init__(self, bot):\n        self.bot = bot\n\n        # üîπ Salons prot√©g√©s (texte interdit hors threads)\n        self.protected_channels = [\n            1402704269458673826,\n            1394459808106676314,\n            1393676148629573807\n        ]\n\n        # üîπ Salons avec r√©actions automatiques (uniquement emojis anim√©s)\n        self.react_channels = {\n            1408082781887664201: [\n                \"<a:mochi:1408874019788423209>\",\n                \"<a:refused:1408873542078173245>\"\n            ],\n            1393676148629573802: [\n                \"<a:mochi:1408874019788423209>\",\n                \"<a:refused:1408873542078173245>\"\n            ]\n        }\n\n        # üîπ Salon selfie pour embed automatique\n        self.selfie_channel_id = 1393676148629573807\n\n        # üîπ Lock pour √©viter les doublons\n        self.processed_messages = set()\n\n    @commands.Cog.listener()\n    async def on_message(self, message: discord.Message):\n        # Ignorer les bots et webhooks\n        if message.author.bot or message.webhook_id:\n            return\n\n        # Eviter de traiter plusieurs fois le m√™me message\n        if message.id in self.processed_messages:\n            return\n        self.processed_messages.add(message.id)\n\n        # Gestion salons prot√©g√©s\n        await self.handle_blocked_channels(message)\n\n        # R√©actions automatiques\n        await self.handle_auto_reactions(message)\n\n        # Embed automatique pour selfies\n        await self.handle_selfie_embed(message)\n\n    async def handle_blocked_channels(self, message: discord.Message):\n        if message.channel.id not in self.protected_channels:\n            return\n        if isinstance(message.channel, discord.Thread):\n            return\n        if message.content and message.content.strip():\n            try:\n                await message.delete()\n                warn_msg = await message.channel.send(\n                    \"‚ö†Ô∏è Les messages texte ne sont autoris√©s que dans les threads !\"\n                )\n                await asyncio.sleep(5)\n                await warn_msg.delete()\n            except Exception as e:\n                print(f\"[‚ùå] Erreur handle_blocked_channels: {e}\")\n\n    async def handle_auto_reactions(self, message: discord.Message):\n        if message.channel.id not in self.react_channels:\n            return\n        for emoji in self.react_channels[message.channel.id]:\n            if emoji.startswith(\"<a:\"):\n                try:\n                    await message.add_reaction(emoji)\n                except Exception as e:\n                    print(f\"[‚ùå] Erreur en ajoutant {emoji}: {e}\")\n\n    async def handle_selfie_embed(self, message: discord.Message):\n        if message.channel.id != self.selfie_channel_id:\n            return\n        if not message.attachments:\n            return\n\n        # Eviter d‚Äôenvoyer plusieurs embeds pour le m√™me message\n        if getattr(message, \"_embed_sent\", False):\n            return\n        message._embed_sent = True\n\n        embed = discord.Embed(\n            title=\"<:rules:1407738894480314480> __**R√®gles du serveur**__\",\n            description=\"__**Les trolls seront sanctionn√©s imm√©diatement**__, veuillez *respecter les autres* pour que notre communaut√© reste agr√©able et conviviale.\",\n            color=0x0055FF\n        )\n        embed.set_thumbnail(url=\"https://giffiles.alphacoders.com/219/219182.gif\")\n        embed.set_image(url=message.attachments[0].url)\n\n        try:\n            await message.channel.send(embed=embed)\n        except Exception as e:\n            print(f\"[‚ùå] Erreur handle_selfie_embed: {e}\")\n\nasync def setup(bot):\n    await bot.add_cog(Triggers(bot))\n","size_bytes":3839},"utils/converters.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Union\n\nclass MemberConverter(commands.MemberConverter):\n    \"\"\"Custom member converter that accepts names, mentions, and IDs\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.Member:\n        # Try the default converter first (mentions and IDs)\n        try:\n            return await super().convert(ctx, argument)\n        except commands.MemberNotFound:\n            pass\n        \n        # Search by username or display name\n        argument = argument.lower()\n        for member in ctx.guild.members:\n            if (member.name.lower() == argument or \n                member.display_name.lower() == argument or\n                argument in member.name.lower() or\n                argument in member.display_name.lower()):\n                return member\n        \n        raise commands.MemberNotFound(f\"Membre '{argument}' introuvable.\")\n\nclass RoleConverter(commands.RoleConverter):\n    \"\"\"Custom role converter that accepts names, mentions, and IDs\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.Role:\n        # Try the default converter first (mentions and IDs)\n        try:\n            return await super().convert(ctx, argument)\n        except commands.RoleNotFound:\n            pass\n        \n        # Search by role name\n        argument = argument.lower()\n        for role in ctx.guild.roles:\n            if (role.name.lower() == argument or\n                argument in role.name.lower()):\n                return role\n        \n        raise commands.RoleNotFound(f\"R√¥le '{argument}' introuvable.\")\n\nclass UserConverter(commands.UserConverter):\n    \"\"\"Custom user converter for unban command\"\"\"\n    \n    async def convert(self, ctx, argument: str) -> discord.User:\n        # Try to convert as user ID first\n        try:\n            user_id = int(argument)\n            user = await ctx.bot.fetch_user(user_id)\n            return user\n        except (ValueError, discord.NotFound):\n            pass\n        \n        # Try the default converter\n        try:\n            return await super().convert(ctx, argument)\n        except commands.UserNotFound:\n            pass\n        \n        raise commands.UserNotFound(f\"Utilisateur '{argument}' introuvable.\")","size_bytes":2261},"utils/helpers.py":{"content":"import re\nimport time\nfrom typing import Optional\n\ndef parse_time(time_str: str) -> Optional[int]:\n    \"\"\"Parse time string like '1h30m' into seconds\"\"\"\n    if not time_str:\n        return None\n    \n    time_regex = re.compile(r'(\\d+)([smhdw])')\n    matches = time_regex.findall(time_str.lower())\n    \n    if not matches:\n        return None\n    \n    total_seconds = 0\n    time_units = {'s': 1, 'm': 60, 'h': 3600, 'd': 86400, 'w': 604800}\n    \n    for amount, unit in matches:\n        total_seconds += int(amount) * time_units.get(unit, 0)\n    \n    return total_seconds\n\ndef format_time(seconds: int) -> str:\n    \"\"\"Format seconds into human readable time\"\"\"\n    if seconds < 60:\n        return f\"{seconds}s\"\n    elif seconds < 3600:\n        return f\"{seconds // 60}m {seconds % 60}s\"\n    elif seconds < 86400:\n        hours = seconds // 3600\n        minutes = (seconds % 3600) // 60\n        return f\"{hours}h {minutes}m\"\n    else:\n        days = seconds // 86400\n        hours = (seconds % 86400) // 3600\n        return f\"{days}d {hours}h\"\n\ndef format_timestamp(timestamp: float) -> str:\n    \"\"\"Format timestamp into readable date\"\"\"\n    import datetime\n    dt = datetime.datetime.fromtimestamp(timestamp)\n    return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n\nasync def get_or_fetch_user(bot, user_id: int):\n    \"\"\"Get user from cache or fetch from API\"\"\"\n    user = bot.get_user(user_id)\n    if user:\n        return user\n    \n    try:\n        user = await bot.fetch_user(user_id)\n        return user\n    except:\n        return None\n\nasync def get_mute_role(guild, create_if_missing=True):\n    \"\"\"Get or create mute role for the guild\"\"\"\n    import discord\n    \n    # Look for existing mute role\n    mute_role = discord.utils.get(guild.roles, name=\"Muted\")\n    \n    if mute_role:\n        return mute_role\n    \n    if not create_if_missing:\n        return None\n    \n    # Create mute role\n    try:\n        mute_role = await guild.create_role(\n            name=\"Muted\",\n            color=discord.Color.dark_grey(),\n            reason=\"Auto-created mute role\"\n        )\n        \n        # Set permissions for mute role in all channels\n        for channel in guild.channels:\n            if isinstance(channel, discord.TextChannel):\n                await channel.set_permissions(\n                    mute_role,\n                    send_messages=False,\n                    add_reactions=False,\n                    speak=False\n                )\n            elif isinstance(channel, discord.VoiceChannel):\n                await channel.set_permissions(\n                    mute_role,\n                    speak=False,\n                    connect=False\n                )\n        \n        return mute_role\n    except discord.Forbidden:\n        return None\n","size_bytes":2738},"utils/permissions.py":{"content":"import discord\nfrom discord.ext import commands\n\nclass PermissionError(commands.CheckFailure):\n    \"\"\"Custom exception for permission errors\"\"\"\n    pass\n\ndef has_permission():\n    \"\"\"Decorator to check if user has permission to use command\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Check if user has permission\n        has_perm = await ctx.bot.check_permissions(ctx, ctx.command.name)\n        if not has_perm:\n            raise PermissionError(\"You don't have permission to use this command.\")\n        \n        # Check cooldown\n        on_cooldown = not await ctx.bot.check_cooldown(ctx, ctx.command.name)\n        if on_cooldown:\n            cooldown_time = await ctx.bot.db.get_command_cooldown(ctx.guild.id, ctx.command.name)\n            from discord.ext.commands import Cooldown\n            cooldown = Cooldown(1, cooldown_time or 60)\n            raise commands.CommandOnCooldown(cooldown, cooldown_time or 60, commands.BucketType.user)\n        \n        return True\n    \n    return commands.check(predicate)\n\ndef admin_only():\n    \"\"\"Decorator for admin-only commands\"\"\"\n    async def predicate(ctx):\n        if not ctx.guild:\n            return False\n        \n        # Bot owner can always use admin commands\n        if await ctx.bot.is_owner(ctx.author):\n            return True\n        \n        # Guild owner can always use admin commands\n        if ctx.author == ctx.guild.owner:\n            return True\n        \n        # Check if user has administrator permission\n        if ctx.author.guild_permissions.administrator:\n            return True\n        \n        raise PermissionError(\"You need administrator permissions to use this command.\")\n    \n    return commands.check(predicate)\n","size_bytes":1754},"cogs/ownership.py":{"content":"import discord\nfrom discord.ext import commands\nfrom typing import Optional\nfrom utils.converters import MemberConverter, UserConverter\n\ndef is_owner_or_buyer():\n    \"\"\"Check if user is owner or buyer\"\"\"\n    async def predicate(ctx):\n        buyer = await ctx.bot.db.get_buyer(ctx.guild.id)\n        is_owner = await ctx.bot.db.is_owner(ctx.guild.id, ctx.author.id)\n        return ctx.author.id == buyer or is_owner\n    \n    return commands.check(predicate)\n\ndef is_buyer_only():\n    \"\"\"Check if user is buyer only\"\"\"\n    async def predicate(ctx):\n        buyer = await ctx.bot.db.get_buyer(ctx.guild.id)\n        return ctx.author.id == buyer\n    \n    return commands.check(predicate)\n\nclass Ownership(commands.Cog):\n    \"\"\"Commandes de gestion de propri√©t√© et d'ownership\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.Cog.listener()\n    async def on_member_update(self, before, after):\n        \"\"\"Monitor nickname changes for leashed users\"\"\"\n        if before.nick != after.nick:\n            leash_info = await self.bot.db.get_leash_info(after.guild.id, after.id)\n            if leash_info:\n                # Get owner info\n                owner = after.guild.get_member(leash_info['owner_id'])\n                if owner:\n                    leash_nick = f\"üê∂ü¶Æ de {owner.display_name}\"\n                    if after.nick != leash_nick:\n                        try:\n                            await after.edit(nick=leash_nick, reason=\"Leash system - nickname protected\")\n                        except discord.Forbidden:\n                            pass\n    \n    @commands.command(name=\"massrole\")\n    @is_owner_or_buyer()\n    async def mass_role(self, ctx, role: discord.Role):\n        \"\"\"Donne un r√¥le √† tous les utilisateurs humains\"\"\"\n        if role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n            return await ctx.send(\"‚ùå Vous ne pouvez pas g√©rer un r√¥le sup√©rieur au v√¥tre.\")\n        \n        if role >= ctx.guild.me.top_role:\n            return await ctx.send(\"‚ùå Je ne peux pas g√©rer ce r√¥le car il est sup√©rieur au mien.\")\n        \n        humans = [member for member in ctx.guild.members if not member.bot and role not in member.roles]\n        \n        if not humans:\n            return await ctx.send(f\"‚ùå Aucun utilisateur humain √† ajouter au r√¥le {role.mention}.\")\n        \n        success_count = 0\n        for member in humans:\n            try:\n                await member.add_roles(role, reason=f\"Massrole par {ctx.author}\")\n                success_count += 1\n            except:\n                continue\n        \n        await ctx.send(f\"‚úÖ R√¥le {role.mention} ajout√© √† {success_count}/{len(humans)} utilisateurs.\")\n    \n    @commands.command(name=\"say\")\n    @is_owner_or_buyer()\n    async def say(self, ctx, *, message: str):\n        \"\"\"Fait parler le bot de mani√®re anonyme\"\"\"\n        await ctx.message.delete()\n        await ctx.send(message)\n    \n    @commands.command(name=\"dm\")\n    @is_owner_or_buyer()\n    async def dm_user(self, ctx, user: UserConverter, *, message: str):\n        \"\"\"Envoie un message priv√© via le bot\"\"\"\n        try:\n            await user.send(message)\n            await ctx.send(\"‚úÖ Message priv√© envoy√©.\")\n        except discord.Forbidden:\n            await ctx.send(\"‚ùå Impossible d'envoyer un message priv√© √† cet utilisateur.\")\n        except Exception as e:\n            await ctx.send(f\"‚ùå Erreur : {str(e)}\")\n    \n    @commands.command(name=\"laisse\")\n    @is_owner_or_buyer()\n    async def leash_user(self, ctx, member: MemberConverter):\n        \"\"\"Met un membre en laisse\"\"\"\n        if member == ctx.author:\n            return await ctx.send(\"‚ùå Vous ne pouvez pas vous mettre en laisse.\")\n        \n        if member.bot:\n            return await ctx.send(\"‚ùå Impossible de mettre un bot en laisse.\")\n        \n        # Check if already leashed\n        if await self.bot.db.is_leashed(ctx.guild.id, member.id):\n            return await ctx.send(\"‚ùå Ce membre est d√©j√† en laisse.\")\n        \n        original_nick = member.nick or member.name\n        leash_nick = f\"üê∂ü¶Æ de {ctx.author.display_name}\"\n        \n        try:\n            await member.edit(nick=leash_nick, reason=f\"Leash par {ctx.author}\")\n            await self.bot.db.add_leash(ctx.guild.id, member.id, ctx.author.id, original_nick)\n            await ctx.send(f\"ü¶Æ {member.mention} est maintenant en laisse.\")\n        except discord.Forbidden:\n            await ctx.send(\"‚ùå Je n'ai pas la permission de modifier ce pseudo.\")\n    \n    @commands.command(name=\"unlaisse\")\n    @is_owner_or_buyer()\n    async def unleash_user(self, ctx, member: MemberConverter):\n        \"\"\"Retire un membre de la laisse\"\"\"\n        leash_info = await self.bot.db.get_leash_info(ctx.guild.id, member.id)\n        if not leash_info:\n            return await ctx.send(\"‚ùå Ce membre n'est pas en laisse.\")\n        \n        try:\n            await member.edit(nick=leash_info['original_nick'], reason=f\"Unleash par {ctx.author}\")\n            await self.bot.db.remove_leash(ctx.guild.id, member.id)\n            await ctx.send(f\"‚ùå {member.mention} n'est plus en laisse.\")\n        except discord.Forbidden:\n            await ctx.send(\"‚ùå Je n'ai pas la permission de modifier ce pseudo.\")\n    \n    @commands.command(name=\"owner\")\n    @is_buyer_only()\n    async def add_owner(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter un owner\"\"\"\n        if member.bot:\n            return await ctx.send(\"‚ùå Impossible d'ajouter un bot comme owner.\")\n        \n        if await self.bot.db.is_owner(ctx.guild.id, member.id):\n            return await ctx.send(\"‚ùå Ce membre est d√©j√† owner.\")\n        \n        buyer = await self.bot.db.get_buyer(ctx.guild.id)\n        if member.id == buyer:\n            return await ctx.send(\"‚ùå Ce membre est d√©j√† le buyer.\")\n        \n        await self.bot.db.add_owner(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"‚úÖ {member.mention} a √©t√© promu owner.\")\n    \n    @commands.command(name=\"unowner\")\n    @is_buyer_only()\n    async def remove_owner(self, ctx, member: MemberConverter):\n        \"\"\"Retirer un owner\"\"\"\n        if not await self.bot.db.is_owner(ctx.guild.id, member.id):\n            return await ctx.send(\"‚ùå Ce membre n'est pas owner.\")\n        \n        await self.bot.db.remove_owner(ctx.guild.id, member.id)\n        await ctx.send(f\"‚ùå {member.mention} n'est plus owner.\")\n    \n    @commands.command(name=\"buyer\")\n    @is_buyer_only()\n    async def transfer_buyer(self, ctx, member: MemberConverter, code: str):\n        \"\"\"Transf√©rer la propri√©t√© du bot\"\"\"\n        if member.bot:\n            return await ctx.send(\"‚ùå Impossible de transf√©rer √† un bot.\")\n        \n        if not await self.bot.db.verify_recovery_code(ctx.guild.id, code):\n            return await ctx.send(\"‚ùå Code de r√©cup√©ration invalide.\")\n        \n        # Generate new recovery code\n        new_code = await self.bot.db.set_buyer(ctx.guild.id, member.id)\n        \n        # Remove from owners if they were one\n        await self.bot.db.remove_owner(ctx.guild.id, member.id)\n        \n        await ctx.send(f\"‚úÖ Propri√©t√© transf√©r√©e √† {member.mention}.\")\n        \n        try:\n            await member.send(f\"üîë Vous √™tes maintenant le buyer du bot sur **{ctx.guild.name}**.\\nNouveau code de r√©cup√©ration : `{new_code}`\")\n        except:\n            pass\n    \n    @commands.command(name=\"wl\")\n    @is_owner_or_buyer()\n    async def whitelist_add(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter en whitelist\"\"\"\n        if await self.bot.db.is_whitelisted(ctx.guild.id, member.id):\n            return await ctx.send(\"‚ùå Ce membre est d√©j√† en whitelist.\")\n        \n        await self.bot.db.add_whitelist(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"‚úÖ {member.mention} ajout√© √† la whitelist.\")\n    \n    @commands.command(name=\"unwl\")\n    @is_owner_or_buyer()\n    async def whitelist_remove(self, ctx, member: MemberConverter):\n        \"\"\"Retirer de la whitelist\"\"\"\n        if not await self.bot.db.is_whitelisted(ctx.guild.id, member.id):\n            return await ctx.send(\"‚ùå Ce membre n'est pas en whitelist.\")\n        \n        await self.bot.db.remove_whitelist(ctx.guild.id, member.id)\n        await ctx.send(f\"‚ùå {member.mention} retir√© de la whitelist.\")\n    \n    @commands.group(name=\"blrank\", invoke_without_command=True)\n    @is_owner_or_buyer()\n    async def blacklist_rank(self, ctx):\n        \"\"\"Afficher la liste blacklist-rank\"\"\"\n        blacklisted = await self.bot.db.get_blacklist_rank(ctx.guild.id)\n        \n        if not blacklisted:\n            return await ctx.send(\"üìã Aucun membre en blacklist-rank.\")\n        \n        members = []\n        for user_id in blacklisted[:20]:  # Limit√© √† 20\n            user = ctx.guild.get_member(user_id)\n            if user:\n                members.append(f\"‚Ä¢ {user.mention}\")\n        \n        if members:\n            await ctx.send(f\"üìã **Blacklist-rank :**\\\\n\" + \"\\\\n\".join(members))\n        else:\n            await ctx.send(\"üìã Aucun membre en blacklist-rank.\")\n    \n    @blacklist_rank.command(name=\"add\")\n    @is_owner_or_buyer()\n    async def blacklist_rank_add(self, ctx, member: MemberConverter):\n        \"\"\"Ajouter au blacklist-rank\"\"\"\n        if await self.bot.db.is_blacklist_rank(ctx.guild.id, member.id):\n            return await ctx.send(\"‚ùå Ce membre est d√©j√† en blacklist-rank.\")\n        \n        await self.bot.db.add_blacklist_rank(ctx.guild.id, member.id, ctx.author.id)\n        await ctx.send(f\"‚úÖ {member.mention} ajout√© au blacklist-rank.\")\n    \n    @blacklist_rank.command(name=\"del\")\n    @is_owner_or_buyer()\n    async def blacklist_rank_remove(self, ctx, member: MemberConverter):\n        \"\"\"Retirer du blacklist-rank\"\"\"\n        if not await self.bot.db.is_blacklist_rank(ctx.guild.id, member.id):\n            return await ctx.send(\"‚ùå Ce membre n'est pas en blacklist-rank.\")\n        \n        await self.bot.db.remove_blacklist_rank(ctx.guild.id, member.id)\n        await ctx.send(f\"‚ùå {member.mention} retir√© du blacklist-rank.\")\n    \n    @commands.command(name=\"setupbuyer\")\n    @commands.is_owner()\n    async def setup_buyer(self, ctx, member: MemberConverter):\n        \"\"\"Setup initial buyer (bot owner only)\"\"\"\n        recovery_code = await self.bot.db.set_buyer(ctx.guild.id, member.id)\n        await ctx.send(f\"‚úÖ {member.mention} d√©fini comme buyer initial.\")\n        \n        try:\n            await member.send(f\"üîë Vous √™tes maintenant le buyer du bot sur **{ctx.guild.name}**.\\nCode de r√©cup√©ration : `{recovery_code}`\")\n        except:\n            pass\n\nasync def setup(bot):\n    await bot.add_cog(Ownership(bot))","size_bytes":10725},"cogs/help_interactive.py":{"content":"import discord\nfrom discord.ext import commands\n\nclass HelpView(discord.ui.View):\n    \"\"\"Vue interactive pour le syst√®me d'aide\"\"\"\n    \n    def __init__(self, bot):\n        super().__init__(timeout=180)\n        self.bot = bot\n        \n    @discord.ui.button(label=\"üéõÔ∏è Administration\", style=discord.ButtonStyle.primary)\n    async def admin_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes d'administration\"\"\"\n        embed = discord.Embed(\n            title=\"üéõÔ∏è Commandes d'Administration\",\n            description=\"Gestion des permissions et configuration du bot\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"setperm\", \"Attribuer une permission\", \"`+setperm <commande> <r√¥le>`\"),\n            (\"unsetperm\", \"Retirer une permission\", \"`+unsetperm <commande> <r√¥le>`\"),\n            (\"perms\", \"Voir toutes les permissions\", \"`+perms`\"),\n            (\"resetperms\", \"R√©initialiser les permissions\", \"`+resetperms`\"),\n            (\"cooldown\", \"D√©finir un d√©lai d'attente\", \"`+cooldown <commande> <secondes>`\"),\n            (\"settings\", \"Voir les param√®tres du serveur\", \"`+settings`\"),\n            (\"prefix\", \"Changer le pr√©fixe\", \"`+prefix <nouveau_pr√©fixe>`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.set_footer(text=\"‚ö†Ô∏è Ces commandes n√©cessitent les permissions d'administrateur\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"üî® Mod√©ration\", style=discord.ButtonStyle.primary)\n    async def moderation_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes de mod√©ration\"\"\"\n        embed = discord.Embed(\n            title=\"üî® Commandes de Mod√©ration\",\n            description=\"Gestion et mod√©ration des membres\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"ban\", \"Bannir un membre\", \"`+ban <membre> [raison]`\"),\n            (\"unban\", \"D√©bannir un utilisateur\", \"`+unban <id_utilisateur>`\"),\n            (\"kick\", \"Expulser un membre\", \"`+kick <membre> [raison]`\"),\n            (\"mute\", \"Rendre muet un membre\", \"`+mute <membre> [dur√©e] [raison]`\"),\n            (\"unmute\", \"Enlever le mute\", \"`+unmute <membre>`\"),\n            (\"warn\", \"Avertir un membre\", \"`+warn <membre> [raison]`\"),\n            (\"infractions\", \"Voir l'historique d'un membre\", \"`+infractions <membre>`\"),\n            (\"mutelist\", \"Liste des membres mu√©s\", \"`+mutelist`\"),\n            (\"clear\", \"Supprimer des messages\", \"`+clear <nombre>`\"),\n            (\"lock\", \"Verrouiller un salon\", \"`+lock [#salon]`\"),\n            (\"unlock\", \"D√©verrouiller un salon\", \"`+unlock [#salon]`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"üìù Format des dur√©es\",\n            value=\"`10s` = 10 secondes\\n`5m` = 5 minutes\\n`2h` = 2 heures\\n`1d` = 1 jour\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"üí° Vous pouvez utiliser les noms d'utilisateurs au lieu de les mentionner\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"üëë R√¥les\", style=discord.ButtonStyle.primary)\n    async def roles_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes de gestion des r√¥les\"\"\"\n        embed = discord.Embed(\n            title=\"üëë Commandes de Gestion des R√¥les\",\n            description=\"Gestion compl√®te des r√¥les du serveur\",\n            color=self.bot.config.embed_color\n        )\n        \n        commands_list = [\n            (\"addrole\", \"Ajouter un r√¥le √† un membre\", \"`+addrole <membre> <r√¥le>`\"),\n            (\"delrole\", \"Retirer un r√¥le d'un membre\", \"`+delrole <membre> <r√¥le>`\"),\n            (\"createrole\", \"Cr√©er un nouveau r√¥le\", \"`+createrole <nom> [couleur] [permissions]`\"),\n            (\"deleterole\", \"Supprimer un r√¥le\", \"`+deleterole <r√¥le>`\"),\n            (\"rolestats\", \"Statistiques d'un r√¥le\", \"`+rolestats <r√¥le>`\")\n        ]\n        \n        for name, desc, usage in commands_list:\n            embed.add_field(\n                name=f\"`{name}`\",\n                value=f\"{desc}\\n{usage}\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"üé® Couleurs disponibles\",\n            value=\"`rouge`, `bleu`, `vert`, `jaune`, `orange`, `violet`, `rose`, `cyan`, `noir`, `blanc` ou `#RRGGBB`\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"üîê Permissions sp√©ciales\",\n            value=\"`admin` = toutes les permissions\\n`mod` = permissions de mod√©ration\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"üí° Vous pouvez utiliser les noms de r√¥les et membres directement\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"üë®‚Äçüíº Ownership\", style=discord.ButtonStyle.success)\n    async def ownership_help(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Affiche l'aide pour les commandes d'ownership\"\"\"\n        embed = discord.Embed(\n            title=\"üë®‚Äçüíº Commandes Ownership\",\n            description=\"Gestion avanc√©e du bot et propri√©t√©\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"üè¢ Commandes Owners\",\n            value=(\n                \"`massrole <r√¥le>` - Donne le r√¥le √† tous les humains\\n\"\n                \"`say <message>` - Fait parler le bot anonymement\\n\"\n                \"`dm <membre> <msg>` - Message priv√© via le bot\\n\"\n                \"`laisse <membre>` - Met en laisse (üê∂ü¶Æ)\\n\"\n                \"`unlaisse <membre>` - Retire de la laisse\\n\"\n                \"`wl <membre>` - Ajoute √† la whitelist anti-raid\\n\"\n                \"`unwl <membre>` - Retire de la whitelist\\n\"\n                \"`blrank add <membre>` - Ajoute au blacklist-rank\\n\"\n                \"`blrank del <membre>` - Retire du blacklist-rank\\n\"\n                \"`blrank` - Liste blacklist-rank\"\n            ),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"üîë Commandes Buyer (Propri√©taire)\",\n            value=(\n                \"`owner <membre>` - Ajoute un owner\\n\"\n                \"`unowner <membre>` - Retire un owner\\n\"\n                \"`buyer <membre> <code>` - Transfert la propri√©t√©\"\n            ),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"‚ÑπÔ∏è Hi√©rarchie\",\n            value=(\n                \"**Buyer** : Propri√©taire principal avec code de r√©cup√©ration\\n\"\n                \"**Owners** : Administrateurs avec privil√®ges √©tendus\\n\"\n                \"**Whitelist** : Immunit√© aux protections anti-raid\\n\"\n                \"**Blacklist-rank** : Protection contre attribution de r√¥les\"\n            ),\n            inline=False\n        )\n        \n        embed.set_footer(text=\"ü¶Æ Le syst√®me de laisse surveille automatiquement les pseudos\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    @discord.ui.button(label=\"üè† Menu Principal\", style=discord.ButtonStyle.secondary, row=1)\n    async def main_menu(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Retourne au menu principal\"\"\"\n        embed = discord.Embed(\n            title=\"üìö CrowBot Gestion V2 - Aide Interactive\",\n            description=\"Choisissez une cat√©gorie avec les boutons ci-dessous pour voir les commandes disponibles.\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"üéõÔ∏è Administration\",\n            value=\"Gestion des permissions et configuration\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"üî® Mod√©ration\", \n            value=\"Commandes de mod√©ration des membres\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"üëë R√¥les\", \n            value=\"Gestion compl√®te des r√¥les\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"üë®‚Äçüíº Ownership\", \n            value=\"Commandes avanc√©es propri√©t√©\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"‚ÑπÔ∏è Informations\",\n            value=f\"Pr√©fixe actuel : `+`\\nServeurs : {len(self.bot.guilds)}\\nVersion : 2.0\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"S√©lectionnez une cat√©gorie avec les boutons ci-dessous\")\n        await interaction.response.edit_message(embed=embed, view=self)\n    \n    async def on_timeout(self):\n        \"\"\"Appel√© quand la vue expire\"\"\"\n        # Disable all buttons when timeout\n        for item in self.children:\n            item.disabled = True\n\nclass HelpCommand(commands.Cog):\n    \"\"\"Syst√®me d'aide interactif du bot\"\"\"\n    \n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name=\"help\", aliases=[\"aide\", \"h\"])\n    async def help_command(self, ctx):\n        \"\"\"Affiche le menu d'aide interactif\"\"\"\n        \n        embed = discord.Embed(\n            title=\"üìö CrowBot Gestion V2 - Aide Interactive\",\n            description=\"Choisissez une cat√©gorie avec les boutons ci-dessous pour voir les commandes disponibles.\",\n            color=self.bot.config.embed_color\n        )\n        \n        embed.add_field(\n            name=\"üéõÔ∏è Administration\",\n            value=\"Gestion des permissions et configuration\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"üî® Mod√©ration\", \n            value=\"Commandes de mod√©ration des membres\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"üëë R√¥les\", \n            value=\"Gestion compl√®te des r√¥les\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"üë®‚Äçüíº Ownership\", \n            value=\"Commandes avanc√©es propri√©t√©\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"‚ÑπÔ∏è Informations\",\n            value=f\"Pr√©fixe actuel : `+`\\nServeurs : {len(self.bot.guilds)}\\nVersion : 2.0\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"S√©lectionnez une cat√©gorie avec les boutons ci-dessous\")\n        \n        view = HelpView(self.bot)\n        await ctx.send(embed=embed, view=view)\n\nasync def setup(bot):\n    await bot.add_cog(HelpCommand(bot))","size_bytes":10991}},"version":1}